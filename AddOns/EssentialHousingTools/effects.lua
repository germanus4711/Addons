if not EHT then EHT = { } end

local round = function( n, d ) if nil == d then return zo_roundToZero( n ) else return zo_roundToNearest( n, 1 / ( 10 ^ d ) ) end end
local RAD5, RAD15, RAD30, RAD45, RAD60, RAD80, RAD90, RAD120, RAD180, RAD270, RAD360, RAD720 = math.rad( 5 ), math.rad( 15 ), math.rad( 30 ), 0.25 * math.pi, math.rad(60), math.rad(80), 0.5 * math.pi, math.rad(120), math.pi, 1.5 * math.pi, 2 * math.pi, 4 * math.pi
local RADGL_LOW, RADGL_HIGH = math.rad( 89.8 ), math.rad( 90.2 )
local GOLDEN = ( 1 + math.sqrt( 5 ) ) / 2
local bit, hasbit, setbit, clearbit = EHT.Bit.New, EHT.Bit.Has, EHT.Bit.Set, EHT.Bit.Clear
local BIT1, BIT2, BIT4, BIT8 = bit( 1 ), bit( 2 ), bit( 3 ), bit( 4 )

local function rand( minVal, maxVal )
	if maxVal and not minVal then
		return 0 < maxVal and math.random( 0, maxVal ) or 0 > maxVal and math.random( maxVal, 0 ) or 0
	elseif maxVal and minVal then
		return maxVal > minVal and math.random( minVal, maxVal ) or maxVal < minVal and math.random( maxVal, minVal ) or minVal
	elseif not maxVal and minVal then
		return 0 < minVal and math.random( 0, minVal ) or 0 > minVal and math.random( minVal, 0 ) or 0
	else
		return math.random()
	end
end
EHT.Rand = rand

local enableDepthBuffer = true

do
	local TemporaryUpdateEvents = {}

	function EHT.RegisterTemporaryUpdateEvent(key, interval, handler)
		if not TemporaryUpdateEvents[key] then
			TemporaryUpdateEvents[key] = handler
			EVENT_MANAGER:RegisterForUpdate(key, interval, handler)
		end
	end

	function EHT.UnregisterTemporaryUpdateEvents()
		for key in pairs(TemporaryUpdateEvents) do
			EVENT_MANAGER:UnregisterForUpdate(key)
		end
	end
end

---[ Namespace and Class Declarations ]---

EHT.Effect = ZO_Object:Subclass()
EHT.EffectAnimation = ZO_Object:Subclass()
EHT.EffectEditor = ZO_Object:Subclass()
EHT.EffectType = ZO_Object:Subclass()
EHT.EffectLerp = ZO_Object:Subclass()
EHT.Particle = ZO_Object:Subclass()
EHT.ParticleEmitter = ZO_Object:Subclass()
EHT.World = ZO_Object:Subclass()

EHT.EffectDeserializers = { }
EHT.EffectSerializers = { }
EHT.Effects = { }
EHT.EffectUI = { }
EHT.DeferredEffects = { }

EHT.TotalEffectsInstantiated = 0
EHT.TotalParticlesInstantiated = 0
EHT.TotalParticlesRecycled = 0
EHT.EffectUpdateCostMS = 0

---[ Private Constants ]---

local RESET_POSITION = 1
local RESET_ORIENT = 2
local RESET_TRANSFORM = 4
local RESET_SCALE = 8
local RESET_COLOR = 16

local EFFECT_STATE_NEW = 1
local EFFECT_STATE_INITIALIZING = 2
local EFFECT_STATE_INITIALIZED = 3
local EFFECT_STATE_RESETTING = 4
local EFFECT_STATE_ACTIVE = 5
local EFFECT_STATE_NAMES =
{
	"New",
	"Initializing",
	"Initialized",
	"Resetting",
	"Active",
}

local MAX_EFFECTS = 2000
local V2_SET_SIZE_MIN_INDEX = 1001
local V2_SET_SIZE_MAX_INDEX = 1000
local EVENT_PREFIX = "EHTEffect"
local EFFECT_EDIT_BUTTONS_PREFIX = "EHTEffectEditButtons"
local EFFECT_EDITOR_PREFIX = "EHTEffectEditor"
local GLOBAL_EFFECTS_PREFIX = "EHTGlobalEffects"
local PARTICLE_PREFIX = "EHTParticle"
local NIL_TEXTURE = "nil"
local CHATCAST_VERSION = 18 -- Added Painting FX scaling and offset meta params
-- local CHATCAST_VERSION = 17
local CHATCAST_PREFIX = "EHTFX"
EHT.CHATCAST_PREFIX = CHATCAST_PREFIX
local MAX_META_STRING_LEN = 1800
local DRAW_LEVEL_EFFECTS = 10
local EFFECT_REFRESH_DELAY = 7000
local MAILCAST_SEND_TIMEOUT = 30 * 1000
local MAILCAST_SUBJECT = "Essential Housing Tools VFX"
local MAX_CHATCAST_LENGTH = 350
local MAX_GUILDCAST_LENGTH = 254
local MAX_MAILCAST_LENGTH = 700
local MAX_EDITOR_DRAW_LEVEL = 250000
-- REPLACED WITH LOCAL NUMBERS FOR PERF
-- local MAX_PARTICLE_DRAW_LEVEL = 200000
local DRAW_LEVEL_OVERLAY_EFFECT = 200000 * 1.2
local MAX_PARTICLE_INIT_TIME = 2000
local MAX_RETICLE_DISTANCE = 100000
local MAX_RETICLE_RADIUS = 70
local MIN_RETICLE_EFFECT_CLICK_TO_DRAG_DURATION = 300
local RETICLE_EFFECT_CLICK_TO_DRAG_INTERVAL = 50
local FLASH_RETICLE_TARGET_EFFECT_BUTTON

local MAX_REORDER_PARTICLES_DURATION = 2
local MAX_UPDATE_EFFECTS_DURATION = 3
local REORDER_PARTICLES_INTERVAL = 1
local UPDATE_EFFECTS_INTERVAL = 1

local CullCycle, MaxCullCycles, ParticlesCulled = 0, 4, 0

local MAX_LOCALIZED_DISTANCE = 2500
local PARTIAL_LOCALIZED_DISTANCE = 0.5 * MAX_LOCALIZED_DISTANCE

local DEFAULT_PARAM_TARGET_PLAYER_TEXT = "homeowner's @name"
local DEFAULT_PARAM_MESSAGE_TEXT = "type a message"
local DEFAULT_PARAM_NAME_TEXT = "Type a name"
local DEFAULT_PARAM_TITLE_TEXT = "Type a title"

EHT.Effects.MAX_EFFECTS = MAX_EFFECTS
EHT.Effects.MAX_EDITOR_DRAW_LEVEL = MAX_EDITOR_DRAW_LEVEL
EHT.Effects.MAX_PARTICLE_DRAW_LEVEL = 200000


EHT.EffectType.CATEGORY = {
	NONE = "",
	ACTION = "Actions",
	ANIM = "Animations",
	BUILD = "Building Materials",
	CUSTOM = "Home Customization",
	DECO = "Decorative",
	GEO = "Geometric Shapes",
	HERALDRY = "Heraldry",
	LAND = "Landscaping",
	LIBRARY = "Library",
	LIGHT = "Lighting",
	MAP = "Maps",
	NPC = "Non-Player Characters",
	PAINT = "Paintings and Murals",
	PET = "Critters and Pets",
	PORTALS = "Portals",
	SCENE = "Scenery",
	SIGIL = "Sigils and Runes",
	SKY = "Sky Overlays",
	SOUND = "Sound & Music",
	SUBMISSION = "Player Submissions",
	TEXT = "Text",
	WEATHER = "Weather",
}
local CAT = EHT.EffectType.CATEGORY

SKY_BOX_PRESETS = {
	["1"] = { X = 25721, Y = 20016, Z = 25954, SizeX = 562, SizeY = 602, SizeZ = 602, Pitch = nil, Yaw = nil, Roll = nil, Editable = true }, -- Mara's Kiss Public House
	["4"] = { X = 23578, Y = 10026, Z = 24257, SizeX = 770, SizeY = 500, SizeZ = 1, Pitch = nil, Yaw = nil, Roll = nil, Editable = true }, -- Barbed Hook Private Room
	["5"] = { X = 25593, Y = 20074, Z = 26170, SizeX = 910, SizeY = 600, SizeZ = 600, Pitch = nil, Yaw = nil, Roll = nil, Editable = true }, -- Sisters of the Sands Apartment
	["7"] = { X = 53067, Y = 13425, Z = 41902, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Black Vine Villa
	["9"] = { X = 27652, Y = 4096, Z = 50654, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Mathiisen Manor
	["10"] = { X = 27982, Y = 8000, Z = 37019, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Humblemud
	["11"] = { X = 49853, Y = 1, Z = 53835, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- The Ample Domicile
	["12"] = { X = 56301, Y = 1, Z = 32876, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Stay-Moist Mansion
	["13"] = { X = 20057, Y = 20024, Z = 24509, SizeX = 1362, SizeY = 715, SizeZ = 715, Pitch = 0, Yaw = nil, Roll = nil, Editable = true, }, -- Snugpod
	["14"] = { X = 48103, Y = 1, Z = 48141, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Bouldertree Refuge
	["15"] = { X = 24710, Y = 15823, Z = 65296, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- The Gorinir Estate
	["17"] = { X = 57644, Y = 1701, Z = 32753, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Ravenhurst
	["18"] = { X = 66592, Y = 1, Z = 74018, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Gardner House
	["20"] = { X = 51928, Y = 1181, Z = 47951, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Velothi Reverie
	["21"] = { X = 84171, Y = 1044, Z = 66392, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Quondam Indorilia
	["23"] = { X = 25058, Y = 659, Z = 23420, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Sleek Creek House
	["24"] = { X = 38611, Y = 5472, Z = 53702, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Dawnshadow
	["25"] = { X = 22350, Y = 12675, Z = 46687, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Cyrodilic Jungle House
	["26"] = { X = 44805, Y = 28614, Z = 56460, SizeX = 28860, SizeY = 52000, SizeZ = 52000, Pitch = math.rad( 0 ), Yaw = math.rad( 0 ), Roll = math.rad( 0 ) }, -- Domus Phrasticus
	["27"] = { X = 29941, Y = 293, Z = 21406, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Strident Springs Demesne
	["28"] = { X = 38655, Y = 6149, Z = 39361, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Autumn's-Gate
	["30"] = { X = 28061, Y = 12999, Z = 23040, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Old Mistveil Manor
	["32"] = { X = 46256, Y = 1, Z = 43239, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Mournoth Keep
	["33"] = { X = 45584, Y = 10841, Z = 51222, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Forsaken Stronghold
	["34"] = { X = 71701, Y = 1, Z = 37096, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Twin Arches
	["36"] = { X = 94560, Y = 1, Z = 71931, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Hunding's Palatial Hall
	["37"] = { X = 37032, Y = 6009, Z = 21205, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Serenity Falls Estate
	["38"] = { X = 95676, Y = 1, Z = 60396, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Daggerfall Overlook
	["39"] = { X = 80693, Y = 1, Z = 23754, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Ebonheart Chateau
	["40"] = { X = 64831, Y = 1, Z = 67034, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Grand Topal Hideaway
	["41"] = { X = 90246, Y = 20380, Z = 90207, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Earthtear Cavern
	["42"] = { X = 1005, Y = 988, Z = 1716, SizeX = 750, SizeY = 400, SizeZ = 400, Pitch = nil, Yaw = nil, Roll = nil, Editable = true }, -- Saint Delyn Penthouse
	["43"] = { X = 46086, Y = 1, Z = 45934, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Amaya Lake Lodge
	["44"] = { X = 39980, Y = 1, Z = 80960, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Ald Velothi Harbor House
	["45"] = { X = 55039, Y = 1, Z = 72950, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Tel Galen
	["46"] = { X = 56499, Y = 11501, Z = 97004, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Linchal Grand Manor
	["47"] = { X = 84285, Y = 20000, Z = 89920, SizeX = 29500, SizeY = 70000, SizeZ = 29500, Pitch = 0, Yaw = nil, Roll = nil }, -- Coldharbour Surreal Estate
	["48"] = { X = 46157, Y = 917, Z = 82938, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Hakkvild's High Hall
	["49"] = { X = 75016, Y = 8341, Z = 50791, SizeX = 148000, SizeY = 154000, SizeZ = 194000, Pitch = nil, Yaw = nil, Roll = nil }, -- Exorcised Coven Cottage
	["54"] = { X = 65771, Y = 28084, Z = 75747, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Pariah's Pinnacle
	["55"] = { X = 43472, Y = 32283, Z = 83588, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- The Orbservatory Prior
	["57"] = { X = 97878, Y = 1, Z = 75117, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Princely Dawnlight Palace
	["58"] = { X = 26739, Y = 37768, Z = 24016, SizeX = 940, SizeY = 750, SizeZ = 750, Pitch = nil, Yaw = nil, Roll = nil, Editable = true }, -- Golden Gryphon Garret
	["59"] = { X = 70850, Y = 1, Z = 82480, SizeX = 140000, SizeY = 140000, SizeZ = 140000, Pitch = 0, Yaw = nil, Roll = nil }, -- Alinor Crest Townhouse
	["60"] = { X = 74401, Y = 3215, Z = 71931, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Colossal Aldmeri Grotto
	["61"] = { X = 37778, Y = 1, Z = 42253, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Hunter's Glade
	["62"] = { X = 80207, Y = 4685, Z = 62606, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Grand Psijic Villa
	["63"] = { X = 126650, Y = 30000, Z = 121500, SizeX = 23000, SizeY = 21000, SizeZ = 21000, Pitch = 0, Yaw = nil, Roll = nil }, -- Enchanted Snow Globe Home
	["64"] = { X = 73704, Y = 10000, Z = 81594, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = 0, Yaw = nil, Roll = nil }, -- Lakemire Xanmeer Manor
	["65"] = { X = 80702, Y = 16751, Z = 65032, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = nil, Yaw = nil, Roll = nil }, -- Frostvault Chasm
	["66"] = { X = 86266, Y = 29000, Z = 86903, SizeX = 150000, SizeY = 150000, SizeZ = 150000, Pitch = nil, Yaw = nil, Roll = nil }, -- Elinhir Private Arena
}

local ALL_SOUNDS = SOUNDS

local SOUNDS = {
	ANNOUNCE = "Display_Announcement",
	DRUMS_1 = "ElderScroll_Captured_Aldmeri",
	DRUMS_2 = "Emperor_Coronated_Aldmeri",
	DRUMS_3 = "Emperor_Deposed_Aldmeri",
	ENLIGHTENED = "EnlightenedState_Gained",
	FOOTSTEPS_SPLASH = "Alchemy_Reagent_Placed",
	HORN = "BG_One_Minute_Warning",
	LEVEL_UP = "LevelUp",
	METAL_SCRAPING = "Book_Metal_Close",
	OMINOUS = "Collectible_Unlocked",
	RIPPING = "Clothier_Improve_Tooltip_Glow_Fail",
	SPARKS = "GiftInventoryView_FanfareSparks",
	SWOOSH = "Character_Close",
	TICK = "Countdown_Tick",
	TOCK = "Countdown_Warning",
	TOSS = "CrownCrates_Deal_Primary",
	STORM = "Champion_Closed",
	STORM2 = "Champion_MageMouseover",
	STORM3 = "CrownCrates_Scene_Open",
}

local TEXTURES = {
	BOUNDING_BOX = "bounding_box",
	AETHER_RAIN = "aether_rain",
	SHOOTING_STAR = "shooting_star",
	ALPINIA_1 = "alpinia_01",
	ARCH_1 = "arch_01",
	ARCH_2 = "arch_02",
	ARCH_3 = "arch_03",
	ARMOR_SUIT = "armor_suit",
	ARROW_1 = "arrow_01",
	ARROW_2 = "arrow_02",
	ARROW_3 = "arrow_03",
	ASH = "ash",
	ASH_SEQ_1 = "ash_seq_01",
	AURORA_1 = "aurora_01",
	AURORA_BOREALIS_1 = "aurora_borealis_01",
	AXE_GLASS_1 = "axe_glass_01",
	AXE_GLASS_2 = "axe_glass_02",
	BARK_1 = "bark_01",
	BAT_FLYING_1 = "bat_flying_01",
	BAT_FLYING_2 = "bat_flying_02",
	BAT_FLYING_3 = "bat_flying_03",
	BLACK = "black",
	BOOK_1 = "book_1",
	BOOK_1_N = "book_1_n",
	BOOKS_1 = "books_01",
	BOOKS_2 = "books_02",
	BOOKSHELVES_1 = "bookshelves_01",
	BOOKSHELVES_2 = "bookshelves_02",
	BOOKSHELVES_3 = "bookshelves_03",
	BOW_DAEDRIC_1 = "bow_daedric_01",
	BOX = "box",
	BRICK_1 = "brick_01",
	BUBBLE_1 = "bubble_01",
	BUBBLE_HIGHLIGHT = "bubble_highlight",
	BUSH_ROSE_1 = "bush_rose_01",
	BUSH_ROSE_1_P = "bush_rose_01_p",
	CAKE_1 = "cake_01",
	CANDLES_1 = "candles_01",
	CASTLE_1 = "castle_01",
	CAT_1 = "cat_01",
	CAT_2 = "cat_02",
	CEILING_1 = "ceiling_01",
	CEILING_2 = "ceiling_02",
	CHEESE_1 = "cheese_01",
	CHEESE_2 = "cheese_02",
	CHEESE_3 = "cheese_03",
	CHEST_1 = "chest_01",
	CHRISTMAS_LIGHTS_1 = "christmas_lights_01",
	CHRISTMAS_LIGHTS_1_N = "christmas_lights_01_n",
	CHRISTMAS_LIGHTS_2 = "christmas_lights_02",
	CHRISTMAS_LIGHTS_2_N = "christmas_lights_02_n",
	CIRCLE = "circle",
	CIRCLE_AXIS = "circle_axis",
	CIRCLE_DEPTH = "circle_depth",
	CIRCLE_NEGATIVE = "circle_negative",
	CIRCLE_SOFT = "circle_soft",
	CIRCLE_SOFT_2 = "circle_soft2",
	CIRCLE_SOFT_3 = "circle_soft3",
	CIRCLE_SOFT_4 = "circle_soft4",
	LENS_FLARE_3 = "lens_flare_03",
	CLOCK_FACE_BACK = "clock_face_back",
	CLOCK_FACE = "clock_face",
	CLOCK_HAND = "clock_hand",
	CLOUDS_1 = "clouds_01",
	CLOUDS_2 = "clouds_02",
	CLOUDS_2_R = "clouds_02_r",
	CLOUDS_3 = "clouds_03",
	COLUMN_1 = "column_01",
	COLUMN_2 = "column_02",
	COLOR_PICKER = "color_picker",
	COINS_1 = "coins_01",
	CRACKS_1 = "cracks_01",
	CRACKS_2 = "cracks_02",
	DELPHINIUM_1_N = "delphinium_01_n",
	DIRT_1 = "dirt_01",
	DIRT_1_ROUND = "dirt_01_round",
	DIVIDER_1 = "divider_01",
	DOOR_1 = "door_01",
	DOOR_2 = "door_02",
	DOOR_3 = "door_03",
	DOOR_4 = "door_04",
	DOOR_5 = "door_05",
	DOOR_6 = "door_06",
	DOOR_7 = "door_07",
	DOOR_8 = "door_08",
	DOOR_9 = "door_09",
	DOOR_GOTHIC_1 = "door_gothic_01",
	ELECTRICITY_01 = "electricity_01",
	ELECTRICITY_02 = "electricity_02",
	ELECTRICITY_03 = "electricity_03",
	ELECTRICITY_04 = "electricity_04",
	ELECTRICITY_CELLS = "electricity_cells",
	ENERGY_1 = "energy_01",
	ETHEREAL_1 = "ethereal_01",
	ETHEREAL_2 = "ethereal_02",
	ETHEREAL_3 = "ethereal_03",
	ETHEREAL_4 = "ethereal_04",
	EYES_1 = "eyes_01",
	EYES_1_GLOW = "eyes_01_glow",
	EYES_2 = "eyes_02",
	EYES_2_GLOW = "eyes_02_glow",
	FENCE = "fence",
	FIELD_1 = "field_01",
	FISH_1 = "fish_01",
	FISH_2 = "fish_02",
	FISH_3 = "fish_03",
	FISH_3_A = "fish_03_a",
	FLAME_1 = "flame_01",
	FLAME_1_NEG = "flame_01_n",
	FLAME_2 = "flame_02",
	FLAME_2_NEG = "flame_02_n",
	FLAME_3 = "flame_03",
	FLAME_3_NEG = "flame_03_n",
	FLAME_4 = "flame_04",
	FLAME_7 = "flame_07",
	FLUTE = "flute",
	FONT_1 = "font_01",
	FONT_2 = "font_02",
	FONT_3 = "font_03",
	FONT_4 = "font_04",
	FONT_5 = "font_05",
	FONT_6 = "font_06",
	FORCEFIELD_1 = "forcefield_01",
	FOUNTAIN_1 = "fountain_01",
	FROG_HOP = "frog_hop",
	LANTERNS_1 = "lanterns_01",
	LANTERNS_1_A = "lanterns_01_a",
	LEAF_MAPLE = "leaf_maple",
	GATE_1 = "gate_01",
	GEODE_1 = "geode_01",
	GEODE_2 = "geode_02",
	GEODE_3 = "geode_03",
	GEODE_4 = "geode_04",
	GLASS_1 = "glass_01",
	GLASS_2 = "glass_02",
	GLASS_3 = "glass_03",
	GLASS_STAINED_01 = "glass_stained_01",
	GLASS_STAINED_01_NEG = "glass_stained_01_n",
	GLOW_WORMS_1 = "glow_worms_01",
	GRASS_1 = "grass_01",
	GRASS_2 = "grass_02",
	GRASS_3 = "grass_03",
	GRADIENT_CENTER = "gradient_center",
	GRID_1 = "grid_01",
	GUIDELINE = "guideline",
	HAND_1 = "hand_01",
	HARP = "harp",
	HAY_1 = "hay_01",
	HAY_2 = "hay_02",
	HEDGE_1 = "hedge_01",
	HEDGE_2 = "hedge_02",
	HIST_BULB_1 = "hist_bulb_01",
	ICE_1 = "ice_01",
	ICE_2 = "ice_02",
	ICE_2_ROUND = "ice_02_round",
	ICE_WALL_1 = "ice_wall_01",
	ICICLE_1 = "icicle_01",
	ICON_POI_ALCHEMY = "esoui/art/inventory/inventory_tabicon_craftbag_alchemy_up.dds",
	ICON_POI_CLOTHING = "esoui/art/inventory/inventory_tabicon_craftbag_clothing_up.dds",
	ICON_POI_ENCHANTING = "esoui/art/inventory/inventory_tabicon_craftbag_enchanting_up.dds",
	ICON_POI_JEWELRY = "esoui/art/inventory/inventory_tabicon_craftbag_jewelrycrafting_up.dds",
	ICON_POI_PROVISIONING = "esoui/art/inventory/inventory_tabicon_craftbag_provisioning_up.dds",
	ICON_POI_RETRAIT = "esoui/art/inventory/inventory_tabicon_craftbag_itemtrait_up.dds",
	ICON_POI_SMITHING = "esoui/art/inventory/inventory_tabicon_craftbag_blacksmithing_up.dds",
	ICON_POI_STYLE = "esoui/art/restyle/keyboard/dyes_tabicon_outfitstyledye_up.dds", -- "esoui/art/restyle/gamepad/gp_dyes_tabicon_outfitstyledye.dds",
	ICON_POI_WOODWORKING = "esoui/art/inventory/inventory_tabicon_craftbag_woodworking_up.dds",
	ICON_POI_BANKER = "icon_bank",
	ICON_POI_MERCHANT = "icon_sack",
	ICON_ARROW = "icon_arrow",
	ICON_BAG = "icon_bag",
	ICON_BREADCRUMB = "icon_breadcrumb",
	ICON_BUILD = "icon_build",
	ICON_BUILD_GLOW = "icon_build_glow",
	ICON_CAMERA = "icon_camera",
	ICON_CHECKED = "icon_checked",
	ICON_CHECKED_N = "icon_checked_n",
	ICON_CLOSE = "icon_close",
	ICON_COMPASS_RELATIVE = "icon_compass_relative",
	ICON_CROWN = "icon_crown",
	ICON_DIRECTION_ARROW = "icon_direction_arrow",
	ICON_DRAG_HANDLE = "icon_drag_handle",
	ICON_FAVORITE = "icon_favorite",
	ICON_FEEDBACK = "icon_feedback",
	ICON_FOOTER = "icon_footer",
	ICON_FX_UNPUBLISHED = "icon_fx_unpublished",
	ICON_GOLD = "esoui/art/currency/currency_gold.dds",
	ICON_GUESTBOOK = "icon_guestbook",
	ICON_HELP = "icon_help",
	ICON_INDETERMINATE = "icon_indeterminate",
	ICON_LIMITS = "icon_limits",
	ICON_LINK_GROUP = "icon_link_group",
	ICON_HOUSE_LINK = "icon_house_link",
	ICON_UNLINK_GROUP = "icon_unlink_group",
	ICON_LOCK = "icon_lock",
	ICON_MAIL_OWNER = "icon_mail_owner",
	ICON_MINIMIZE = "icon_minimize",
	ICON_MULTISELECT = "icon_multiselect",
	ICON_MULTISELECT_BUILD = "icon_multiselect_build",
	ICON_MULTISELECT_CAMERA = "icon_multiselect_camera",
	ICON_NEW = "esoui/art/miscellaneous/gamepad/gp_icon_new.dds",
	ICON_PATHING = "icon_pathing",
	ICON_PIN = "icon_pin",
	ICON_QUILL = "icon_quill",
	ICON_RADIAL_MENU = "icon_radial_menu",
	ICON_RADIAL_MENU_BG = "icon_radial_menu_bg",
	ICON_ROTATION_ARROW = "icon_rotation_arrow",
	ICON_SACK = "icon_sack",
	ICON_TRADEABLE = "icon_tradeable",
	ICON_UNCHECKED = "icon_unchecked",
	ICON_UNCHECKED_N = "icon_unchecked_n",
	ICON_YOUTUBE = "icon_youtube",
	ICON_QAM_ALIGN = "icon_qam_align",
	ICON_QAM_CANCEL = "icon_qam_cancel",
	ICON_QAM_CENTER_ON = "icon_qam_center_on",
	ICON_QAM_CENTER_BETWEEN = "icon_qam_center_between",
	ICON_QAM_DESELECT = "icon_qam_deselect",
	ICON_QAM_DESELECT_RADIUS = "icon_qam_deselect_radius",
	ICON_QAM_EDIT = "icon_qam_edit",
	ICON_QAM_ORIENT = "icon_qam_orient",
	ICON_QAM_LEVEL = "icon_qam_level",
	ICON_QAM_SELECT = "icon_qam_select",
	ICON_QAM_SELECT_RADIUS = "icon_qam_select_radius",
	ICON_QAM_SNAP = "icon_qam_snap",
	ICON_QAM_STRAIGHTEN = "icon_qam_straighten",
	IVY_1 = "ivy_01",
	IVY_2 = "ivy_02",
	JHART = "jhart",
	STABBITYDOOM = "stabbitydoom",
	KELP_1 = "kelp_01",
	LAVA_1 = "lava_01",
	LAVA_1_NEG = "lava_01_n",
	LAVENDER_1 = "lavender_01",
	LEAVES = "leaves",
	LIGHT_RAYS_1 = "light_rays_01",
	LIGHT_RAYS_2 = "light_rays_02",
	LIGHT_RAYS_3 = "light_rays_03",
	LIGHTNING_LINES = "lightning_lines",
	LILY_PADS_1 = "lily_pads_01",
	LILY_PADS_2 = "lily_pads_02",
	LOTUS = "lotus",
	LOTUS_NEG = "lotus_n",
	LUPIN_1 = "lupin_01",
	MACE_REDGUARD_1 = "mace_redguard_01",
	MAGNA_GEODE_1 = "magna_geode_01",
	MANDOLIN = "mandolin",
	MARBLE_1 = "marble_01",
	MASK_NAHKRIIN = "mask_nahkriin",
	MASTER_SWORD = "master_sword",
	MASTER_SWORD_NEG = "master_sword_n",
	METAL_1 = "metal_01",
	MINT = "mint",
	MOSS_1 = "moss_01",
	MUNGE_SPOT = "munge_spot",
	NEBULA_1 = "nebula_01",
	NODE_ENCHANTING = "node_enchanting",
	NODE_ENCHANTING_C = "node_enchanting_c",
	NOISE_1 = "noise_01",
	NOISE_2 = "noise_02",
	NOISE_3 = "noise_03",
	NOISE_4 = "noise_04",
	NOISE_NEGATIVE = "noise_negative",
	NPC_CARDINAL = "npc_cardinal",
	PAPER_1 = "paper_01",
	PAPER_2 = "paper_02",
	PAPER_3 = "paper_03",
	PARCHMENT_1 = "parchment_01",
	PARCHMENT_2 = "parchment_02",
	PARCHMENT_3 = "parchment_03",
	PARCHMENT_4 = "parchment_04",
	PETUNIA_1 = "petunia_01",
	PILLAR_1 = "pillar_01",
	PLATE_1 = "plate_01",
	PLATE_1B = "plate_01b",
	PLATE_2 = "plate_02",
	PLATE_2B = "plate_02b",
	PORING_1 = "poring_01",
	PORTAL_PRIMARY = "esoui/art/loadingscreens/loadscreen_crowswood_01.dds",
	PUMPKINS_1 = "pumpkins_01",
	RAINBOW_1 = "rainbow_01",
	QUILT_1 = "quilt_01",
	ROCK_1 = "rock_01",
	ROCK_2 = "rock_02",
	ROCK_3 = "rock_03",
	ROCK_4 = "rock_04",
	ROCK_6 = "rock_06",
	ROCK_7 = "rock_07",
	ROCK_8 = "rock_08",
	SAND_1 = "sand_01",
	SHIELD_1 = "shield_01",
	SHIELD_AYLEID_1 = "shield_ayleid_01",
	RABBIT_1 = "rabbit_01",
	RABBIT_1_C = "rabbit_01_C",
	RAIN_DROP_1 = "rain_drop_01",
	ROPE_1 = "rope_01",
	ROSE_1 = "rose_01",
	RUG_1 = "rug_01",
	RULER_HORIZ = "ruler_horiz",
	RULER_VERT = "ruler_vert",
	RUNES_1 = "runes_01",
	RUNES_2 = "runes_02",
	SALVIA_1 = "salvia_01",
	SCYTHE = "scythe",
	SENCHE_SHADOW = "senche_shadow",
	SHADOWMARK_CACHE = "shadowmark_cache",
	SHADOWMARK_DANGER = "shadowmark_danger",
	SHADOWMARK_EMPTY = "shadowmark_empty",
	SHADOWMARK_ESCAPE = "shadowmark_escape",
	SHADOWMARK_FENCE = "shadowmark_fence",
	SHADOWMARK_GUILD = "shadowmark_guild",
	SHADOWMARK_LOOT = "shadowmark_loot",
	SHADOWMARK_PROTECTED = "shadowmark_protected",
	SHADOWMARK_SAFE = "shadowmark_safe",
	SHAPE_CIRCLE = "shape_circle",
	SHAPE_TRIANGLE = "shape_triangle",
	SHAPE_RIGHT_ANGLE = "shape_right_angle",
	SHAPE_ARROW = "shape_arrow",
	SHIP_1 = "ship_01",
	SIGIL_1 = "sigil_01",
	SIGIL_2 = "sigil_02",
	SIGIL_3 = "sigil_03",
	SIGIL_4 = "sigil_04",
	SIGIL_5 = "sigil_05",
	SIGIL_6 = "sigil_06",
	SIGIL_7 = "sigil_07",
	SIGIL_8 = "sigil_08",
	SIGIL_9 = "sigil_09",
	SIGIL_10 = "sigil_10",
	SIGIL_11 = "sigil_11",
	SIGIL_12 = "sigil_12",
	SIGIL_13 = "sigil_13",
	SIGIL_14 = "sigil_14",
	SIGIL_15 = "sigil_15",
	SIGIL_16 = "sigil_16",
	SIGIL_17 = "sigil_17",
	SILHOUETTE_GUARD = "silhouette_guard",
	SLIDER_BORDER = "slider_border",
	SLIDER_INDICATOR = "slider_indicator",
	SKY_TOP_FADE_OUT = "sky_top_fade_out",
	SKY_STARS_1 = "sky_stars_01",
	SKY_STARS_2 = "sky_stars_02",
	SKY_STARS_3 = "sky_stars_03",
	SKY_STARS_5 = "sky_stars_05",
	SKY_STARS_5_C = "sky_stars_05_c",
	SKY_STARS_7_S = "sky_stars_07_s",
	SKY_STARS_7_T = "sky_stars_07_t",
	SKY_STARS_8 = "sky_stars_08",
	SKY_STARS_8_S = "sky_stars_08_s",
	SKY_STARS_9_S = "sky_stars_09_s",
	SKY_STARS_9_T = "sky_stars_09_t",
	SMOKE_1 = "smoke_01",
	SMOKE_1_TILE = "smoke_01_tile",
	SMOKE_2 = "smoke_02",
	SMOKE_3 = "smoke_03",
	SMOKE_4 = "smoke_04",
	SMOKE_5 = "smoke_05",
	SMOKE_PLUME_1 = "smoke_plume_01",
	SNOWFLAKE_1 = "snowflake_01",
	SOLID = "square",
	SOLID_ARCH = "solid_arch",
	SOLID_SOFT = "square_soft",
	SPADE = "spade",
	SPHERE = "sphere",
	SPIDERWEB_1 = "spiderweb_01",
	SPIRIT_STONE_1 = "spirit_stone_01",
	SPIRIT_STONE_2 = "spirit_stone_02",
	SPIRIT_STONE_3 = "spirit_stone_03",
	SPLASH_1 = "splash_01",
	SPLASH_2 = "splash_02",
	SPLASH_3 = "splash_03",
	SPLASH_4 = "splash_04",
	STAFF_DRAGON_1 = "staff_dragon_01",
	STARBURST_1 = "starburst_01",
	STARBURST_2 = "starburst_02",
	STARBURST_3 = "starburst_03",
	STARS_1 = "stars_01",
	STARS_2 = "stars_02",
	STATUE_1 = "statue_01",
	STATUE_1_C = "statue_01_c",
	STATUE_2 = "statue_02",
	STATUE_2_C = "statue_02_c",
	STATUE_DIBELLA_1 = "statue_dibella_01",
	STEAM_1 = "steam_01",
	STONES_1 = "stones_01",
	STONES_1_NEG = "stones_01_n",
	STONES_2 = "stones_02",
	STONES_2_NEG = "stones_02_n",
	SWORD_1 = "sword_01",
	SWORD_DAEDRIC_1 = "sword_daedric_01",
	SWORD_DAEDRIC_2 = "sword_daedric_02",
	SWORD_EBONY_1 = "sword_ebony_01",
	SWORDS_1 = "swords_01",
	TARGET = "target",
	TILE_1 = "tile_01",
	TILE_2 = "tile_02",
	TILE_3 = "tile_03",
	TILE_4 = "tile_04",
	TILE_5 = "tile_05",
	TILE_6 = "tile_06",
	TILE_7 = "tile_07",
	TILE_8 = "tile_08",
	TILE_9 = "tile_09",
	TILE_10 = "tile_10",
	TOME_1_B = "tome_01_b",
	TOME_1_P = "tome_01_p",
	TOME_1_S = "tome_01_s",
	TOME_2_S = "tome_02_s",
	TOME_3_S = "tome_03_s",
	TRANSPARENT = "transparent",
	TREE_1 = "tree_01",
	TREE_2 = "tree_02",
	TREE_CHERRY_BLOSSOM_1 = "tree_cherry_blossom_01",
	TREE_CHERRY_BLOSSOM_2 = "tree_cherry_blossom_02",
	TREE_CLUSTER_1 = "tree_cluster_01",
	TREE_ETHEREAL = "tree_ethereal",
	TREE_MAPLE_1 = "tree_maple_01",
	TREE_MAPLE_2 = "tree_maple_02",
	TREE_MAPLE_3 = "tree_maple_03",
	TREE_MAPLE_4_C = "tree_maple_04_c",
	TREE_MAPLE_4_S = "tree_maple_04_s",
	TREE_PINK_TRUMPET_1 = "tree_pink_trumpet_01",
	TREE_WITHERED = "tree_withered_01",
	TRIFORCE = "triforce",
	TULIP_1 = "tulip_01",
	TYTHIS = "tythis",
	UNITS_1 = "units_01",
	VIGNETTE = "vignette",
	VIOLIN = "violin",
	WABBAJACK_1 = "wabbajack_01",
	WAINSCOTING_1 = "wainscoting_01",
	WALL_1 = "wall_01",
	WALL_2 = "wall_02",
	WALL_3 = "wall_03",
	WALL_4 = "wall_04",
	WALL_ALTMER_BOTTOM = "wall_altmer_bottom",
	WALL_ALTMER_CENTER = "wall_altmer_center",
	WALL_ALTMER_TOP = "wall_altmer_top",
	WARRIOR_BRETON = "warrior_breton",
	WARRIOR_KHAJIIT = "warrior_khajiit",
	WATER_1 = "water_01",
	WATER_2 = "water_02",
	WATER_CIRCLE = "water_circle",
	WATER_LILY = "water_lily",
	WATER_LILY_NEG = "water_lily_n",
	WATER_SQUARE = "water_square",
	WATERFALL_3 = "waterfall_03",
	WAVES_1 = "waves_01",
	WAVES_2 = "waves_02",
	WATER_REFLECTION_1 = "water_reflection_01",
	WEAPON_MOUNTED_1 = "weapon_mounted_01",
	WEAPON_RACK_1 = "weapon_rack_01",
	WHIRLPOOL_1 = "whirlpool_01",
	WHIRLPOOL_2 = "whirlpool_02",
	WHIRLPOOL_3 = "whirlpool_03",
	WHIRLPOOL_4 = "whirlpool_04",
	WHIRLPOOL_5 = "whirlpool_05",
	WHIRLPOOL_6 = "whirlpool_06",
	WINDOW_1 = "window_01",
	WINDOW_2 = "window_02",
	WINDOW_3 = "window_03",
	WINDOW_4 = "window_04",
	WINDOW_5 = "window_05",
	WINDOW_6 = "window_06",
	WINDOW_7 = "window_07",
	WINDOW_8 = "window_08",
	WINDOW_CLOCKWORK = "window_clockwork",
	WINDOW_DIVINES = "window_divines",
	WINDOW_GOTHIC = "window_gothic",
	WINDOW_GOTHIC_2 = "window_gothic_02",
	WINDOW_ROUND_1 = "window_round_01",
	WINDOWS_TRIO = "windows_trio",
	WINE_RACK_1 = "wine_rack_01",
	WISTERIA_1 = "wisteria_01",
	WISTERIA_1_C = "wisteria_01_c",
	WISTERIA_1_P = "wisteria_01_p",
	WISTERIA_2 = "wisteria_02",
	WISTERIA_2_C = "wisteria_02_c",
	WISTERIA_2_P = "wisteria_02_p",
	WOOD_PLANKS_1 = "wood_planks_01",
}

EHT.TextureFilenames = EHT.Util.CloneTable( TEXTURES )
EHT.Textures = TEXTURES

for key, value in pairs( TEXTURES ) do
	if not string.find( value, ".dds" ) then
		TEXTURES[key] = string.format( EHT.PATH_TEXTURES, value )
	end
end

EHT.ICON_CROWN = zo_iconFormat( TEXTURES.ICON_CROWN, 24, 24 )
EHT.ICON_TRADEABLE = zo_iconFormat( TEXTURES.ICON_TRADEABLE, 24, 24 )
EHT.ICON_PATHING = zo_iconFormat( EHT.Textures.ICON_PATHING, 24, 24 )

local CUSTOM_TEMPLATES = {
	{ Id = 5000, Name = "Sign, \"Muppet Club\"", Size = 512, Behavior = "Shining", },
	{ Id = 5001, Submitter = "Krainor", Name = "Sign, \"Farreach Valley\"", SizeX = 512, SizeY = 343, SizeZ = 343, Behavior = "Shining", TextureCoords = { 0, 1, 0, 343 / 512 } },
	{ Id = 5002, Name = "Sign, \"Tamriel Trade Union\"", Count = 2, SizeX = 512, SizeY = 512, SizeZ = 512, RGB = { 1, 0, 0 }, Behavior = "MaskedGlowing" },
	{ Id = 5003, Submitter = "Chryseia", Name = "Darien & Winterrose, Nostalgia", SizeX = 200*(916/1024), SizeY = 200*(611/1024), SizeZ = 200*(611/1024), },
	{ Id = 5004, Submitter = "Chryseia", Name = "Darien & Winterrose, Painting", SizeX = 200*(968/1024), SizeY = 200*(645/1024), SizeZ = 200*(645/1024), },
	{ Id = 5005, Submitter = "Chryseia", Name = "Darien & Winterrose, Photograph", SizeX = 200*(1158/1024), SizeY = 200*(772/1024), SizeZ = 200*(772/1024), },
	{ Id = 5006, Submitter = "Chryseia", Name = "Darien Gautier, Glamour Shot", SizeX = 200*(699/1024), SizeY = 200*(1048/1024), SizeZ = 200*(1048/1024), },
	{ Id = 5007, Submitter = "Catsmoke", Category = CAT.DECO, Name = "Rug, Elsweyr Hunter", SizeX = 400, SizeY = 400*(352/512), SizeZ = 400*(352/512), },
	{ Id = 5008, Submitter = "Maya", Name = "Mivanu & Varda", SizeX = 400*(1224/1024), SizeY = 400*(814/1024), SizeZ = 400*(814/1024), },
	{ Id = 5009, Submitter = "Xerodom", Name = "Siofra", SizeX = 250*(740/1024), SizeY = 250*(1024/1024), SizeZ = 250*(1024/1024), TextureCoords = { 0, (740/1024), 0, 1 } },
	{ Id = 5010, Submitter = "Agrivar", Name = "Agrivar", Callback = function( template )
		template.DefaultGreeting = "Let me guess - someone stole your sweetroll?"
		template.TexWidth, template.TexHeight = 2048, 1024
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5011, Submitter = "Wueben", Name = "Zombie Cat", Callback = function( template )
		template.DefaultGreeting = "Did you touch my ass!?"
		template.TexWidth, template.TexHeight = 2048, 1024
		template.CellsX = 4
		template.CellInterval = 1200
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5012, Submitter = "Zendyra", Name = "Chrispi Critters", Callback = function( template )
		template.DefaultGreeting = "Don't be jealous..."
		template.TexWidth, template.TexHeight = 512, 256
		template.CellsX, template.CellInterval = 6, 360
		template.CellWidth, template.CellHeight = 85.333, 256
		template.LocalWidth, template.LocalHeight = 85.333, 256
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5013, Submitter = "Krainor", Name = "Blackthornes Portrait", SizeX = 250, SizeY = 250*(1589/1500), SizeZ = 250*(1589/1500), TextureCoords = { 0, 1, 0, 1 } },
	{ Id = 5014, Submitter = "Volringer", Name = "Firedrake", Callback = function( template )
		template.TexWidth, template.TexHeight = 1024, 1024
		template.CellsX, template.CellInterval = 3, 500
		template.CellWidth, template.CellHeight = 341, 732
		template.LocalWidth, template.LocalHeight = 341, 732
		template.DefaultWidth, template.DefaultHeight = 130, 275
		template.LoopForwardReverse = true
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5015, Submitter = "Volringer", Name = "Stormlord", Callback = function( template )
		template.TexWidth, template.TexHeight = 2048, 1024
		template.CellsX, template.CellInterval = 3, 1200
		template.CellWidth, template.CellHeight = 680, 965
		template.LocalWidth, template.LocalHeight = 680, 965
		template.DefaultWidth, template.DefaultHeight = 275 * (680/965), 235 * (965/680)
		template.LoopForwardReverse = true
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5016, Submitter = "Volringer", Name = "Pit Daemon", Callback = function( template )
		template.TexWidth, template.TexHeight = 2048, 1024
		template.CellsX, template.CellInterval = 6, 600
		template.CellWidth, template.CellHeight = 330, 980
		template.LocalWidth, template.LocalHeight = 330, 980
		template.DefaultWidth, template.DefaultHeight = 120, 300
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5017, Behavior = "Banner", Submitter = "Krainor", Name = "Dragon Banner", SizeX = 250*(146/218), SizeY = 250*(218/146), SizeZ = 250*(218/146) },
	{ Id = 5018, Submitter = "twitch.tv/jhartellis", Name = "JHartEllis", Callback = function( template )
		template.DefaultGreeting = "Mooooove me wherever you'd like."
		template.TexWidth, template.TexHeight = 1024, 1024
		template.CellsX, template.CellInterval = 3, 500
		template.CellWidth, template.CellHeight = 340, 787
		template.LocalWidth, template.LocalHeight = 340, 787
		template.DefaultWidth, template.DefaultHeight = 130, 300
		template.LoopForwardReverse = true
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5019, Submitter = "Lashh", Name = "Lashh", Callback = function( template )
		template.DefaultGreeting = "Hi sweetie"
		template.TexWidth, template.TexHeight = 1024, 1024
		template.CellsX, template.CellInterval = 4, 500
		template.CellWidth, template.CellHeight = 240, 1024
		template.LocalWidth, template.LocalHeight = 240, 1024
		template.DefaultWidth, template.DefaultHeight = 80, 220
		template.LoopForwardReverse = true
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5020, DateAdded = 1554367060, Category = CAT.DECO, Submitter = "StabbityDoom", Name = "Droplet", SizeX = 128, SizeY = 128*(450/512), SizeZ = 128*(450/512), TextureCoords = { 0, 1, 0, 450/512 }, RGB = { 0.086, 0.75, 1 } },
	{ Id = 5021, Category = CAT.DECO, Submitter = "Chryseia", Name = "Scrollwork", SizeX = 128*(380/1024), SizeY = 128, SizeZ = 128, TextureCoords = { 644/1024, 1, 0, 1 } },
	{ Id = 5022, ImageId = 5021, Category = CAT.DECO, Submitter = "Chryseia", Name = "Frame Border, Horizontal", Roll = RAD90, Yaw = 0, SizeX = 128*(175/1024), SizeY = 128, SizeZ = 128, TextureCoords = { 0, 175/1024, 0, 1 } },
	{ Id = 5023, ImageId = 5021, Category = CAT.DECO, Submitter = "Chryseia", Name = "Frame Border, Vertical", Yaw = 0, SizeX = 128*(175/1024), SizeY = 128, SizeZ = 128, TextureCoords = { 0, 175/1024, 0, 1 } },
	{ Id = 5024, Category = CAT.DECO, Submitter = "Chryseia", Name = "Frame, Rectangular", SizeX = 128*(977/746), SizeY = 128*(746/977), SizeZ = 128*(746/977) },
	{ Id = 5025, Category = CAT.DECO, Submitter = "Chryseia", Name = "Frame, Oval", SizeX = 128*(312/463), SizeY = 128*(463/312), SizeZ = 128*(463/312) },
	{ Id = 5026, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Goat, Ninendava Sacred", SizeX = 100*(486/650), SizeY = 100*(650/486), SizeZ = 100*(650/486) },
	{ Id = 5027, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Hen, Riverwood White", SizeX = 60*(615/650), SizeY = 60*(650/615), SizeZ = 60*(650/615) },
	{ Id = 5028, AutoPreview = false, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Spider, Skein", SizeX = 70*(750/530), SizeY = 70*(530/750), SizeZ = 70*(530/750) },
	{ Id = 5031, Category = CAT.PET, Submitter = "Catsmoke", Name = "Pet Bashibazook, \"Fluffy\"", SizeX = 400, SizeY = 400, SizeZ = 400 },
	{ Id = 5032, Submitter = "Stormahawk", Name = "Stormahawk", Callback = function( template )
		template.DefaultGreeting = "It's not my fault that I'm fabulous - I was just drawn this way."
		template.TexWidth, template.TexHeight = 1024, 1024
		template.CellsX, template.CellInterval = 3, 700
		template.CellWidth, template.CellHeight = 340, 1024
		template.LocalWidth, template.LocalHeight = 340, 1024
		template.DefaultWidth, template.DefaultHeight = 220*(340/539), 220
		template.LoopForwardReverse = true
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5033, DateAdded = 1556113059, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Frog, Blue Oasis Dragon", SizeX = 50*(643/572), SizeY = 50*(572/643), SizeZ = 50*(572/643) },
	{ Id = 5034, DateAdded = 1556113059, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Lizard, Helstrom Ancestor", SizeX = 70, SizeY = 70*(161/969), SizeZ = 70*(161/969) },
	{ Id = 5035, DateAdded = 1556113059, Category = CAT.DECO, Submitter = "Scarlet-Ibis", Name = "Ballista Figurehead, Pact", SizeX = 80*(827/662), SizeY = 80*(662/827), SizeZ = 80*(662/827) },
	{ Id = 5036, DateAdded = 1556243640, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Mouser, Big-eared Ginger", SizeX = 60, SizeY = 60*(574/622), SizeZ = 60*(574/622) },
	{ Id = 5037, DateAdded = 1556243640, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Monkey, Imgakin", SizeX = 55, SizeY = 55*(555/434), SizeZ = 55*(555/434) },
	{ Id = 5038, DateAdded = 1556243640, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Pig, Pink Pearl", SizeX = 86, SizeY = 86*(524/900), SizeZ = 86*(524/900) },

	{ Id = 5039, ImageId = 5039, DateAdded = 1556507738, Category = CAT.DECO, Behavior = "Shining", Submitter = "Aziara", Name = "Indrik Feather, Opaline", SizeX = 16, SizeY = 34, SizeZ = 86*(524/900), TextureCoords = { 0, 0.25, 0, 364/512 } },
	{ Id = 5040, ImageId = 5039, DateAdded = 1556507738, Category = CAT.DECO, Behavior = "Shining", Submitter = "Aziara", Name = "Indrik Feather, Onyx", SizeX = 16, SizeY = 34, SizeZ = 86*(524/900), TextureCoords = { 0.25, 0.5, 0, 364/512 } },
	{ Id = 5041, ImageId = 5039, DateAdded = 1556507738, Category = CAT.DECO, Behavior = "Shining", Submitter = "Aziara", Name = "Indrik Feather, Gilded", SizeX = 16, SizeY = 34, SizeZ = 86*(524/900), TextureCoords = { 0.5, 0.75, 0, 364/512 } },
	{ Id = 5042, ImageId = 5039, DateAdded = 1556507738, Category = CAT.DECO, Behavior = "Shining", Submitter = "Aziara", Name = "Indrik Feather, Emerald", SizeX = 16, SizeY = 34, SizeZ = 86*(524/900), TextureCoords = { 0.75, 1, 0, 364/512 } },
	{ Id = 5043, DateAdded = 1556507738, Category = CAT.LAND, Submitter = "StabbityDoom", Name = "Bamboo, Cluster", SizeX = 400*(172/400), SizeY = 400, SizeZ = 400 },
	{ Id = 5044, DateAdded = 1556507738, Category = CAT.SIGIL, Behavior = "Ethereal", Submitter = "Mrs Norrell", Name = "Sigil, Dark Brotherhood", SizeX = 512, SizeY = 512, SizeZ = 512, Additive = true, SampleAlpha = 0.6, },

	{ Id = 5045, DateAdded = 1556602793, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Cow, Holstein", SizeX = 150*(800/517), SizeY = 150, SizeZ = 150 },
	{ Id = 5046, DateAdded = 1556602793, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Deer, Doe", SizeX = 120*(550/558), SizeY = 120, SizeZ = 120 },
	{ Id = 5047, DateAdded = 1556602793, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Cow, Hereford", SizeX = 150*(800/517), SizeY = 150, SizeZ = 150 },

	{ Id = 5048, DateAdded = 1556698249, Submitter = "Scarlet-Ibis", Name = "Skeleton, Woodwind Extraordinaire", Callback = function( template )
		template.DefaultGreeting = "Look alive... Doot, Doot, Doot!"
		template.TexWidth, template.TexHeight = 1024, 1024
		template.CellsX, template.CellInterval = 3, 700
		template.CellWidth, template.CellHeight = 340, 685
		template.LocalWidth, template.LocalHeight = 340, 685
		template.DefaultWidth, template.DefaultHeight = 280*(340/685), 280
		template.LoopForwardReverse = true
		EHT.Effect.CreatePlayerNPC( template )
	end },

	{ Id = 5049, Behavior = "Billboard", DateAdded = 1556820418, Category = CAT.LAND, Submitter = "StabbityDoom", Name = "Bamboo, Stalk", SizeX = 400*(146/993), SizeY = 400, SizeZ = 400, TextureCoords = {0, 68/512, 0, 1 }, },

	{ Id = 5050, DateAdded = 1557016035, Category = CAT.PET, Submitter = "Scarlet&Stabbity", Name = "Raven, Standing", SizeX = 26*(175/115), SizeY = 26, SizeZ = 26 },
	{ Id = 5051, DateAdded = 1557016035, Category = CAT.PET, Submitter = "Scarlet&Stabbity", Name = "Owl", SizeX = 60*(113/232), SizeY = 60, SizeZ = 60 },
	{ Id = 5052, DateAdded = 1557016035, Category = CAT.PET, Submitter = "Scarlet&Stabbity", Name = "Sheep / Shower Loofah", SizeX = 110*(430/350), SizeY = 110, SizeZ = 110 },

	{ Id = 5053, DateAdded = 1557308753, Category = CAT.DECO, Submitter = "Aveykin", Name = "Rug, Braided Tassles", SizeX = 300*(658/974), SizeY = 300, SizeZ = 300 },
	{ Id = 5054, DateAdded = 1557353303, Submitter = "Nomak67", Name = "Sign, Nomak's Guild", SizeX = 500*(2332/1898), SizeY = 500, SizeZ = 500 },

	{ Id = 5055, DateAdded = 1556698249, Submitter = "Scarlet-Ibis", Name = "Werewolf", Callback = function( template )
		template.DefaultGreeting = ""
		template.TexWidth, template.TexHeight = 1024, 1024
		template.CellsX, template.CellsY, template.MaxCells = 3, 2, 5
		template.CellInterval = 1000
		template.CellWidth, template.CellHeight = 340, 472
		template.LocalWidth, template.LocalHeight = 340, 472
		template.DefaultWidth, template.DefaultHeight = 300*(340/472), 300
		template.Saturation = 0.5
		template.LoopForwardReverse = false
		EHT.Effect.CreatePlayerNPC( template )
	end },

	{ Id = 5056, DateAdded = 1557730606, Submitter = "Scarlet-Ibis", Name = "Maid, Argonian", Callback = function( template )
		template.DefaultGreeting = ""
		template.TexWidth, template.TexHeight = 1024, 1024
		template.CellsX, template.CellsY, template.MaxCells = 3, 2, 6
		template.CellInterval = 300
		template.CellWidth, template.CellHeight = 317, 505
		template.LocalWidth, template.LocalHeight = 317, 505
		template.DefaultWidth, template.DefaultHeight = 160, 260
		template.LoopForwardReverse = false
		template.NonSinusoidal = true
		template.R, template.G, template.B = 1, 1, 1
		EHT.Effect.CreatePlayerNPC( template )
	end },

	{ Id = 5057, DateAdded = 1557730606, Submitter = "Scarlet-Ibis", Name = "Laborer, Nord", Callback = function( template )
		template.DefaultGreeting = ""
		template.TexWidth, template.TexHeight = 1024, 1024
		template.CellsX, template.CellsY, template.MaxCells = 2, 2, 4
		template.CellInterval = 350
		template.CellWidth, template.CellHeight = 443, 512
		template.LocalWidth, template.LocalHeight = 443, 512
		template.DefaultWidth, template.DefaultHeight = 260, 320
		template.LoopForwardReverse = false
		template.NonSinusoidal = true
		template.R, template.G, template.B = 1, 1, 1
		EHT.Effect.CreatePlayerNPC( template )
	end },

	{ Id = 5058, DateAdded = 1557730606, Category = CAT.NPC, Behavior = "Billboard", Submitter = "Scarlet-Ibis", Name = "Bloodfiend, Dark-Elf", SizeX = 240*(172/745), SizeY = 240, SizeZ = 240 },
	{ Id = 5059, DateAdded = 1557730606, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Elk", SizeX = 220*(527/620), SizeY = 220, SizeZ = 220 },
	{ Id = 5060, DateAdded = 1557730606, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Vulture-griffon", SizeX = 80*(600/352), SizeY = 80, SizeZ = 80 },
	{ Id = 5061, DateAdded = 1557730606, Category = CAT.NPC, Behavior = "Billboard", Submitter = "Scarlet-Ibis", Name = "Priestess, Imperial", SizeX = 240*(224/640), SizeY = 240, SizeZ = 240 },
	{ Id = 5062, DateAdded = 1557730606, Category = CAT.NPC, Behavior = "Billboard", Submitter = "Scarlet-Ibis", Name = "Guard, Orc", SizeX = 240*(219/627), SizeY = 240, SizeZ = 240 },

	{ Id = 5063, DateAdded = 1557784973, Submitter = "Volringer", Name = "Mercenary, Redguard", Callback = function( template )
		template.DefaultGreeting = ""
		template.TexWidth, template.TexHeight = 256, 512
		template.CellsX, template.CellsY, template.MaxCells = 1, 5, 5
		template.CellInterval, template.LoopPauseCells = 170, 3
		template.CellWidth, template.CellHeight = 200, 102.4
		template.LocalWidth, template.LocalHeight = 200, 102.4
		template.DefaultWidth, template.DefaultHeight = 120*(398/204), 120
		template.LoopForwardReverse = true
		template.NonSinusoidal = true
		template.R, template.G, template.B = 1, 1, 1
		EHT.Effect.CreatePlayerNPC( template )
	end },

	{ Id = 5064, DateAdded = 1557784973, Submitter = "Volringer", Name = "Mercenary, Nord", Callback = function( template )
		template.DefaultGreeting = ""
		template.TexWidth, template.TexHeight = 2048, 2048
		template.CellsX, template.CellsY, template.MaxCells = 2, 4, 8
		template.CellInterval, template.MidpointPauseCells = 176, 3
		template.CellWidth, template.CellHeight = 755, 445
		template.LocalWidth, template.LocalHeight = 755, 445
		template.DefaultWidth, template.DefaultHeight = 140*(398/204), 140
		template.LoopForwardReverse = true
		template.NonSinusoidal = true
		template.R, template.G, template.B = 1, 1, 1
		EHT.Effect.CreatePlayerNPC( template )
	end },

	{ Id = 5065, DateAdded = 1557952885, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Guar, Bantam (Honor)", SizeX = 60*(429/500), SizeY = 60, SizeZ = 60 },
	{ Id = 5066, DateAdded = 1557952885, Submitter = "Scarlet-Ibis", Name = "Rogue, Khajiit", Callback = function( template )
		template.DefaultGreeting = ""
		template.TexWidth, template.TexHeight = 512, 512
		template.CellsX, template.CellsY, template.MaxCells = 1, 1, 1
		template.CellInterval, template.MidpointPauseCells = 1000, 0
		template.CellWidth, template.CellHeight = 512, 512
		template.LocalWidth, template.LocalHeight = 512, 512
		template.DefaultWidth, template.DefaultHeight = 260*(275/670),260
		template.LoopForwardReverse = false
		template.NonSinusoidal = true
		template.R, template.G, template.B = 1, 1, 1
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5067, DateAdded = 1557952885, Submitter = "Scarlet-Ibis", Name = "Trader, Khajiit", Callback = function( template )
		template.DefaultGreeting = ""
		template.TexWidth, template.TexHeight = 512, 512
		template.CellsX, template.CellsY, template.MaxCells = 1, 1, 1
		template.CellInterval, template.MidpointPauseCells = 1000, 0
		template.CellWidth, template.CellHeight = 512, 512
		template.LocalWidth, template.LocalHeight = 512, 512
		template.DefaultWidth, template.DefaultHeight = 260*(255/620),260
		template.LoopForwardReverse = false
		template.NonSinusoidal = true
		template.R, template.G, template.B = 1, 1, 1
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5068, DateAdded = 1557952885, Category = CAT.DECO, Behavior = "Tile", TileSizeX = 240, TileSizeY = 150, Submitter = "StabbityDoom", Name = "Carpet, Shag", SizeX = 240, SizeY = 150, SizeZ = 150 },

	{ Id = 5069, DateAdded = 1558089090, Category = CAT.DECO, Behavior = "Perspective", Submitter = "Disco.ball", Name = "Dwarven Frieze, Wrathstone", SizeX = 402, SizeY = 514, SizeZ = 514, },

	{ Id = 5070, DateAdded = 1558239289, Category = CAT.PET, Behavior = "Flipbook", Submitter = "Scarlet-Ibis", Name = "Skeevaton", SizeX = 40*(636/270), SizeY = 40, SizeZ = 40, Interval = 600, TextureCoords = { { 0, 1, 0, 0.25 }, { 0, 1, 0.25, 0.5 }, { 0, 1, 0.5, 0.75 }, { 0, 1, 0.75, 1 } }, },
	{ Id = 5071, DateAdded = 1558239289, Submitter = "Scarlet-Ibis", Name = "Lord, Argonian", Callback = function( template )
		template.DefaultGreeting = ""
		template.TexWidth, template.TexHeight = 512, 512
		template.CellsX, template.CellsY, template.MaxCells = 1, 1, 1
		template.CellInterval, template.MidpointPauseCells = 1000, 0
		template.CellWidth, template.CellHeight = 512, 512
		template.LocalWidth, template.LocalHeight = 512, 512
		template.DefaultWidth, template.DefaultHeight = 260*(255/645),260
		template.NonSinusoidal = true
		template.R, template.G, template.B = 1, 1, 1
		EHT.Effect.CreatePlayerNPC( template )
	end },
	{ Id = 5072, DateAdded = 1558239289, Category = CAT.PET, Submitter = "Scarlet-Ibis", Name = "Dwarven Spider", SizeX = 250*(563/348), SizeY = 250, SizeZ = 250, },

	{ Id = 5073, DateAdded = 1558460556, Category = CAT.SUBMISSION, Submitter = "Nomak67", Name = "Portrait, Banshee Queen", SizeX = 180*(2988/4331), SizeY = 180, SizeZ = 180, },

	{ Id = 5074, DateAdded = 1558896703, Submitter = "ZuoLiang", Name = "ZuoLiang", Callback = function( template )
		template.DefaultGreeting = ""
		template.TexWidth, template.TexHeight = 1024, 1024
		template.CellsX, template.CellsY, template.MaxCells = 2, 1, 2
		template.CellInterval, template.MidpointPauseCells = 4000, 0
		template.CellWidth, template.CellHeight = 1024, 1024
		template.LocalWidth, template.LocalHeight = 1024, 1024
		template.DefaultWidth, template.DefaultHeight = 260*(488/1026),260
		template.R, template.G, template.B = 1, 0, 1
		template.LoopForwardReverse = false
		template.StaticPrimaryCell = true
		template.CellAlphaMasks = { 1, 0.1 }
		template.CellSampling = { { 1, 0 }, { 5, 15 } }
		EHT.Effect.CreatePlayerNPC( template )
	end },

	{ Id = 5075, DateAdded = 1559518237, Category = CAT.LAND, Behavior = "Fan", Submitter = "CryHavok101 & StabbityDoom", Name = "Antler Coral, Lunar", AutoUpdateDrawLevel = false, CanPitch = true, OrderDrawLevelByIndex = false, SizeX = 500*(1024/830), SizeY = 500, SizeZ = 500, RGB = { 0, 0.8, 0.8, 1 } },

	{ Id = 5076, DateAdded = 1559712537, Category = CAT.LAND, Submitter = "CryHavok101 & StabbityDoom", Name = "Antler Coral, Ocean", SizeX = 300*(523/973), SizeY = 280, SizeZ = 280, RGB = { 0.58, 0.51, 0.9, 1 } },
	{ Id = 5077, DateAdded = 1559712537, Category = CAT.LAND, Submitter = "CryHavok101 & StabbityDoom", Name = "Antler Coral, Crimson Stout", SizeX = 720*(567/642), SizeY = 720, SizeZ = 720, RGB = { 0.69, 0.69, 0.69, 1 } },
	{ Id = 5078, DateAdded = 1559712537, Category = CAT.LAND, Submitter = "CryHavok101 & StabbityDoom", Name = "Antler Coral, Crimson", SizeX = 800*(451/1036), SizeY = 800, SizeZ = 800, RGB = { 0.69, 0.69, 0.69, 1 } },

	{ Id = 5079, DateAdded = 1560713582, Submitter = "Emma.98", Name = "Emma.98", Callback = function( template )
		template.DefaultGreeting = ""
		template.TexWidth, template.TexHeight = 2048, 1024
		template.CellsX, template.CellsY, template.MaxCells = 4, 1, 4
		template.CellInterval, template.MidpointPauseCells = 1000, 0
		template.CellWidth, template.CellHeight = 380, 925
		template.LocalWidth, template.LocalHeight = 380, 925
		template.DefaultWidth, template.DefaultHeight = 220*(380/925), 220
		template.LoopForwardReverse = true
		template.NonSinusoidal = false
		template.GlowBase, template.GlowIntensity, template.GlowInterval = 0.8, 0.4, 2500
		template.R, template.G, template.B = 1, 1, 1
		EHT.Effect.CreatePlayerNPC( template )
	end },

	{ Id = 5080, DateAdded = 1563141161, Category = CAT.PET, Submitter = "Tehuantl", Name = "Huge Hanna", SizeX = 40*(626/476), SizeY = 40, SizeZ = 40, RGB = { 1, 1, 1, 1 } },
	{ Id = 5081, DateAdded = 1563141161, Category = CAT.DECO, Submitter = "Sharalei", Name = "Statue, Peryite", SizeX = 800*(729/888), SizeY = 800, SizeZ = 800, RGB = { 1, 1, 1, 1 } },
	{ Id = 5082, DateAdded = 1563141161, Submitter = "Krainor", Name = "Blackthorne, Krainor", SizeX = 150*(316/443), SizeY = 150, SizeZ = 150, RGB = { 1, 1, 1, 1 } },
	{ Id = 5083, DateAdded = 1563141161, Submitter = "Krainor", Name = "Blackthorne, Alessiana", SizeX = 150*(318/411), SizeY = 150, SizeZ = 150, RGB = { 1, 1, 1, 1 } },
	{ Id = 5084, DateAdded = 1563141161, Category = CAT.LAND, Submitter = "StabbityDoom", Name = "Ivy, Festive Flowers", SizeX = 600*(1391/1182), SizeY = 600, SizeZ = 600, RGB = { 1, 1, 1, 1 } },
	{ Id = 5085, DateAdded = 1563141161, Category = CAT.LAND, Submitter = "ZuoLiang", Name = "Rainbow over Zuo", SizeX = 500*(640/300), SizeY = 500, SizeZ = 500, RGB = { 1, 1, 1, 1 } },

	{ Id = 5086, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Behavior = "MaskedColor", Name = "Brooch, Ballerina", SizeX = 20*(323/403), SizeY = 20, SizeZ = 20, RGB = { 1, 1, 1, 1 } },
	{ Id = 5087, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Behavior = "MaskedColor", Name = "Plate, Rustic Pewter Charger", SizeX = 50*(801/822), SizeY = 50, SizeZ = 50, RGB = { 1, 1, 1, 1 } },
	{ Id = 5088, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Behavior = "MaskedColor", Name = "Plate, Fancy Porcelain", SizeX = 50*(1000/987), SizeY = 50, SizeZ = 50, RGB = { 1, 1, 1, 1 } },
	{ Id = 5089, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Brooch, Bird", SizeX = 20*(454/469), SizeY = 20, SizeZ = 20, RGB = { 1, 1, 1, 1 } },
	{ Id = 5090, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Plate, Silver Crest Charger", SizeX = 50*(829/831), SizeY = 50, SizeZ = 50, RGB = { 1, 1, 1, 1 } },
	{ Id = 5091, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Behavior = "MaskedColor", Name = "Cameo, Classic", SizeX = 50*(500/601), SizeY = 50, SizeZ = 50, RGB = { 1, 1, 1, 1 } },
	{ Id = 5092, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Cutlery, Fork", SizeX = 30*(202/862), SizeY = 30, SizeZ = 30, RGB = { 1, 1, 1, 1 } },
	{ Id = 5093, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Cutlery, Knife", SizeX = 30*(153/862), SizeY = 30, SizeZ = 30, RGB = { 1, 1, 1, 1 } },
	{ Id = 5094, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Cutlery, Spoon", SizeX = 30*(133/543), SizeY = 30, SizeZ = 30, RGB = { 1, 1, 1, 1 } },
	{ Id = 5095, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Behavior = "MaskedColor", Name = "Hand Mirror, Ornate", SizeX = 50*(702/1579), SizeY = 50, SizeZ = 50, RGB = { 1, 1, 1, 1 }, TintAlpha = 0.6 },
	{ Id = 5096, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Behavior = "MaskedColor", Name = "Earrings", SizeX = 16*(108/397), SizeY = 16, SizeZ = 16, RGB = { 1, 1, 1, 1 } },
	{ Id = 5097, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Behavior = "MaskedColor", Name = "Hair Comb", SizeX = 30*(621/696), SizeY = 30, SizeZ = 30, RGB = { 1, 1, 1, 1 } },
	{ Id = 5098, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Behavior = "MaskedColor", Name = "Necklace, Teardrop", SizeX = 30*(363/484), SizeY = 30, SizeZ = 30, RGB = { 1, 1, 1, 1 } },
	{ Id = 5099, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Behavior = "MaskedColor", Name = "Necklace, Pearl", SizeX = 30, SizeY = 30, SizeZ = 30, RGB = { 1, 1, 1, 1 } },
	{ Id = 5100, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Behavior = "MaskedColor", Name = "Chandelier, Pearl", SizeX = 30*(312/549), SizeY = 30, SizeZ = 30, RGB = { 1, 1, 1, 1 } },
	{ Id = 5101, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Behavior = "MaskedColor", Name = "Cameo, Venus", SizeX = 50*(485/711), SizeY = 50, SizeZ = 50, RGB = { 1, 1, 1, 1 } },
	{ Id = 5102, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Drawer Pull, Decorative", SizeX = 12*(434/425), SizeY = 12, SizeZ = 12, RGB = { 1, 1, 1, 1 } },
	{ Id = 5103, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Brooch, Dragon", SizeX = 20, SizeY = 20, SizeZ = 20, RGB = { 1, 1, 1, 1 } },
	{ Id = 5104, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Key", SizeX = 16*(196/611), SizeY = 16, SizeZ = 16, RGB = { 1, 1, 1, 1 } },
	{ Id = 5105, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Necklace Chain, Pearl", SizeX = 30*(364/470), SizeY = 30, SizeZ = 30, RGB = { 1, 1, 1, 1 } },
	{ Id = 5106, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Pocketwatch", SizeX = 20*(768/585), SizeY = 20, SizeZ = 20, RGB = { 1, 1, 1, 1 } },
	{ Id = 5107, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Rectangular Frame, Painted Wood", SizeX = 50*(595/714), SizeY = 50, SizeZ = 50, RGB = { 1, 1, 1, 1 } },
	{ Id = 5108, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Wood Frame Border, Horizontal", SizeX = 50, SizeY = 50*(189/1117), SizeZ = 50*(189/1117), RGB = { 1, 1, 1, 1 } },
	{ Id = 5109, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Wood Frame Border, Vertical", SizeX = 50*(190/1117), SizeY = 50, SizeZ = 50, RGB = { 1, 1, 1, 1 } },
	{ Id = 5110, DateAdded = 1564724469, Category = CAT.DECO, Submitter = "Chryseia", Name = "Clockface", SizeX = 30*(661/665), SizeY = 30, SizeZ = 30, RGB = { 1, 1, 1, 1 } },

	{ Id = 5111, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "snowfaeriewings", Name = "Faerie Door", SizeX = 518, SizeY = 488, SizeZ = 488, RGB = { 1, 1, 1, 1 } },
	{ Id = 5112, DateAdded = 1564914733, Category = CAT.LAND, Submitter = "StabbityDoom", Name = "Willow Tree, Weeping", SizeX = 804, SizeY = 905, SizeZ = 905, RGB = { 1, 1, 1, 1 } },

	{ Id = 5113, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Art, Bird & Blossom", SizeX = 474, SizeY = 694, SizeZ = 694, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5114, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Art, Fortress", SizeX = 441, SizeY = 474, SizeZ = 474, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5115, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Art, Lighthouse", SizeX = 418, SizeY = 423, SizeZ = 423, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5116, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Art, Stained Glass Panel", SizeX = 552, SizeY = 419, SizeZ = 419, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5117, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Carved Wood Panel, Clover", SizeX = 514, SizeY = 514, SizeZ = 514, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5118, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Carved Wood Panel, Crown", SizeX = 514, SizeY = 514, SizeZ = 514, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5119, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Carved Wood Panel, Decorative", SizeX = 273, SizeY = 550, SizeZ = 550, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5120, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Carved Wood Panel, Distressed Bird", SizeX = 573, SizeY = 1069, SizeZ = 1069, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5121, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Carved Wood Panel, Dragon", SizeX = 572, SizeY = 572, SizeZ = 572, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5122, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Carved Wood Panel, Gothic", SizeX = 324, SizeY = 703, SizeZ = 703, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5123, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Carved Wood Panel, Hanging Cage", SizeX = 362, SizeY = 704, SizeZ = 704, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5124, DateAdded = 1564914733, Category = CAT.DECO, Submitter = "Chryseia", Name = "Carved Wood Panel, Painted", SizeX = 283, SizeY = 677, SizeZ = 677, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5125, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Door, French", SizeX = 461, SizeY = 1474, SizeZ = 1474, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5126, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Floor, Border, Floral Inlay", SizeX = 1135, SizeY = 563, SizeZ = 563, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5127, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Floor, Border, Geometric", SizeX = 281, SizeY = 370, SizeZ = 370, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5128, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Floor, Courtyard Pavers", SizeX = 1000, SizeY = 827, SizeZ = 827, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5129, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Floor, Fancy Parquet", SizeX = 736, SizeY = 737, SizeZ = 737, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5130, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Floor, Flower Vine Tile", SizeX = 955, SizeY = 935, SizeZ = 935, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5131, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Floor, Herringbone", SizeX = 420, SizeY = 819, SizeZ = 819, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5132, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Floor, Marble Diamonds", SizeX = 1042, SizeY = 1015, SizeZ = 1015, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5133, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Floor, Medallion, Floral Inlay", SizeX = 597, SizeY = 600, SizeZ = 600, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5134, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Floor, Medallion, Marble Inlay", SizeX = 1060, SizeY = 1060, SizeZ = 1060, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5135, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Floor, Parquet Simple", SizeX = 471, SizeY = 474, SizeZ = 474, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5136, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Floor, Spanish Tiles", SizeX = 474, SizeY = 474, SizeZ = 474, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5137, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Pilaster, Carved Torch", SizeX = 482, SizeY = 1593, SizeZ = 1593, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5138, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Pilaster, Distressed Bird", SizeX = 573, SizeY = 1635, SizeZ = 1635, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5139, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Pilaster, Gothic", SizeX = 365, SizeY = 720, SizeZ = 720, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5140, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Pilaster, Thin, Painted", SizeX = 48, SizeY = 997, SizeZ = 997, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5141, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Railing, Palm & Elephant", SizeX = 578, SizeY = 1053, SizeZ = 1053, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5142, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Railing, Scrolling Leaf", SizeX = 185, SizeY = 1067, SizeZ = 1067, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5143, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Slab, Brick and Plaster", SizeX = 0.25*1643, SizeY = 0.25*1125, SizeZ = 0.25*1125, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5144, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Slab, Cedar Roof", SizeX = 0.25*2459, SizeY = 0.25*789, SizeZ = 0.25*789, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5145, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Slab, Distressed Wood Plank", SizeX = 0.25*2143, SizeY = 0.25*375, SizeZ = 0.25*375, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5146, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Slab, Rustic Wood Planks", SizeX = 0.25*474, SizeY = 0.25*474, SizeZ = 0.25*474, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5147, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Slab, Sanded Wood Plank", SizeX = 0.25*2250, SizeY = 0.25*457, SizeZ = 0.25*457, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5148, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Slab, Slate Roof Tile", SizeX = 0.25*516, SizeY = 0.25*540, SizeZ = 0.25*540, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5149, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Slab, Smooth Plaster", SizeX = 0.25*1360, SizeY = 0.25*1810, SizeZ = 0.25*1810, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5150, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wainscoting, French", SizeX = 0.5*575, SizeY = 0.5*988, SizeZ = 0.5*988, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5151, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wainscoting, Wood", SizeX = 0.5*306, SizeY = 0.5*306, SizeZ = 0.5*306, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5152, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wallpaper, Bouquets", SizeX = 0.5*351, SizeY = 0.5*343, SizeZ = 0.5*343, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5153, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wallpaper, Chinoiserie 1", SizeX = 147, SizeY = 505, SizeZ = 505, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5154, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wallpaper, Chinoiserie 2", SizeX = 148, SizeY = 505, SizeZ = 505, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5155, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wallpaper, Chinoiserie 3", SizeX = 148, SizeY = 505, SizeZ = 505, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5156, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wallpaper, Chinoiserie 4", SizeX = 146, SizeY = 505, SizeZ = 505, RGB = { 1, 1, 1, 1 }  },
	{ Id = 5157, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wallpaper, Classical Archways", SizeX = 0.25*814, SizeY = 0.25*1059, SizeZ = 0.25*1059, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5158, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wallpaper, Fan Pattern", SizeX = 0.25*539, SizeY = 0.25*534, SizeZ = 0.25*534, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5159, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wallpaper, Faux Panels", SizeX = 0.25*529, SizeY = 0.25*884, SizeZ = 0.25*884, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5160, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wallpaper, Floral Pattern", SizeX = 0.25*430, SizeY = 0.25*430, SizeZ = 0.25*430, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5161, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wallpaper, Textured Panel", SizeX = 0.25*209, SizeY = 0.25*720, SizeZ = 0.25*720, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },
	{ Id = 5162, DateAdded = 1564914733, Category = CAT.BUILD, Submitter = "Chryseia", Name = "Wallpaper, Urn Damask", SizeX = 0.25*1004, SizeY = 0.25*785, SizeZ = 0.25*785, RGB = { 1, 1, 1, 1 }, Behavior = "Pattern" },

	{ Id = 5163, Submitter = "Stormahawk", Name = "Stormahawk, Formal", Callback = function( template )
		template.DefaultGreeting = ""
		template.TexWidth, template.TexHeight = 1024, 1024
		template.CellsX, template.CellsY, template.MaxCells = 5, 2, 6
		template.CellInterval, template.LoopPauseCells, template.MidpointPauseCells = 220, 14, 20
		template.CellWidth, template.CellHeight = 178, 512
		template.LocalWidth, template.LocalHeight = 178, 512
		template.DefaultWidth, template.DefaultHeight = 240*(178/512), 240
		template.LoopForwardReverse = true
		template.NonSinusoidal = false
		template.R, template.G, template.B = 1, 1, 1
		EHT.Effect.CreatePlayerNPC( template )
	end },
}
EHT.CustomEffectTemplates = CUSTOM_TEMPLATES

local function GetCustomTemplateTexture( id, index )
	return string.format( EHT.PATH_TEXTURES_CUSTOM, tostring( id ), ( index and 1 ~= index ) and string.format( "_%d", index ) or "" )
end

---[ Private Variables ]---

local EFFECT_EDITOR

local EffectList = { }
local EffectTypeList = { }
local EffectTypeByNameList = { }
local ParticleList = { }
local InactiveParticleList = { }
local CameraFacingParticles = { }
EHT.CameraFacingParticles = CameraFacingParticles
local NumParticles = 0

local HideAllEffectsFlag = false
local CameraWindow
local EffectEditButtonsWindow
local EffectEditorWindow
local GlobalEffectsWindow
local ReticleWindow
local ParticleWindow, ParticleWindow2D

local TamrielTime = { Hour = 0, Minute = 0, Second = 0, }
local PlayerX, PlayerY, PlayerZ, PlayerHeading = 0, 0, 0, 0
local DepthToUIHeight, DepthToUIWidth = 1, 1
local IsHouseZone = false
local CameraPitch, CameraYaw, CameraRoll = 0, 0, 0
local CameraX, CameraY, CameraZ, CameraHeading = 0, 0, 0, 0
local CameraNormalX, CameraNormalY, CameraNormalZ = 0, 0, 0
local CameraForwardX, CameraForwardY, CameraForwardZ = 0, 0, 0
local FaceCameraPitch, FaceCameraYaw, FaceCameraRoll = 0, 0, 0
local CameraLastUpdate = 0
local OldCameraX, OldCameraY, OldCameraZ, OldCameraHeading = 0, 0, 0, 0
local ReticleVectorX, ReticleVectorY, ReticleVectorZ = 0, 0, 0
local ReticleEffect, ReticleEffectButton, ReticleEffectDistance, ReticleEffectTimer
local CheckedReticleEffectDuringPlacement = false
local CurrentEditorEffect
local IsEditModeActive = false
local InvalidMailIds = { }
local FrameTime = 0

local function RefreshViewDimensions()
	EHT.Effect.ViewWidth, EHT.Effect.ViewHeight = GuiRoot:GetDimensions()
end
RefreshViewDimensions()
EVENT_MANAGER:RegisterForEvent( "EHT.RefreshViewDimensions", EVENT_SCREEN_RESIZED, RefreshViewDimensions )

EHT.Metrics:Add( "Particle Animation", "ms", 10,
	function( metric )
		local avg = metric:GetAverage()
	end
)

EHT.Metrics:Add( "Z-Depth Order", "ms", 10,
	function( metric )
		local avg = metric:GetAverage()
	end
)


local ENABLE_CHATCAST_REFLECTION = false

SLASH_COMMANDS[ "/acceptmyfx" ] = function()
	ENABLE_CHATCAST_REFLECTION = not ENABLE_CHATCAST_REFLECTION
	df( "|cffffffYou |cffff00%s|cffffff accept FX data from other players for your own homes.", ENABLE_CHATCAST_REFLECTION and "temporarily will" or "will not" )
end

function EHT.IsChatcastReflectionEnabled()
	return ENABLE_CHATCAST_REFLECTION
end

---[ Brightness Management ]---

local BrightnessTransitionInterval = 10000
local LastBrightnessChange, LastBrightnessValue

local RequestedBrightness = {
	Local = { },
	Global = { },
	Override = nil,
}

local function ManageBrightness()
	local ft = FrameTime
	local originalValue = ( ( EHT.Util.GetPreservedSetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_GAMMA_ADJUSTMENT ) or EHT.Util.GetCurrentSetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_GAMMA_ADJUSTMENT ) or 150 ) - 25 ) / 125
	local overrideBrightness = RequestedBrightness.Override
	local globalBrightness, localBrightness
	local sources = 0
	local newValue

	if overrideBrightness then
		newValue = overrideBrightness
		sources = 1
	else
		for effect, value in pairs( RequestedBrightness.Global ) do
			globalBrightness = math.min( globalBrightness or 1, value )
			sources = sources + 1
		end

		for effect, value in pairs( RequestedBrightness.Local ) do
			localBrightness = math.min( localBrightness or 1, value )
			sources = sources + 1
		end

		newValue = localBrightness or globalBrightness or originalValue
	end

	local currentValue = ( ( ( EHT.Util.GetCurrentSetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_GAMMA_ADJUSTMENT ) or 150 ) - 25 ) / 125 ) or 1
	local delta

	newValue, currentValue = round( newValue, 2 ), round( currentValue, 2 )

	if newValue == currentValue then
		LastBrightnessChange, LastBrightnessValue = nil, nil
		if 0 == sources then
			EHT.Util.RestoreSetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_GAMMA_ADJUSTMENT )
			EVENT_MANAGER:UnregisterForUpdate( "EHT.ManageBrightness" )
		end
		return
	end

	if newValue ~= LastBrightnessValue then
		delta, LastBrightnessValue, LastBrightnessChange = 0, newValue, ft
	else
		delta = LastBrightnessChange and zo_clamp( ( ft - LastBrightnessChange ) / BrightnessTransitionInterval, 0, 1 ) or 1
	end

	local finalValue = math.floor( 25 + 125 * zo_lerp( currentValue, newValue, delta ) )
	EHT.Util.ModifySetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_GAMMA_ADJUSTMENT, finalValue )

	if 1 <= delta then
		LastBrightnessChange, LastBrightnessValue = nil, nil
	end
end

local function RequestBrightness( effect, effectScope, value )
	if "Override" == effectScope then
		RequestedBrightness.Override = value
	else
		local scope = RequestedBrightness[effectScope]
		if not effect or not scope then
			return
		end

		scope[effect] = tonumber( value )
	end

	EVENT_MANAGER:RegisterForUpdate( "EHT.ManageBrightness", 100, ManageBrightness )
end
EHT.Effect.RequestBrightness = RequestBrightness

---[ Effect Serializers / Deserializers ]---

local function GetBase88MaxLen( digits )
	local s = EHT.Util.IntToBase88( 10 ^ digits )
	return #s
end

local function ExcludeInvalidStringChars( s )
	if not s then return nil end
	local output = string.gsub( s, "[^%s%w%p]", "" )
	return output
end
EHT.ExcludeInvalidStringChars = ExcludeInvalidStringChars

local function TransformCharsForSerialization( s )
	if not s then return nil end
	s = string.gsub( string.gsub( s, "[\n\r]", "\~" ), " ", "\`" )
	return s
end
EHT.TransformCharsForSerialization = TransformCharsForSerialization

local function TransformCharsForDeserialization( s )
	if not s then return nil end
	s = string.gsub( string.gsub( s, "\~", "\n" ), "\`", " " )
	return s
end
EHT.TransformCharsForDeserialization = TransformCharsForDeserialization

local function EffectSerializersInt( value, digits )
	if not value then value = 0 end
	value = math.abs( value )
	return EHT.Util.IntToBase88( EHT.Util.CompressInteger( value, digits ) )
end

function EHT.EffectSerializers.Int1( value )
	return EffectSerializersInt( value, 1 )
end

function EHT.EffectSerializers.Int2( value )
	return EffectSerializersInt( value, 2 )
end

function EHT.EffectSerializers.Int3( value )
	return EffectSerializersInt( value, 3 )
end

function EHT.EffectSerializers.Int4( value )
	return EffectSerializersInt( value, 4 )
end

function EHT.EffectSerializers.Int5( value )
	return EffectSerializersInt( value, 5 )
end

function EHT.EffectSerializers.Int6( value )
	return EffectSerializersInt( value, 6 )
end

function EHT.EffectSerializers.Int7( value )
	return EffectSerializersInt( value, 7 )
end

function EHT.EffectSerializers.Int8( value )
	return EffectSerializersInt( value, 8 )
end

local function EffectDeserializersInt( data, dataIndex, digits )
	local dataLen = GetBase88MaxLen( digits )
	local base88 = string.sub( data, dataIndex, dataIndex + dataLen - 1 )
	if not base88 or #base88 < dataLen then
		return nil, nil
	end

	local base88Value, errorMessage = EHT.Util.Base88ToInt( base88 )
	if errorMessage or not base88Value then
		return nil, nil
	end

	local value = EHT.Util.DecompressInteger( tostring( base88Value ), 1, digits )
	dataIndex = dataIndex + dataLen
	return value, dataIndex
end

function EHT.EffectDeserializers.Int1( data, dataIndex )
	return EffectDeserializersInt( data, dataIndex, 1 )
end

function EHT.EffectDeserializers.Int2( data, dataIndex )
	return EffectDeserializersInt( data, dataIndex, 2 )
end

function EHT.EffectDeserializers.Int3( data, dataIndex )
	return EffectDeserializersInt( data, dataIndex, 3 )
end

function EHT.EffectDeserializers.Int4( data, dataIndex )
	return EffectDeserializersInt( data, dataIndex, 4 )
end

function EHT.EffectDeserializers.Int5( data, dataIndex )
	return EffectDeserializersInt( data, dataIndex, 5 )
end

function EHT.EffectDeserializers.Int6( data, dataIndex )
	return EffectDeserializersInt( data, dataIndex, 6 )
end

function EHT.EffectDeserializers.Int7( data, dataIndex )
	return EffectDeserializersInt( data, dataIndex, 7 )
end

function EHT.EffectDeserializers.Int8( data, dataIndex )
	return EffectDeserializersInt( data, dataIndex, 8 )
end

function EHT.EffectSerializers.StringVar( s )
	s = TransformCharsForSerialization( s or "" )
	s = ExcludeInvalidStringChars( s )
	if MAX_META_STRING_LEN < #s then s = string.sub( s, 1, MAX_META_STRING_LEN ) end
	local sLen = EHT.Util.IntToBase88( EHT.Util.CompressInteger( #s, 4 ) )
	return sLen .. s
end

function EHT.EffectDeserializers.StringVar( data, dataIndex )
	local sLen
	sLen, dataIndex = EffectDeserializersInt( data, dataIndex, 4 )
	if not sLen or not dataIndex then
		return nil, nil
	end

	if 0 < sLen then
		local s = string.sub( data, dataIndex, dataIndex + ( sLen - 1 ) )
		if #s < sLen then
			return nil, nil
		end

		s = TransformCharsForDeserialization( s )

		return s, dataIndex + sLen
	else
		return "", dataIndex
	end
end

---[ Metadata Parameters ]---

local MapMetaParamsByIndex = {
	{
		Name = "Name",
		Cast = tostring,
		Default = "",
		Deserializer = EHT.EffectDeserializers.StringVar,
		Serializer = EHT.EffectSerializers.StringVar,
	},
	{
		Name = "Message",
		Cast = tostring,
		Default = "",
		Deserializer = EHT.EffectDeserializers.StringVar,
		Serializer = EHT.EffectSerializers.StringVar,
	},
	{
		Name = "Title",
		Cast = tostring,
		Default = "",
		Deserializer = EHT.EffectDeserializers.StringVar,
		Serializer = EHT.EffectSerializers.StringVar,
	},
	{
		Name = "HouseId",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int4,
		Serializer = EHT.EffectSerializers.Int4,
	},
	{
		Name = "Owner",
		Cast = tostring,
		Default = "",
		Deserializer = EHT.EffectDeserializers.StringVar,
		Serializer = EHT.EffectSerializers.StringVar,
	},
	{
		Name = "GuildId",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int8,
		Serializer = EHT.EffectSerializers.Int8,
	},
	{
		Name = "HeraldryBkgCat",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int5,
		Serializer = EHT.EffectSerializers.Int5,
	},
	{
		Name = "HeraldryBkgStyle",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int5,
		Serializer = EHT.EffectSerializers.Int5,
	},
	{
		Name = "HeraldryBkgColor1",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int5,
		Serializer = EHT.EffectSerializers.Int5,
	},
	{
		Name = "HeraldryBkgColor2",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int5,
		Serializer = EHT.EffectSerializers.Int5,
	},
	{
		Name = "HeraldryCrestCat",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int5,
		Serializer = EHT.EffectSerializers.Int5,
	},
	{
		Name = "HeraldryCrestStyle",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int5,
		Serializer = EHT.EffectSerializers.Int5,
	},
	{
		Name = "HeraldryCrestColor",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int5,
		Serializer = EHT.EffectSerializers.Int5,
	},
	{
		Name = "Pattern Scale % (X)",
		Cast = tonumber,
		Default = 100,
		Deserializer = EHT.EffectDeserializers.Int4,
		Serializer = EHT.EffectSerializers.Int4,
	},
	{
		Name = "Pattern Scale % (Y)",
		Cast = tonumber,
		Default = 100,
		Deserializer = EHT.EffectDeserializers.Int4,
		Serializer = EHT.EffectSerializers.Int4,
	},
	{
		Name = "Lore Book",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int4,
		Serializer = EHT.EffectSerializers.Int4,
	},
	{
		Name = "Target Effect",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int8,
		Serializer = EHT.EffectSerializers.Int8,
	},
	{
		Name = "Lore Collection",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int4,
		Serializer = EHT.EffectSerializers.Int4,
	},
	{
		Name = "Lore Category",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int4,
		Serializer = EHT.EffectSerializers.Int4,
	},
	{
		Name = "Furniture",
		Cast = tostring,
		Default = "",
		Deserializer = EHT.EffectDeserializers.StringVar,
		Serializer = EHT.EffectSerializers.StringVar,
	},
	{
		Name = "When Furniture",
		Cast = tostring,
		Default = "",
		Deserializer = EHT.EffectDeserializers.StringVar,
		Serializer = EHT.EffectSerializers.StringVar,
	},
	{
		Name = "Is",
		Cast = tostring,
		Default = "",
		Deserializer = EHT.EffectDeserializers.StringVar,
		Serializer = EHT.EffectSerializers.StringVar,
	},
	{
		Name = "Then Furniture",
		Cast = tostring,
		Default = "",
		Deserializer = EHT.EffectDeserializers.StringVar,
		Serializer = EHT.EffectSerializers.StringVar,
	},
	{
		Name = "Will Be",
		Cast = tostring,
		Default = "",
		Deserializer = EHT.EffectDeserializers.StringVar,
		Serializer = EHT.EffectSerializers.StringVar,
	},
	{
		Name = "Then Group",
		Cast = tostring,
		Default = "",
		Deserializer = EHT.EffectDeserializers.StringVar,
		Serializer = EHT.EffectSerializers.StringVar,
	},
	{
		Name = "Then Group Furniture",
		Cast = tostring,
		Default = "",
		Deserializer = EHT.EffectDeserializers.StringVar,
		Serializer = EHT.EffectSerializers.StringVar,
	},
	{
		Name = "Scale % (X)",
		Cast = tonumber,
		Default = 100,
		Deserializer = EHT.EffectDeserializers.Int4,
		Serializer = EHT.EffectSerializers.Int4,
	},
	{
		Name = "Scale % (Y)",
		Cast = tonumber,
		Default = 100,
		Deserializer = EHT.EffectDeserializers.Int4,
		Serializer = EHT.EffectSerializers.Int4,
	},
	{
		Name = "Offset % (X)",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int3,
		Serializer = EHT.EffectSerializers.Int3,
	},
	{
		Name = "Offset % (Y)",
		Cast = tonumber,
		Default = 0,
		Deserializer = EHT.EffectDeserializers.Int3,
		Serializer = EHT.EffectSerializers.Int3,
	},
}

local MapMetaParamsByName = { }

for index, param in ipairs( MapMetaParamsByIndex ) do
	param.Index = index
	MapMetaParamsByName[ string.lower( param.Name ) ] = param
end

EHT.MetaParamsByIndex = MapMetaParamsByIndex
EHT.MetaParamsByName = MapMetaParamsByName

local function GetMetaParamByName( name )
	return MapMetaParamsByName[ string.lower( name ) ]
end

local function GetMetaParamByIndex( index )
	return MapMetaParamsByIndex[ index ]
end

---[ World Functions ]---

local function GetParticleWindow()
	local win = ParticleWindow
	if nil == win then
		win = WINDOW_MANAGER:CreateTopLevelWindow( PARTICLE_PREFIX )
		ParticleWindow = win
		win:SetHidden( false )
		win:SetDimensions( 1, 1 )
		win:SetMovable( true )
		win:SetMouseEnabled( false )
		win:SetClampedToScreen( false )
		win:SetAnchor( TOPLEFT, GuiRoot, TOPLEFT, -10, -10 )
		win:Create3DRenderSpace()
		win:SetDrawLayer( DL_BACKGROUND )
		win:SetDrawTier( DT_LOW )
	end
	return win
end

local function GetParticleWindow2D()
	local win = ParticleWindow2D
	if nil == win then
		win = WINDOW_MANAGER:CreateTopLevelWindow( PARTICLE_PREFIX .. "2D" )
		ParticleWindow2D = win
		win:SetHidden( false )
		win:SetAnchorFill()
		win:SetMovable( false )
		win:SetMouseEnabled( false )
		win:SetClampedToScreen( false )
		win:SetDrawLayer( DL_OVERLAY )
		win:SetDrawTier( DT_HIGH )
	end
	return win
end

local function Assert( validCondition, invalidMessage )
	if not validCondition and EHT.IsDev then
		zo_callLater( function() df( "|cff3333ESSENTIAL HOUSING TOOLS:|r\n%s", invalidMessage ) end, 4000 )
	end
	return validCondition
end

local function GetAngleTo( xFrom, zFrom, xTo, zTo )
	return math.atan2( -( xTo - xFrom ), -( zTo - zFrom ) ) % RAD360
end

function EHT.World:GetAngleTo( ... )
	return GetAngleTo( ... )
end

local function VariableEaseIn( interval, scale )
	return interval ^ scale
end
EHT.World.VariableEaseIn = VariableEaseIn

local function VariableEaseOut( interval, scale )
	return 1 - ( interval ^ scale )
end
EHT.World.VariableEaseOut = VariableEaseOut

local function VariableEase( interval, scale )
    if interval < 0.5 then
        return ( 2 * interval ) ^ scale
    else
		return ( 2 - 2 * interval ) ^ scale
	end
end
EHT.World.VariableEase = VariableEase

local function InverseVariableEase( interval, scale )
    if interval < 0.5 then
        return 1 - ( ( 2 * ( 0.5 - interval ) ) ^ scale )
    else
		return 1 - ( ( 2 * ( interval - 0.5 ) ) ^ scale )
	end
end
EHT.World.InverseVariableEase = InverseVariableEase

local function Ease2( interval )
    if interval < 0.5 then
        return ( 2 * interval ) ^ 2
    else
		return ( 2 - 2 * interval ) ^ 2
	end
end
local EaseInOut2 = Ease2
EHT.World.EaseInOut2 = EaseInOut2

local function InverseEase2( interval )
    if interval < 0.5 then
        return 1 - ( ( 2 * ( 0.5 - interval ) ) ^ 2 )
    else
		return 1 - ( ( 2 * ( interval - 0.5 ) ) ^ 2 )
	end
end
local EaseOutIn2 = InverseEase2
EHT.World.EaseOutIn2 = EaseOutIn2

local function EaseIn2( interval )
	return interval ^ 2
end
local function EaseOut2( interval )
	return 1 - ( interval ^ 2 )
end

local function Ease3( interval )
    if interval < 0.5 then
        return ( 2 * interval ) ^ 3
    else
		return ( 2 - 2 * interval ) ^ 3
	end
end
local EaseInOut3 = Ease3
local function InverseEase3( interval )
    if interval < 0.5 then
        return 1 - ( ( 2 * ( 0.5 - interval ) ) ^ 3 )
    else
		return 1 - ( ( 2 * ( interval - 0.5 ) ) ^ 3 )
	end
end
local EaseOutIn3 = InverseEase3
local function EaseIn3( interval )
	return interval ^ 3
end
local function EaseOut3( interval )
	return 1 - ( interval ^ 3 )
end

local function Ease4( interval )
    if interval < 0.5 then
        return ( 2 * interval ) ^ 4
    else
		return ( 2 - 2 * interval ) ^ 4
	end
end
local EaseInOut4 = Ease4
local function InverseEase4( interval )
    if interval < 0.5 then
        return 1 - ( ( 2 * ( 0.5 - interval ) ) ^ 4 )
    else
		return 1 - ( ( 2 * ( interval - 0.5 ) ) ^ 4 )
	end
end
local EaseOutIn4 = InverseEase4
local function EaseIn4( interval )
	return interval ^ 4
end
local function EaseOut4( interval )
	return 1 - ( interval ^ 4 )
end
-- /script eff( 1 ).Options.SampleMultiplier = 60
local function EasedCyclicalLerp( minValue, maxValue, interval, easingExponent )
	easingExponent = easingExponent or 2
	local easedInterval
    if interval < 0.5 then
        easedInterval = 1 - ( ( 2 * ( 0.5 - interval ) ) ^ easingExponent )
    else
		easedInterval = 1 - ( ( 2 * ( interval - 0.5 ) ) ^ easingExponent )
	end
	return zo_lerp( minValue, maxValue, 1 - math.abs( -1 + 2 * easedInterval ) )
end
function EHT.World.EasedCyclicalLerp( ... )
	return EasedCyclicalLerp( ... )
end

local function CreateEasingFunction( period, minValue, maxValue )
	return function( self, interval, duration )
		return zo_lerp( minValue, maxValue, InverseEase3( ( interval * period ) % 1 ) )
	end
end

local function CreateEasingVelocityFunction( xRatioPerSecond, yRatioPerSecond, zRatioPerSecond )
	return function( self, interval, duration )
		return xRatioPerSecond * self.Effect.SizeX, yRatioPerSecond * self.Effect.SizeY, zRatioPerSecond * self.Effect.SizeZ
	end
end

local function CreateEasingMultiplierFunction( ... )
	local easing = CreateEasingFunction( ... )
	return function( self, interval, duration, p1, p2, p3 )
		local c = easing( self, interval, duration )
		return p1 and p1 * c, p2 and p2 * c, p3 and p3 * c
	end
end

local randomEasingMultiplierCounter = 0
local function CreateRandomizedEasingMultiplierFunction( ... )
	randomEasingMultiplierCounter = randomEasingMultiplierCounter + 1
	local key = string.format( "RandomEasingOffset%d", randomEasingMultiplierCounter )
	local easing = CreateEasingFunction( ... )
	return function( self, interval, duration, p1, p2, p3 )
		local offset = self[ key ]
		if not offset then
			offset = math.random()
			self[ key ] = offset
		end
		local c = easing( self, ( interval + offset ) % 1, duration )
		return p1 and p1 * c, p2 and p2 * c, p3 and p3 * c
	end
end

local function DotProduct( v1, v2, v3, w1, w2, w3 )
	return v1 * w1 + v2 * w2 + v3 * w3
end

local function VectorLength( v1, v2, v3 )
	return math.sqrt( DotProduct( v1, v2, v3, v1, v2, v3 ) )
end

function EHT.World:VectorLength( v1, v2, v3 )
	return VectorLength( v1, v2, v3 )
end

local function InnerProduct( x1, y1, z1, x2, y2, z2 )
	return x1 * x2, y1 * y2, z1 * z2
end

function EHT.World:InnerProduct( ... )
	return InnerProduct( ... )
end

local function NormalVector( v1, v2, v3 )
	local c = 1 / VectorLength( v1, v2, v3 )
	return v1 * c, v2 * c, v3 * c
end

function EHT.World:GetNormalVector( ... )
	return NormalVector( ... )
end

function GetAngleBetweenPoints(x1, y1, z1, x2, y2, z2)
	local dot = DotProduct(x1, y1, z1, x2, y2, z2)
	local mag1 = VectorLength(x1, y1, z1)
	local mag2 = VectorLength(x2, y2, z2)
	return math.acos(dot / (mag1 * mag2))
end

function EHT.World:GetAspectRatioWidth( width, height, newWidth, newHeight, maintainRatio )
	local result = ( newWidth / newHeight ) * ( width / height )
	return math.max( 1, false ~= maintainRatio and round( result ) or result )
end

local function CrossProduct( x1, y1, z1, x2, y2, z2 )
	return ( y1 * z2 ) - ( z1 * y2 ),	( z1 * x2 ) - ( x1 * z2 ),	( x1 * y2 ) - ( y1 * x2 )
end

function EHT.World:ResetReticleCheck()
	CheckedReticleEffectDuringPlacement = false
end

function EHT.World:ResetReticleEffect()
	ReticleEffect, ReticleEffectButton, ReticleEffectDistance, ReticleEffectTimer = nil, nil, 0, 0
	CheckedReticleEffectDuringPlacement = false
	EVENT_MANAGER:UnregisterForUpdate( "EHT.OnDragEffect" )
end

function EHT.World:GetPlayerPosition()
	return PlayerX, PlayerY, PlayerZ, PlayerHeading
end

function EHT.World:GetCameraPosition()
	return CameraX, CameraY, CameraZ, CameraHeading
end

function EHT.World:GetCameraOrientation()
	if not CameraWindow then return 0, 0, 0 end
	return CameraWindow.CameraControl:Get3DRenderSpaceOrientation()
end

function EHT.World:GetCameraDistance( x, y, z )
	return zo_distance3D( x, y, z, CameraX, CameraY, CameraZ )
end

function EHT.World:GetCameraSurfaceNormal()
	local tex = CameraWindow.CameraControl
	local x0, y0, z0 = tex:Convert3DWorldPositionToLocalPosition( 0, 0, 0 )
	local x1, y1, z1 = tex:Convert3DWorldPositionToLocalPosition( 1, 0, 0 )
	local x2, y2, z2 = tex:Convert3DWorldPositionToLocalPosition( 0, 1, 0 )
	return CrossProduct( x1 - x0, y1 - y0, z1 - z0, x2 - x0, y2 - y0, z2 - z0 )
end

local function GetCameraForward()
	if not CameraWindow then return 0, 0, 0 end
	return CameraWindow.CameraControl:Get3DRenderSpaceForward()
end

function EHT.World:GetCameraForward()
	return GetCameraForward()
end

function GetCameraRight()
	if not CameraWindow then return 0, 0, 0 end
	return CameraWindow.CameraControl:Get3DRenderSpaceRight()
end

function EHT.World:GetCameraRight()
	return GetCameraRight()
end

function GetCameraUp()
	if not CameraWindow then return 0, 0, 0 end
	return CameraWindow.CameraControl:Get3DRenderSpaceUp()
end

function EHT.World:GetCameraUp()
	return GetCameraUp()
end

function EHT.World:FacePlayer( x, y, z )
	local dx, dz = PlayerX - x, PlayerZ - z
	local yaw = math.atan2( dx, dz )
	return 0, yaw, 0
end
--[[
function EHT.World:FaceCamera( x, y, z )
	local normalX, normalY, normalZ = NormalVector( CameraX - x, CameraY - y, CameraZ - z )
	local pitch = -math.asin( normalY )
	local yaw = math.atan2( normalX, normalZ )
	return pitch, yaw, 0
end
]]
function EHT.World:GetCameraFacingOrientation()
	return FaceCameraPitch, FaceCameraYaw, FaceCameraRoll
end

function EHT.World:GetReticleVectorPoint( distance )
	local cx, cy, cz = CameraX, CameraY, CameraZ
	local dx, dy, dz = EHT.World:GetCameraForward()

	if nil == dx then return end
	if nil == distance then distance = MAX_RETICLE_DISTANCE end

	return cx + dx * distance, cy + dy * distance, cz + dz * distance
end

local function GetMinPointLineSegmentDistance( px, py, pz, lx1, ly1, lz1, lx2, ly2, lz2 )
	local lineDistance = zo_distance3D( lx1, ly1, lz1, lx2, ly2, lz2 )

	if 0 == lineDistance then
		return zo_distance3D( px, py, pz, lx1, ly1, lz1 )
	end

	local t = ( ( px - lx1 ) * ( lx2 - lx1 ) + ( py - ly1 ) * ( ly2 - ly1 ) + ( pz - lz1 ) * ( lz2 - lz1 ) ) / lineDistance
	t = zo_clamp( t, 0, 1 )

	return zo_distance3D( px, py, pz, lx1 + t * ( lx2 - lx1 ), ly1 + t * ( ly2 - ly1 ), lz1 + t * ( lz2 - lz1 ) )
end

function EHT.World:GetMinPointLineSegmentDistance( ... )
	return GetMinPointLineSegmentDistance( ... )
end

function EHT.World:GetCircumference( radiusX, radiusY, arcPercent )
	radiusY = radiusY or radiusX
	arcPercent = arcPercent or 1

	local circum = math.pow( radiusX + radiusY, 2 ) * ( math.sqrt( -3 * ( math.pow( radiusX - radiusY, 2 ) / math.pow( radiusX + radiusY, 2 ) ) + 4 ) + 10 )
	circum = 3 * ( math.pow( radiusX - radiusY, 2 ) / circum ) + 1
	circum = math.pi * ( radiusX + radiusY ) * circum
	circum = circum * ( arcPercent / ( 2 * math.pi ) )
	return circum
end

function EHT.World:GetCircumferenceSegmentSize( numSegments, radiusX, radiusY, arcPercent )
	local circum = EHT.World:GetCircumference( radiusX, radiusY, arcPercent )
	local size = math.unnan( circum / numSegments )
	return size
end

function EHT.World:GetCircumferenceSegmentCount( segmentSize, radiusX, radiusY, arcPercent )
	local circum = EHT.World:GetCircumference( radiusX, radiusY, arcPercent )
	local count = math.unnan( circum / segmentSize )
	return count
end

function EHT.World:GetCameraControl()
	if CameraWindow then return CameraWindow.CameraControl end
end

function EHT.World:IsPointInside( x, y, z, minX, minY, minZ, maxX, maxY, maxZ )
	return	( x <= maxX and x >= minX ) and
			( y <= maxY and y >= minY ) and
			( z <= maxZ and z >= minZ )
end

function EHT.World:AreRegionsOverlapping( x1, y1, z1, x2, y2, z2, minX, minY, minZ, maxX, maxY, maxZ )
	return	( x1 <= maxX and x2 >= minX ) and
			( y1 <= maxY and y2 >= minY ) and
			( z1 <= maxZ and z2 >= minZ )
end

function EHT.World:IsPlayerInside( minX, minY, minZ, maxX, maxY, maxZ )
	return self:AreRegionsOverlapping( PlayerX - 20, PlayerY, PlayerZ - 20, PlayerX + 20, PlayerY + 200, PlayerZ + 20, minX, minY, minZ, maxX, maxY, maxZ )
end

function EHT.World:CrossProduct( ... )
	return CrossProduct( ... )
end

function EHT.World:DotProduct( ... )
	return DotProduct( ... )
end

local function GetMinPointLineDistance( x, y, z, x1, y1, z1, x2, y2, z2 )
	local v1, v2, v3 = x2 - x1, y2 - y1, z2 - z1
	local w1, w2, w3 = x - x1, y - y1, z - z1

	local c1 = v1 * w1 + v2 * w2 + v3 * w3
	local c2 = v1 * v1 + v2 * v2 + v3 * v3

	local b = c1 / c2
	local lp1, lp2, lp3 = x1 + b * v1, y1 + b * v2, z1 + b * v3

	return zo_distance3D( x, y, z, lp1, lp2, lp3 ), lp1, lp2, lp3
end

local function GetMinReticleDistance( x, y, z )
	return GetMinPointLineDistance( x, y, z, CameraX, CameraY, CameraZ, ReticleVectorX, ReticleVectorY, ReticleVectorZ )
end

function EHT.World:GetMinPointLineDistance( x, y, z, x1, y1, z1, x2, y2, z2 )
	return GetMinPointLineDistance( x, y, z, x1, y1, z1, x2, y2, z2 )
end

function EHT.World:GetMinReticleDistance( ... )
	return GetMinReticleDistance( ... )
end

local function GetLineDistances( x11, y11, z11, x12, y12, z12, x21, y21, z21, x22, y22, z22 )
	local u1, u2, u3 = x12 - x11, y12 - y11, z12 - z11
	local v1, v2, v3 = x22 - x21, y22 - y21, z22 - z21
	local w1, w2, w3 = x11 - x21, y11 - y21, z11 - z21

	local a = DotProduct( u1, u2, u3,	u1, u2, u3 )
	local b = DotProduct( u1, u2, u3,	v1, v2, v3 )
	local c = DotProduct( v1, v2, v3,	v1, v2, v3 )
	local d = DotProduct( u1, u2, u3,	w1, w2, w3 )
	local e = DotProduct( v1, v2, v3,	w1, w2, w3 )
	local den = a * c - b * b
	local sc, tc

	if den < 0.00001 then
		sc = 0
		if b > c then
			tc = d / b
		else
			tc = e / c
		end
	else
		sc = ( ( b * e ) - ( c * d ) ) / den
		tc = ( ( a * e ) - ( b * d ) ) / den
	end

	local ox1, oy1, oz1 = x12 - ( sc * u1 ), y12 - ( sc * u2 ), z12 - ( sc * u3 )
	local ox2, oy2, oz2 = x22 - ( tc * v1 ), y22 - ( tc * v2 ), z22 - ( tc * v3 )

	local dX = w1 + ( sc * u1 ) - ( tc * v1 )
	local dY = w2 + ( sc * u2 ) - ( tc * v2 )
	local dZ = w3 + ( sc * u3 ) - ( tc * v3 )

	return VectorLength( dX, dY, dZ ), sc, tc, ox1, oy1, oz1, ox2, oy2, oz2
end

function EHT.World:GetLineDistances( ... )
	return GetLineDistances( ... )
end

local function GetPointPlaneDistance( x, y, z, px1, py1, pz1, px2, py2, pz2, px3, py3, pz3 )
	local pnX = ( py2 - py1 ) * ( pz3 - pz1 ) - ( py3 - py1 ) * ( pz2 - pz1 )
	local pnY = ( pz2 - pz1 ) * ( px3 - px1 ) - ( pz3 - pz1 ) * ( px2 - px1 )
	local pnZ = ( px2 - px1 ) * ( py3 - py1 ) - ( px3 - px1 ) * ( py2 - py1 )
	pnX, pnY, pnZ = NormalVector( pnX, pnY, pnZ )
    --local sn = -DotProduct( pnX, pnY, pnZ, px1 - x, py1 - y, pz1 - z )
    --local sd = DotProduct( pnX, pnY, pnZ, pnX, pnY, pnZ )
    --local sb = sn / sd
	local sb = -DotProduct( pnX, pnY, pnZ, px1 - x, py1 - y, pz1 - z )
	local qx, qy, qz = x + sb * pnX, y + sb * pnY, z + sb * pnZ
    return zo_distance3D( x, y, z, qx, qy, qz ), qx, qy, qz
end

local function GetPlanarDrawDistance( centerX, centerY, centerZ, normalX, normalY, normalZ, radiusX, radiusY )
    local intersectDot = -DotProduct( normalX, normalY, normalZ, centerX - CameraX, centerY - CameraY, centerZ - CameraZ )
	return zo_distance3D( 0, 0, 0, intersectDot * normalX, intersectDot * normalY, intersectDot * normalZ )
end
--[[
local function GetFastBoundedPointPlaneDistance( x, y, z, pnX, pnY, pnZ, px1, py1, pz1, maxX, maxY, maxZ )
    local sb = -DotProduct( pnX, pnY, pnZ, px1 - x, py1 - y, pz1 - z )
	local qx, qy, qz = x + sb * pnX, y + sb * pnY, z + sb * pnZ
	local planarDistance = zo_distance3D( x, y, z, qx, qy, qz )
	local boundedDistance = zo_distance3D( x, y, z, px1, py1, pz1 ) + zo_distance3D( 0, 0, 0, maxX, maxY, maxZ )
    return math.max( planarDistance, boundedDistance )
end
]]
function EHT.World.GetPointPlaneDistance( ... )
	return GetPointPlaneDistance( ... )
end

function EHT.World:GetLinePlaneIntersection( l, p )
	local uX, uY, uZ = l.x2 - l.x1, l.y2 - l.y1, l.z2 - l.z1
	local wX, wY, wZ = l.x1 - p.x1, l.y1 - p.y1, l.z1 - p.z1

	local D = DotProduct( p.x2, p.y2, p.z2,		uX, uY, uZ )
	local N = -DotProduct( p.x2, p.y2, p.z2,	wX, wY, wZ )

	-- Line and Plane are parallel
	if math.abs( D ) < 0.0000001 then
		if 0 == N then
			-- Plane contains Line
			return l.x1, l.y1, l.z1
		else
			-- No intersection
			return nil
		end
	end

	local si = N / D
	if 0 > si or 1 < si then
		-- No intersection
		return nil
	end

	local iX, iY, iZ = l.x1 + ( si * uX ), l.y1 + ( si * uY ), l.z1 + ( si * uZ )
	return iX, iY, iZ
end

do
	local line, plane = { }, { }

	function EHT.World:GetReticlePlaneIntersection( px, py, pz, nx, ny, nz )
		line.x1, line.y1, line.z1, line.x2, line.y2, line.z2 = CameraX, CameraY, CameraZ, ReticleVectorX, ReticleVectorY, ReticleVectorZ
		plane.x1, plane.y1, plane.z1, plane.x2, plane.y2, plane.z2 = px, py, pz, nx, ny, nz
		return EHT.World:GetLinePlaneIntersection( line, plane )
	end
end

function EHT.World:Get3DPosition( x, y, z )
	return WorldPositionToGuiRender3DPosition( x, y, z )
end

function EHT.World:GetWorldPosition( x, y, z )
	return GuiRender3DPositionToWorldPosition( x, y, z )
end

function EHT.World:GetUIDimensions( worldX, worldY, worldZ, uiWidth, uiHeight )
	local depth = zo_distance3D( worldX, worldY, worldZ, CameraX, CameraY, CameraZ )
	local width, height = ( depth / DepthToUIWidth ) * uiWidth, ( depth / DepthToUIHeight ) * uiHeight
	return width, height
end

function EHT.World:GetUIIndicatorDimensions( worldX, worldY, worldZ, scaleModifier )
	local scale = (EHT.GetSetting("IndicatorScale") or 1) * (scaleModifier or 1)
	local dx = (worldX - CameraX) * CameraForwardX
	local dy = (worldY - CameraY) * CameraForwardY
	local dz = (worldZ - CameraZ) * CameraForwardZ
	local distance = zo_distance3D(0, 0, 0, dx, dy, dz)
	local frustumWidth, frustumHeight = GetWorldDimensionsOfViewFrustumAtDepth(distance)
	local width, height = 0.0004 * frustumWidth * scale, 0.0008 * frustumHeight * scale
	return width, height
end

function EHT.World.RotateAxisX( x, y, z, radians )
	local c, s = math.cos( radians ), math.sin( radians )
	return x	,	y * c - z * s	,	y * s + z * c
end

function EHT.World.RotateAxisY( x, y, z, radians )
	local c, s = math.cos( radians ), math.sin( radians )
	return z * s + x * c	,	y	,	z * c - x * s
end

function EHT.World.RotateAxisZ( x, y, z, radians )
	local c, s = math.cos( radians ), math.sin( radians )
	return x * c - y * s	,	x * s + y * c	,	z
end

function EHT.World.Rotate( x, y, z, radX, radY, radZ )
	x, y, z = EHT.World.RotateAxisZ( x, y, z, radZ )
	x, y, z = EHT.World.RotateAxisX( x, y, z, radX )
	x, y, z = EHT.World.RotateAxisY( x, y, z, radY )
	return x, y, z
end

function EHT.World.LocalRotate( x, y, z, centerX, centerY, centerZ, radX, radY, radZ )
	x, y, z = x - centerX, y - centerY, z - centerZ
	x, y, z = EHT.World.RotateAxisZ( x, y, z, radZ )
	x, y, z = EHT.World.RotateAxisX( x, y, z, radX )
	x, y, z = EHT.World.RotateAxisY( x, y, z, radY )
	x, y, z = centerX + x, centerY + y, centerZ + z
	return x, y, z
end

local function UpdateFrameData()
	FrameTime = GetFrameTimeMilliseconds() or 0
end
EVENT_MANAGER:RegisterForUpdate( "EHT.World.UpdateFrameData", 1, UpdateFrameData )

local function GetLinearInterval( cycleMS, offsetMS )
	if offsetMS then
		return ( ( FrameTime - offsetMS ) % cycleMS ) / cycleMS
	end
	return ( FrameTime % cycleMS ) / cycleMS
end

local function GetIntervalPeriod( cycleMS, offsetMS )
	if offsetMS then
		return math.floor( ( FrameTime - offsetMS ) / cycleMS )
	end
	return math.floor( FrameTime  / cycleMS )
end

function EHT.World:GetIntervalPeriod( cycle, offsetMS )
	return GetIntervalPeriod( cycle, offsetMS )
end

local function GetLoopInterval( cycleMS, offsetMS )
	if offsetMS then
		local normalized = ( ( FrameTime - offsetMS ) % cycleMS ) / cycleMS
		if normalized < 0.5 then
			return 2 * normalized
		end
		return 1 - 2 * ( normalized - 0.5 )
	end
	local normalized = ( FrameTime % cycleMS ) / cycleMS
	if normalized < 0.5 then
		return 2 * normalized
	end
	return 1 - 2 * ( normalized - 0.5 )
end

function EHT.World:GetLoopInterval( cycle, offsetMS )
	return GetLoopInterval( cycle, offsetMS )
end

local function GetEasedLoopInterval( cycleMS, offsetMS )
	if offsetMS then
		return Ease2( ( ( FrameTime - offsetMS ) % cycleMS ) / cycleMS )
	end
	return Ease2( ( FrameTime % cycleMS ) / cycleMS )
end

function EHT.World:GetEasedLoopInterval( cycle, offsetMS )
	return GetEasedLoopInterval( cycle, offsetMS )
end

local function GetEasedInterval( cycleMS, offsetMS )
	if offsetMS then
		return math.sin( 6.283185307 * ( ( ( FrameTime - offsetMS ) % cycleMS ) / cycleMS ) )
	end
	return math.sin( 6.283185307 * ( ( FrameTime % cycleMS ) / cycleMS ) )
end

local function GetSurface( index, surfacesX, surfacesY )
	index = index % ( surfacesX * surfacesY )
	local unitsX, unitsY = 1 / surfacesX, 1 / surfacesY
	local left, right, top, bottom = ( index * unitsX ) % 1, ( ( index + 1 ) * unitsX ) % 1, math.floor( index * unitsX ) * unitsY, ( math.floor( index * unitsX ) + 1 ) * unitsY
	return left, right < left and ( right + 1 ) or right, top, bottom < top and ( bottom + 1 ) or bottom
end

local function GetIntervalSurface( surfacesX, surfacesY, cycleMS, offsetMS )
	local totalSurfaces = surfacesX * surfacesY
	local interval = zo_ceil( zo_lerp( 0, totalSurfaces - 1, GetLinearInterval( cycleMS, offsetMS ) ) ) + 1
	return GetSurface( interval, surfacesX, surfacesY )
end

local function GetIntervalColor( baseR, rangeR, baseG, rangeG, baseB, rangeB, baseA, rangeA, interval, intervalOffset )
	local r, g, b, a, int
	int = GetEasedInterval( interval, intervalOffset )
	r, g, b, a = baseR + rangeR * int, baseG + rangeG * int, baseB + rangeB * int, baseA + rangeA * int
	return r, g, b, a
end

function EHT.World:GetLinearInterval( duration, offset )
	return GetLinearInterval( duration, offset )
end

function EHT.World:GetEasedInterval( duration, offset )
	return GetEasedInterval( duration, offset )
end

function EHT.World:GetSurfaceCoords( index, surfacesX, surfacesY )
	return GetSurface( index, surfacesX, surfacesY )
end

function EHT.World:GetIntervalSurfaceCoords( surfacesX, surfacesY, cycleMS, offsetMS )
	return GetIntervalSurface( surfacesX, surfacesY, cycleMS, offsetMS )
end

function EHT.World:GetDistanceAndAngleFromPlayer( x, y, z )
	local distance = zo_distance3D( PlayerX, PlayerY, PlayerZ, x, y, z )
	local angle = math.atan2( PlayerX - x, PlayerZ - z )
	local heading = ( CameraHeading - angle ) % math.rad( 360 )
	return distance, angle, heading
end

function EHT.World:GetDistanceAndAngleFromCamera( x, y, z )
	local distance = zo_distance3D( CameraX, CameraY, CameraZ, x, y, z )
	local angle = math.atan2( CameraX - x, CameraZ - z )
	local heading = ( CameraHeading - angle ) % math.rad( 360 )

	return distance, angle, heading
end

function EHT.World:GetReticleTargetEffect()
	local editor = EHT.GetEffectEditor()
	local buttons = editor.EditButtons

	if nil == buttons then return end

	local button, effect, effectButton
	local minDistance = MAX_RETICLE_DISTANCE
	local isEditing = editor:IsEditing()

	if isEditing then
		button = editor.EditingEffectMarker
		local eff = CurrentEditorEffect

		if button and eff then
			local x, y, z = EHT.World:GetWorldPosition( button:Get3DRenderSpaceOrigin() )
			local dimX, dimY = button:Get3DLocalDimensions()
			local reticleRadius = MAX_RETICLE_RADIUS * math.max( dimX, dimY )
			local distance = zo_distance3D( x, y, z, CameraX, CameraY, CameraZ )

			if GetMinReticleDistance( x, y, z ) <= reticleRadius then
				effect, minDistance, effectButton = eff, distance, editor.EditingEffectMarker
			end
		end
	else
		for index = 1, #buttons do
			button = buttons[index]
			if not button or not button.Effect then break end

			local x, y, z = self:GetWorldPosition( button:Get3DRenderSpaceOrigin() )
			local dimX, dimY = button:Get3DLocalDimensions()
			local reticleRadius = MAX_RETICLE_RADIUS * math.max( dimX, dimY )
			local distance = zo_distance3D( x, y, z, CameraX, CameraY, CameraZ )

			if distance < minDistance and GetMinReticleDistance( x, y, z ) <= reticleRadius then
				minDistance = distance
				effect = button.Effect
				effectButton = button
			end
		end
	end

	if effect then
		return effect, effectButton, minDistance
	end
end

---[ Event Handlers ]---

do
	local prevEffectLabel

	function EHT.Effect.FlashReticleTargetEffect()
		FLASH_RETICLE_TARGET_EFFECT_BUTTON = nil
		local cancel = false

		if not EHT.Housing.IsSelectionMode() then
			cancel = true
		elseif EHT.GetSetting("EditEffectButtonHidden") then
			if prevEffectLabel then
				prevEffectLabel = nil
				EHT.UI.HideInteractionPrompt()
			end
		else
			local effect
			effect, FLASH_RETICLE_TARGET_EFFECT_BUTTON = EHT.World:GetReticleTargetEffect()

			if not effect or EHT.GetEffectEditor():IsEditing() then
				if EHT.UI.GetInteractionPromptLabel() == prevEffectLabel then
					EHT.UI.HideInteractionPrompt()
					prevEffectLabel = nil
				end
			else
				prevEffectLabel = string.format( "|cffff33%s\n|c33ffffClick|cffffff to Edit\n|c33ffffClick|cffffff+|c33ffffHold|cffffff to Drag", effect:GetEffectType().Name )
				local RIGHT_ALIGN = true
				EHT.UI.ShowInteractionPrompt( nil, prevEffectLabel, nil, RIGHT_ALIGN )
			end
		end

		if cancel then
			EHT.UI.HideInteractionPrompt()
			EVENT_MANAGER:UnregisterForUpdate("EHT.FlashReticleTargetEffect")
			return
		end
	end
end

function EHT.Effect.RegisterFlashReticleTargetEffect()
	EVENT_MANAGER:RegisterForUpdate( "EHT.FlashReticleTargetEffect", 300, EHT.Effect.FlashReticleTargetEffect )
end

function EHT.Effect.UnregisterFlashReticleTargetEffect()
	--EVENT_MANAGER:UnregisterForUpdate( "EHT.FlashReticleTargetEffect" )
end

local function OnDragEffect()
	EVENT_MANAGER:UnregisterForUpdate( "EHT.OnDragEffect" )
	if not EHT.Housing.IsHouseZone() or not ReticleEffect or not ReticleEffectButton then return end
	EVENT_MANAGER:RegisterForUpdate( "EHT.OnDragEffect", RETICLE_EFFECT_CLICK_TO_DRAG_INTERVAL, OnDragEffect )

	local x, y, z = EHT.World:GetReticleVectorPoint( ReticleEffectDistance )
	if x then
		ReticleEffectButton:Set3DRenderSpaceOrigin( WorldPositionToGuiRender3DPosition( x, y, z ) )
		ReticleEffectButton:Set3DRenderSpaceOrientation( 0, CameraHeading, 0 )
	end
end

local function OnWorldMouseDown( event, button, isCtrl, isAlt, isShift, isCommand )
	ReticleEffect, ReticleEffectButton, ReticleEffectDistance, ReticleEffectTimer = nil, nil, 0, 0
	if 1 ~= button or IsReticleHidden() or EHT.GetSetting( "EditEffectButtonHidden" ) or ( not EHT.Housing.IsSelectionMode() and not EHT.Housing.IsPlacementMode() ) then
		return
	end

	local editor = EHT.GetEffectEditor()
	if nil == editor then return end
	if not editor:HasEditEffectPermission() then return end

	local buttons = editor.EditButtons
	if nil == buttons then return end

	if CheckedReticleEffectDuringPlacement then return end

	local isEditing = editor:IsEditing()
	local reticleRadius = MAX_RETICLE_RADIUS
	local minDistance = MAX_RETICLE_DISTANCE
	local effect, effectButton

	if isEditing then
		local button = editor.EditingEffectMarker
		local eff = CurrentEditorEffect

		if button and eff then
			local x, y, z = EHT.World:GetWorldPosition( button:Get3DRenderSpaceOrigin() )
			local dimX, dimY = button:Get3DLocalDimensions()
			local reticleRadius = MAX_RETICLE_RADIUS * math.max( dimX, dimY )
			local distance = zo_distance3D( x, y, z, CameraX, CameraY, CameraZ )

			if GetMinReticleDistance( x, y, z ) <= reticleRadius then
				effect, minDistance, effectButton = eff, distance, editor.EditingEffectMarker
			end
		end
	else
		for index = 1, #buttons do
			local button = buttons[index]
			if not button or not button.Effect then
				break
			end

			local x, y, z = EHT.World:GetWorldPosition( button:Get3DRenderSpaceOrigin() )
			local dimX, dimY = button:Get3DLocalDimensions()
			local reticleRadius = MAX_RETICLE_RADIUS * math.max( dimX, dimY )
			local distance = zo_distance3D( x, y, z, CameraX, CameraY, CameraZ )

			if distance < minDistance and GetMinReticleDistance( x, y, z ) <= reticleRadius then
				effect, minDistance, effectButton = button.Effect, distance, button

				if isEditing then
					effectButton:SetHidden( false )
					break
				end
			end
		end
	end

	if effect then
		-- Cancel any placement if an Effect edit button was closer to the reticle.
		local changeMode = false

		if EHT.Housing.IsPlacementMode() then
			local furnitureId = HousingEditorGetSelectedFurnitureId()
			if furnitureId and 0 ~= furnitureId then
				local x, y, z = EHT.Housing.GetFurnitureCenter( furnitureId )
				if x and 0 ~= x then
					local sizeX, sizeY, sizeZ = EHT.Housing.GetFurnitureLocalDimensions( furnitureId )
					local size = 0.5 * math.max( sizeX or 0, sizeY or 0, sizeZ or 0 )

					if size + zo_distance3D( x, y, z, CameraX, CameraY, CameraZ ) > minDistance then
						changeMode = true
					else
						CheckedReticleEffectDuringPlacement = true
						return
					end
				end
			end
		end

		if changeMode then
			HousingEditorRequestModeChange( HOUSING_EDITOR_MODE_SELECTION )
		end

		if EHT.Biz.CheckItemLock( effect:GetRecordId() ) then
			return
		end

		ReticleEffect, ReticleEffectButton, ReticleEffectDistance, ReticleEffectTimer = effect, effectButton, minDistance, FrameTime
		EVENT_MANAGER:RegisterForUpdate( "EHT.OnDragEffect", MIN_RETICLE_EFFECT_CLICK_TO_DRAG_DURATION, OnDragEffect )
	end
end

local function OnWorldMouseUp( event, button, isCtrl, isAlt, isShift, isCommand )
	if not ReticleEffect or not ReticleEffectButton then return end

	local editor = EHT.GetEffectEditor()
	local effect = ReticleEffect
	local button = ReticleEffectButton
	local duration = FrameTime - ( ReticleEffectTimer or 0 )

	if editor:IsEditing() then button:SetHidden( true ) end
	EHT.World:ResetReticleEffect()

	if duration < MIN_RETICLE_EFFECT_CLICK_TO_DRAG_DURATION then
		editor:BindToEffect( effect )
		editor:ShowEditor()
		return
	end

	local x, y, z = GuiRender3DPositionToWorldPosition( button:Get3DRenderSpaceOrigin() )
	effect:SetPosition( x, y, z )
	effect:Reset()
	effect:UpdateRecord( true )
	EHT.UI.PlaySoundEffectChanged()
end

function EHT.World.OnWorldChange()
	-- Reset 3D Render Spaces

	IsHouseZone = EHT.Housing.IsHouseZone()

	local win = GetParticleWindow()
	if nil ~= win then
		win:Destroy3DRenderSpace()
		win:Create3DRenderSpace()
	end

	win = EffectEditButtonsWindow
	if nil ~= win then
		win:Destroy3DRenderSpace()
		win:Create3DRenderSpace()
	end

	win = CameraWindow
	local cc
	if nil == win then
		win = WINDOW_MANAGER:CreateTopLevelWindow( "EHTCameraWin" )
		CameraWindow = win
		win:SetHidden( false )

		cc = WINDOW_MANAGER:CreateControl( "EHTCameraControl", win, CT_TEXTURE )
		cc:SetHidden( true )
		win.CameraControl = cc
	else
		cc = win.CameraControl
	end

	win:Destroy3DRenderSpace()
	win:Create3DRenderSpace()

	cc:Destroy3DRenderSpace()
	cc:Create3DRenderSpace()
	cc:Set3DLocalDimensions( 0.01, 0.01 )

	local reticleWindow = RETICLE.reticleTexture:GetOwningWindow()
	reticleWindow:SetDrawLayer( DL_OVERLAY )

	if IsHouseZone then
		EVENT_MANAGER:RegisterForUpdate( "EHT.World.OnUpdatePlayerCamera", 1, function() EHT.World:OnUpdatePlayerCamera() end )
	else
		EVENT_MANAGER:UnregisterForUpdate( "EHT.World.OnUpdatePlayerCamera" )
	end

	-- Click-to-Drag Effect Setup

	EHT.World:ResetReticleEffect()

	if IsHouseZone and EHT.GetEffectEditor():HasEditEffectPermission() then
		EVENT_MANAGER:RegisterForEvent( "EHT.World.OnMouseDown", EVENT_GLOBAL_MOUSE_DOWN, OnWorldMouseDown )
		EVENT_MANAGER:RegisterForEvent( "EHT.World.OnMouseUp", EVENT_GLOBAL_MOUSE_UP, OnWorldMouseUp )
	else
		EVENT_MANAGER:UnregisterForEvent( "EHT.World.OnMouseDown", EVENT_GLOBAL_MOUSE_DOWN )
		EVENT_MANAGER:UnregisterForEvent( "EHT.World.OnMouseUp", EVENT_GLOBAL_MOUSE_UP )
	end
end

do
	local pReticleVectorX, pReticleVectorY, pReticleVectorZ = 0, 0, 0
	local nextTamrielTimeTick = 0

	function EHT.World:OnUpdatePlayerCamera()
		IsEditModeActive = EHT.Housing.IsSelectionMode() or EHT.Housing.IsPlacementMode()
		ReticleVectorX, ReticleVectorY, ReticleVectorZ = pReticleVectorX, pReticleVectorY, pReticleVectorZ

		PlayerX, PlayerY, PlayerZ, PlayerHeading = GetPlayerWorldPositionInHouse()
		PlayerY = PlayerY + 100

		CameraHeading = GetPlayerCameraHeading() or 0
		CameraLastUpdate = FrameTime

		DepthToUIHeight = 100 * ComputeDepthAtWhichWorldHeightRendersAsUIHeight( 1, 1 )
		DepthToUIWidth = 100 * ComputeDepthAtWhichWorldWidthRendersAsUIWidth( 1, 1 )

		if CameraWindow and CameraWindow.CameraControl then
			Set3DRenderSpaceToCurrentCamera( "EHTCameraControl" )
			pReticleVectorX, pReticleVectorY, pReticleVectorZ = EHT.World:GetReticleVectorPoint()

			CameraX, CameraY, CameraZ = EHT.World:GetWorldPosition( CameraWindow.CameraControl:Get3DRenderSpaceOrigin() )
			CameraPitch, CameraYaw, CameraRoll = EHT.World:GetCameraOrientation()
			CameraNormalX, CameraNormalY, CameraNormalZ = EHT.World:GetCameraSurfaceNormal()
			CameraForwardX, CameraForwardY, CameraForwardZ = EHT.World:GetCameraForward()

			local normalX, normalY, normalZ = -CameraForwardX, -CameraForwardY, -CameraForwardZ
			local pitch = -math.asin( normalY )
			local yaw = math.atan2( normalX, normalZ )
			FaceCameraPitch, FaceCameraYaw, FaceCameraRoll = pitch, yaw, 0

			if ParticleWindow and not ParticleWindow:IsHidden() then
				for p in pairs( CameraFacingParticles ) do
					p:FaceCamera()
				end
			end
		else
			pReticleVectorX, pReticleVectorY, pReticleVectorZ = 0, 0, 0

			CameraX, CameraY, CameraZ = PlayerX, PlayerY, PlayerZ
			CameraNormalX, CameraNormalY, CameraNormalZ = 0, 0, 0
			FaceCameraPitch, FaceCameraYaw, FaceCameraRoll = 0, 0, 0
		end

		if nextTamrielTimeTick <= FrameTime then
			TamrielTime.Hour, TamrielTime.Minute, TamrielTime.Second = EHT.Util.GetInGameTime()
			nextTamrielTimeTick = FrameTime + 250
		end
	end
end

do
	local nextEffectIndex = 1
	local sampleMetricsCallback
	local sampleMetrics = false
	local nextSettingsCheckMS = 0
	
	function EHT.World.SampleFXMetrics(callback)
		sampleMetricsCallback = callback
		sampleMetrics = true
	end

	function EHT.World.OnUpdateEffects()
		if not EHT.Housing.IsHouseZone() then
			EHT.Effect:UnregisterOnUpdate()
			return
		end

		if ParticleWindow and "table" == type( EffectList ) and EHT.ParticleEmitter and EHT.Metrics then
			EHT.ParticleEmitter:UpdateStatistics()

			local startTime = GetGameTimeMilliseconds()
			local samples

			if sampleMetrics then
				samples = {}

				local effects = {}
				for index = 1, #EffectList do
					local effect = EffectList[index]
					if effect and effect.Active and not effect.Deleted and effect.EffectType.Update and not effect:IsHidden() then
						table.insert( effects, effect )
					end
				end
				table.sort( effects, function( left, right )
					return left:GetEffectTypeIndex() < right:GetEffectTypeIndex()
				end )

				local effectTypeName
				local effectTypeCount = 0
				local effectTypeStartTime = 0

				for index = 1, #effects do
					local effect = effects[index]

					if effectTypeName ~= effect.EffectType:GetName() then
						if effectTypeName then
							local totalEffectTime = GetGameTimeMilliseconds() - effectTypeStartTime
							if totalEffectTime > 0 then
								local effectTime = totalEffectTime / effectTypeCount
								table.insert( samples, { effectTypeName, totalEffectTime, effectTime, effectTypeCount } )
							end
						end

						effectTypeName = effect.EffectType:GetName()
						effectTypeCount = 1
						effectTypeStartTime = GetGameTimeMilliseconds()
					else
						effectTypeCount = effectTypeCount + 1
					end

					effect.EffectType.Update( effect )
				end

				if effectTypeName then
					local totalEffectTime = GetGameTimeMilliseconds() - effectTypeStartTime
					local effectTime = totalEffectTime / effectTypeCount
					table.insert( samples, { effectTypeName, totalEffectTime, effectTime, effectTypeCount } )
				end
			else
				local hasActiveEffects = false
				local numEffects = #EffectList
				if numEffects > 0 then
					if nextEffectIndex > numEffects then
						nextEffectIndex = 1
					end

					local maxTime = startTime + MAX_UPDATE_EFFECTS_DURATION

					while nextEffectIndex <= numEffects and GetGameTimeMilliseconds() <= maxTime do
						local effect = EffectList[nextEffectIndex]
						nextEffectIndex = nextEffectIndex + 1
						if effect then
							if effect.Active and not effect.Deleted and effect.EffectType then
								hasActiveEffects = true
								if effect.EffectType.Update and not effect:IsHidden() then
									effect.EffectType.Update(effect)
								end
							end
						else
							break
						end
					end
				end
				
				if hasActiveEffects then
					if nextSettingsCheckMS < startTime then
						nextSettingsCheckMS = startTime + 8000
						EHT.Effect:CheckEffectsRelatedSettings()
					end
				else
					EHT.Effect:UnregisterOnUpdate()
				end
			end

			local endTime = GetGameTimeMilliseconds()
			EHT.EffectUpdateCostMS = EHT.EffectUpdateCostMS + endTime - startTime
			EHT.Metrics:SetValue( "Particle Animation", endTime - startTime )

			if sampleMetrics then
				sampleMetrics = false
				EHT.Metrics.FXSamples = samples

				if sampleMetricsCallback then
					sampleMetricsCallback(samples)
				end
			end

			ParticleWindow:SetHidden( false )
		end
	end
end

do
	local pX, pY, pZ, pPitch, pYaw, pRoll
	local cameraChanged, effectIndex = true, 0
	local nextEffectButtonUpdate = 0

	function EHT.World.OnReorderParticles()
		if not EHT.Housing.IsHouseZone() then
			EHT.Effect:UnregisterOnReorderParticles()
			return
		end

		local startTime = GetGameTimeMilliseconds()
		local maxTime = startTime + MAX_REORDER_PARTICLES_DURATION

		if 0 == effectIndex then
			local cX, cY, cZ = CameraX, CameraY, CameraZ
			local cPitch, cYaw, cRoll = EHT.World:GetCameraForward()

			cameraChanged = cX ~= pX or cY ~= pY or cZ ~= pZ or cPitch ~= pPitch or cYaw ~= pYaw or cRoll ~= pRoll
			pX, pY, pZ, pPitch, pYaw, pRoll = cX, cY, cZ, cPitch, cYaw, cRoll
		end

		local effects = EHT.Effect:GetAll()
		local numEffects = #effects

		-- Calculate the Draw Level Offsets for all Effects' Particles
		-- and cache the result for each.
		-- Time-slice this batch calculation to mitigate FPS impact.

		while effectIndex < numEffects do
			effectIndex = effectIndex + 1
			local e = effects[effectIndex]

			if e and e.Active then
				e.MaxDrawLevel = nil
				for _, p in ipairs( e.Particles ) do
					p:AutoUpdateDrawLevel( cameraChanged, false )
				end

				if GetGameTimeMilliseconds() >= maxTime then
					break
				end
			end
		end

		if effectIndex >= numEffects then
			effectIndex = 0

			if not ReticleEffect and nextEffectButtonUpdate < startTime then
				nextEffectButtonUpdate = GetGameTimeMilliseconds() + 200
				EHT.GetEffectEditor():UpdateEditButtons()
			end
		end

		local endTime = GetGameTimeMilliseconds()
		EHT.Metrics:SetValue( "Z-Depth Order", endTime - startTime )
	end
end

function EHT.Effect.DumpFXMetrics( param )
	EHT.World.SampleFXMetrics( function() EHT.Effect.DumpFXMetricsData( param ) end )
end

function EHT.Effect.DumpFXMetricsData( param )
	local effects = EHT.Effect:GetAll()
	local particles = EHT.Particle:GetAll()
	local activeParticles, inactiveParticles = #particles, #EHT.Particle:GetInactive()
	local totalParticles = activeParticles + inactiveParticles
	local animatedEffects, reorderEffects = 0, 0
	local activeEffects = #effects

	for index, effect in ipairs( effects ) do
		if effect.EffectType.Update then animatedEffects = animatedEffects + 1 end
		if effect:GetAutoDrawLevelEnabled() then reorderEffects = reorderEffects + 1 end
	end

	d( "- FX Metrics -" )
	d( "|c000000." )

	d( "-Effects-" )
	df( "Active: %d\nAnimated: %d\nZ-Depth Order:\n - Managed: %d\n - Unmanaged: %d\n", activeEffects, animatedEffects, reorderEffects, activeEffects - reorderEffects )
	d( "|c000000." )

	d( "-Particles-" )
	df( "Total: %d\n - Active: %d\n - Inactive: %d", totalParticles or 0, activeParticles or 0, inactiveParticles or 0 )
	d( "|c000000." )

	d( "-Batch Intervals-" )
	df( "Particle Animation: %.1fms\nZ-Depth Order: %.1fms", UPDATE_EFFECTS_INTERVAL, REORDER_PARTICLES_INTERVAL )
	d( "|c000000." )

	d( "-Object Lifecycle-" )
	df( "Effects Instantiated:\n - Total:%d\nParticles Instantiated:\n - Total: %d\n - Recycled: %d", EHT.TotalEffectsInstantiated, EHT.TotalParticlesInstantiated, EHT.TotalParticlesRecycled )
	d( "|c000000." )

	EHT.Metrics:Dump()
	d( "|c000000." )

	if param and string.sub( string.lower( param ), 1, 1 ) == "d" then
		local samples = EHT.Metrics.FXSamples
		if not samples or #samples == 0 then
			d( "No high cost FX samples available." )
		else
			table.sort( samples, function( sampleA, sampleB ) return sampleA[3] > sampleB[3] or ( sampleA[3] == sampleB[3] and sampleA[1] < sampleB[1] ) end )
			d( "FX Samples (Highest Cost)" )
			for index = 1, 20 do
				local sample = samples[index]
				if not sample then
					break
				end
				local effectName, totalEffectTime, effectTime, effectCount = sample[1], sample[2], sample[3], sample[4]
				df( "%.2fms x%d (%dms total) %s", effectTime, effectCount, totalEffectTime, effectName )
			end
		end
	else
		d( "\n|cffffffUse |c00ffff/fxmetrics d|cffffff for FX details." )
	end
end

---[ Class : EffectFurnitureStateManager ]---

local EffectFurnitureStateManager = ZO_Object:Subclass()

function EffectFurnitureStateManager:New()
	local obj = ZO_Object.New( self )
	obj:Reset()
	return obj
end

function EffectFurnitureStateManager:Reset()
	self.Handlers = { }
end

function EffectFurnitureStateManager:RegisterHandler( id, effect )
	id = string.fromId64( id )
	if not id then
		return false
	end

	local handlers = self.Handlers[ id ]
	if not handlers then
		handlers = { }
		self.Handlers[ id ] = handlers
	end

	if not EHT.Util.IsListValue( handlers, effect ) then
		table.insert( handlers, effect )
		return true
	end

	return false
end

function EffectFurnitureStateManager:UnregisterHandler( id, effect )
	id = string.fromId64( id )
	if not id then
		return false
	end

	local handlers = self.Handlers[ id ]
	if not handlers then
		return false
	end

	for index, handler in ipairs( handlers ) do
		if effect == handler then
			table.remove( handlers, index )
			return true
		end
	end

	return false
end

function EffectFurnitureStateManager:UnregisterHandlers( id )
	id = string.fromId64( id )
	if not id then
		return
	end

	self.Handlers[ id ] = nil
end

function EffectFurnitureStateManager:OnFurnitureStateChanged( id, newState, oldState )
	id = string.fromId64( id )
	if not id then
		return false
	end

	local handlers = self.Handlers[ id ]
	if not handlers then
		return false
	end

	local numHandlers = #handlers
	for index = numHandlers, 1, -1 do
		local effect = handlers[ index ]
		if effect and effect.Active and not effect.Deleted then
			effect.EffectType.OnFurnitureStateChanged( effect, id, newState, oldState )
		else
			-- Handler is no longer valid.
			table.remove( handlers, index )
		end
	end
end

EHT.EffectFurnitureStateManager = EffectFurnitureStateManager:New()

---[ Class : EffectLerp ]---

do
	EHT.EffectLerp.Queue = { }

	local function IsValidEffect( effect )
		return effect and effect.Active and not effect.Deleted and effect.Particles
	end

	function EHT.EffectLerp:Get( effect, key )
		if not effect or not key then
			return
		end

		local keys = self.Queue[effect]

		if keys then
			for k, lerp in pairs( keys ) do
				if key == k then
					return lerp
				end
			end
		end

		return nil
	end

	function EHT.EffectLerp:Add( effect, key )
		if not effect or not key then
			return
		end

		local keys = self.Queue[effect]

		if not keys then
			keys = { }
			self.Queue[effect] = keys
		end
		keys[key] = self

		self:RegisterUpdate()
	end

	function EHT.EffectLerp:Delete( effect, key )
		if not effect or not key then
			return
		end

		local keys = self.Queue[effect]

		if keys then
			local active = 0

			for k, lerp in pairs( keys ) do
				if k == key then
					keys[k] = nil
					break
				else
					active = active + 1
				end
			end

			if 0 == active then
				self.Queue[effect] = nil
			end
		end
	end

	function EHT.EffectLerp:New( effect, key, ... )
		if not key or not IsValidEffect( effect ) then
			return
		end

		local obj = ZO_Object.New( self )
		return obj:Initialize( effect, key, ... )
	end

	function EHT.EffectLerp:Initialize( effect, key, interval, lerp, final )
		local ft = FrameTime

		self.Effect = effect
		self.Key = key
		self.Interval = interval
		self.Lerp = lerp
		self.Final = final

		local existing = self:Get( effect, key )
		if existing then
			local delta = self.Interval - zo_clamp( ft - existing.StartTime, 0, self.Interval )
			self.StartTime = ft - delta
			self.EndTime = ft + self.Interval - delta
		else
			self.StartTime = ft
			self.EndTime = ft + self.Interval
		end
		self:Add( effect, key )

		return self
	end

	local function Update()
		self = EHT.EffectLerp

		local ft = FrameTime
		local active = 0

		for effect, keys in pairs( self.Queue ) do
			if not IsValidEffect( effect ) then
				self.Queue[effect] = nil
			else
				for key, action in pairs( keys ) do
					local lerp = ZO_EaseInCubic( zo_clamp( ( ft - action.StartTime ) / ( action.EndTime - action.StartTime ), 0, 1 ) )
					action.Lerp( effect, key, lerp )

					if 1 <= lerp then
						if action.Final then
							action.Final( effect, key, lerp )
						end
						self:Delete( effect, key )
					else
						active = active + 1
					end
				end
			end
		end

		if 0 == active then
			self:UnregisterUpdate()
		end
	end

	function EHT.EffectLerp:RegisterUpdate()
		EVENT_MANAGER:RegisterForUpdate( "EHT.EffectLerp.Update", 30, Update )
	end

	function EHT.EffectLerp:UnregisterUpdate()
		EVENT_MANAGER:UnregisterForUpdate( "EHT.EffectLerp.Update" )
	end
end

---[ Class : Animation ]---
--[[
EHT.Animation = ZO_Object:Subclass()

function EHT.Animation:New( ... )
	local obj = ZO_Object.New( self )
	obj:Initialize( ... )
	return obj
end

function EHT.Animation:Initialize( control, options, ... )
	self.Control = control
	self.Options = options

	assert( "userdata" == type( self.Control ), "'Control' must be a valid control reference." )
	assert( "table" == type( self.Options ), "'Options' must be of type 'table'." )

	if self.OnInitialize then
		self.OnInitialize( ... )
	end
end

function EHT.Animation:GetControl()
	return self.Control
end

function EHT.Animation:GetOptions()
	return self.Options
end

EHT.FabricAnimation = EHT.Animation:Subclass()

function EHT.FabricAnimation:OnInitialize()
	local options = self.Options
end

function EHT.FabricAnimation:OnUpdate()
	local i1 = GetEasedInterval( 6000 )
	local i2 = GetEasedInterval( 6000, 1500 )
	icon:SetSampleProcessing( 2 - 0.5 * i2 )

	local x1, x2 = self.IconTC[1], self.IconTC[2]
	local uv1, uv2, uv3, uv4 = 0.06 * i1, 0.06 * i2, 0.06 * i1, 0.06 * i2
	local tex = icon.Texture
	tex:SetVertexUV( 1, x1 + uv1, x1 - uv3 )
	tex:SetVertexUV( 2, x2 + uv2, x1 - uv4 )
	tex:SetVertexUV( 4, x1 + uv1, x2 + uv3 )
	tex:SetVertexUV( 8, x2 + uv2, x2 + uv4 )
end
]]
---[ Class : Particle ]---

function EHT.Particle:GetAll()
	return ParticleList
end

function EHT.Particle:GetInactive()
	return InactiveParticleList
end

function EHT.Particle:GetWindow()
	return ParticleWindow
end

function EHT.Particle:New( ... )
	local particleIndex
	local obj = table.remove( InactiveParticleList, 1 )

	if obj then
		table.insert( ParticleList, obj )
		NumParticles = #ParticleList
		particleIndex = NumParticles

		-- Clear previous particle values.
		for key, value in pairs( obj ) do
			if "function" ~= type( value ) and "Texture" ~= key then
				obj[key] = nil
			end
		end

		EHT.TotalParticlesRecycled = EHT.TotalParticlesRecycled + 1
	end

	if not particleIndex then
		obj = ZO_Object.New( self )
		table.insert( ParticleList, obj )
		NumParticles = #ParticleList
		particleIndex = NumParticles
	end
	
	EHT.TotalParticlesInstantiated = EHT.TotalParticlesInstantiated + 1
	obj.Index = particleIndex
	obj:Initialize( ... )

	return obj
end

function EHT.Particle:Initialize( effect, textureFile )
	self.EffIndex, self.Active, self.Effect, self.Hidden, self.Dirty = 1, true, effect, false, true
	self.X, self.Y, self.Z, self.Pitch, self.Yaw, self.Roll = 0, 0, 0, 0, 0, 0
	self.SizeX, self.SizeY = 100, 100
	self.ColorR, self.ColorG, self.ColorB, self.Alpha = 1, 1, 1, 1
	self.OffsetX, self.OffsetY, self.OffsetZ = 0, 0, 0
	self.OffsetPitch, self.OffsetYaw, self.OffsetRoll = 0, 0, 0
	self.OffsetR, self.OffsetG, self.OffsetB, self.OffsetA = 1, 1, 1, 1
	self.OffsetSizeX, self.OffsetSizeY, self.OffsetSizeZ = 1, 1, 1
	self.ScaleX, self.ScaleY, self.ScaleOffsetX, self.ScaleOffsetY = 1, 1, 0, 0
	self.TCLeft, self.TCRight, self.TCTop, self.TCBottom = 0, 1, 0, 1
	self.VelocityY, self.DriftX, self.DriftZ, self.Expires = nil, nil, nil, nil
	self.TileX1, self.TileX2, self.TileY1, self.TileY2 = nil, nil, nil, nil
	self.VertexX1, self.VertexY1, self.VertexZ1 = 0, 0, 0
	self.VertexX2, self.VertexY2, self.VertexZ2 = 0, 0, 0
	self.VertexX3, self.VertexY3, self.VertexZ3 = 0, 0, 0
	self.VertexX4, self.VertexY4, self.VertexZ4 = 0, 0, 0
	self.SampleRGB, self.SampleAlpha = 1, 0
	self.Alpha, self.Desaturation = 1, 0
	self.AutoDrawLevelEnabled, self.DrawLevelOffset = nil, 0
	self.AutoColorEnabled, self.AutoSizeEnabled, self.AutoPositionEnabled = true, true, true
	self.CameraFacing = false

	local win = GetParticleWindow()

	local tex = self.Texture
	if nil == tex then
		tex = WINDOW_MANAGER:CreateControl( nil, win, CT_TEXTURE )
		self.Texture = tex
		tex:SetTextureReleaseOption( RELEASE_TEXTURE_AT_ZERO_REFERENCES )
		tex:SetHandler( "OnTextureLoaded", function() self.LoadingTexture = false end )
		tex.BaseSetVertexColors = tex.SetVertexColors
		tex.SetVertexColors = function( self, ... )
			if self.Particle then self.Particle:SetVertexColors( ... ) end
		end
	end

	tex.Particle = self
	self.VertexColors = nil
	tex:SetHidden( true )
	self:SetTextureFile( "" )
	self:SetTextureFile( textureFile )
	tex:ClearAnchors()
	tex:SetAnchor( CENTER, win, CENTER, 0, 0 )
	tex:SetAddressMode( TEX_MODE_CLAMP )
	tex:SetBlendMode( TEX_BLEND_MODE_ALPHA )
	tex:SetVertexColors( 1 + 2 + 4 + 8 )
	tex:SetColor( 1, 1, 1, 1 )
	tex:SetDesaturation( 0 )
	self:SetDrawLevel( 0 )
	self:SetOrientation( 0, 0, 0 )
	self:SetTextureCoords( 0, 1, 0, 1 )
	self:SetSampleProcessing( 1, 0 )
	if not tex:Has3DRenderSpace() then tex:Create3DRenderSpace() end
	tex:Set3DLocalDimensions( 1, 1 )
	tex:Set3DRenderSpaceUsesDepthBuffer( true )
end
--[[
function EHT.Particle:New( ... )
	return self:Initialize( ... )
end

function EHT.Particle:Initialize( effect, textureFile )
	local particleIndex
	local inactiveParticle = table.remove( InactiveParticleList, 1 )

	if inactiveParticle then
		self = inactiveParticle
		table.insert( ParticleList, self )
		NumParticles = #ParticleList
		particleIndex = NumParticles

		-- Clear previous particle values.
		for key, value in pairs( self ) do
			if "function" ~= type( value ) and "Texture" ~= key then
				self[key] = nil
			end
		end
	end

	if not particleIndex then
		self = ZO_Object.New( self )
		table.insert( ParticleList, self )
		NumParticles = #ParticleList
		particleIndex = NumParticles
	end

	self.Index, self.EffIndex, self.Active, self.Effect, self.Hidden = particleIndex, 1, true, effect, false
	self.X, self.Y, self.Z, self.Pitch, self.Yaw, self.Roll = 0, 0, 0, 0, 0, 0
	self.SizeX, self.SizeY = 100, 100
	self.ColorR, self.ColorG, self.ColorB, self.Alpha = 1, 1, 1, 1
	self.OffsetX, self.OffsetY, self.OffsetZ = 0, 0, 0
	self.OffsetPitch, self.OffsetYaw, self.OffsetRoll = 0, 0, 0
	self.OffsetR, self.OffsetG, self.OffsetB, self.OffsetA = 1, 1, 1, 1
	self.OffsetSizeX, self.OffsetSizeY, self.OffsetSizeZ = 1, 1, 1
	self.ScaleX, self.ScaleY, self.ScaleOffsetX, self.ScaleOffsetY = 1, 1, 0, 0
	self.TCLeft, self.TCRight, self.TCTop, self.TCBottom = 0, 1, 0, 1
	self.VelocityY, self.DriftX, self.DriftZ, self.Expires = nil, nil, nil, nil
	self.TileX1, self.TileX2, self.TileY1, self.TileY2 = nil, nil, nil, nil
	self.SampleRGB, self.SampleAlpha = 1, 0
	self.Alpha, self.Desaturation = 1, 0
	self.AutoDrawLevelEnabled, self.DrawLevelOffset = nil, 0
	self.AutoColorEnabled, self.AutoSizeEnabled = true, true
	self.CameraFacing = false

	local win = ParticleWindow
	if nil == win then
		win = WINDOW_MANAGER:CreateTopLevelWindow( PARTICLE_PREFIX )
		ParticleWindow = win
		win:SetHidden( false )
		win:SetDimensions( 1, 1 )
		win:SetMovable( true )
		win:SetMouseEnabled( false )
		win:SetClampedToScreen( false )
		win:SetAnchor( TOPLEFT, GuiRoot, TOPLEFT, -10, -10 )
		win:Create3DRenderSpace()
		win:SetDrawLayer( DL_BACKGROUND )
		win:SetDrawTier( DT_LOW )
	end

	local tex = self.Texture
	if nil == tex then
		tex = WINDOW_MANAGER:CreateControl( nil, win, CT_TEXTURE )
		self.Texture = tex
		tex:SetTextureReleaseOption( RELEASE_TEXTURE_AT_ZERO_REFERENCES )
		tex:SetHandler( "OnTextureLoaded", function() self.LoadingTexture = false end )
		tex.BaseSetVertexColors = tex.SetVertexColors
		tex.SetVertexColors = function( self, ... )
			if self.Particle then self.Particle:SetVertexColors( ... ) end
		end
	end

	tex.Particle = self
	self.VertexColors = nil
	tex:SetHidden( true )
	self:SetTextureFile( textureFile )
	tex:ClearAnchors()
	tex:SetAnchor( CENTER, win, CENTER, 0, 0 )
	tex:SetAddressMode( TEX_MODE_CLAMP )
	tex:SetBlendMode( TEX_BLEND_MODE_ALPHA )
	tex:SetVertexColors( 1 + 2 + 4 + 8 )
	tex:SetColor( 1, 1, 1, 1 )
	tex:SetDesaturation( 0 )
	self:SetDrawLevel( 0 )
	self:SetOrientation( 0, 0, 0 )
	self:SetTextureCoords( 0, 1, 0, 1 )
	self:SetSampleProcessing( 1, 0 )
	if not tex:Has3DRenderSpace() then tex:Create3DRenderSpace() end
	tex:Set3DLocalDimensions( 1, 1 )
	tex:Set3DRenderSpaceUsesDepthBuffer( true )

	return self
end
]]
function EHT.Particle:CopyFrom( p )
	if not p then return end
	self:SetPosition( p:GetPosition() )
	self:SetOrientation( p:GetOrientation() )
	self:SetSize( p:GetSize() )
	self:SetColor( p:GetColor() )
	self:SetTextureFile( p:GetTextureFile() )
	self:SetTextureWrapping( p:GetTextureWrapping() )
	self:SetDrawLevel( p:GetDrawLevel() )
	if p:GetAdditive() then
		self:SetAdditive( true )
	elseif p:GetDodge() then
		self:SetDodge( true )
	else
		self:SetAdditive( false )
	end
	self:SetHidden( p:GetHidden() )
	self:SetSizeOffsets( p:GetSizeOffsets() )
	self:SetColorOffsets( p:GetColorOffsets() )
	self:SetDesaturation( p:GetDesaturation() )
	self:SetSampleProcessing( p:GetSampleProcessing() )
	self:SetScale( p:GetScale() )
	self:SetScaleOffsets( p:GetScaleOffsets() )
	self:SetTextureCoords( p:GetTextureCoords() )
	self:SetPositionAndOrientation( p:GetPositionAndOrientation() )
	self:SetPositionOffsets( p:GetPositionOffsets() )
	self:SetOrientationOffsets( p:GetOrientationOffsets() )
	self.AutoDrawLevelEnabled, self.AutoColorEnabled, self.AutoPositionEnabled = p.AutoDrawLevelEnabled, p.AutoColorEnabled, p.AutoPositionEnabled
	self.VertexColors = p.VertexColors
end

function EHT.Particle:Delete(fastDeletion)
	self.Active = false
	CameraFacingParticles[self] = nil

	if self.Texture then
		self.Texture:SetHidden(true)
		self.Texture:SetTexture(TEXTURES.TRANSPARENT)
	end

	for index, particle in ipairs(ParticleList) do
		if particle == self then
			table.remove(ParticleList, index)
			table.insert(InactiveParticleList, self)
			NumParticles = NumParticles - 1
			break
		end
	end

	if true ~= fastDeletion then
		local effect = self.Effect
		if effect then
			local particleIndex = nil
			for index, particle in ipairs(effect.Particles) do
				if particle == self then
					table.remove(effect.Particles, index)
					particleIndex = index
					break
				end
			end

			local numParticles = #effect.Particles
			for index = particleIndex, numParticles do
				local particle = effect.Particles[index]
				particle.EffIndex = index
			end
		end
	end
end

function EHT.Particle:GetHidden()
	return self.Hidden
end

function EHT.Particle:SetHidden( hidden )
	if nil ~= hidden then
		self.Hidden = hidden
	end
	self.Texture:SetHidden( self.Hidden or self.Effect:IsHidden() or HideAllEffectsFlag )
end

function EHT.Particle:RefreshHidden()
	self:SetHidden()
end

function EHT.Particle:GetTextureFile()
	return self.Texture:GetTextureFileName()
end

function EHT.Particle:IsTextureLoaded()
	return true ~= self.LoadingTexture
end

function EHT.Particle:SetIsTextureLoaded( value )
	self.LoadingTexture = not value
end

function EHT.Particle:SetTextureFile( textureFile )
	self:SetIsTextureLoaded( false )
	self.Texture:SetTexture( textureFile )
end

function EHT.Particle:GetSampleProcessing()
	return self.SampleRGB, self.SampleAlpha
end

function EHT.Particle:SetSampleProcessing( rgb, alpha )
	self.SampleRGB, self.SampleAlpha = rgb or self.SampleRGB or 1, alpha or self.SampleAlpha or 0
	self.Texture:SetTextureSampleProcessingWeight( TEX_SAMPLE_PROCESSING_RGB, self.SampleRGB * self.Effect:GetContrast() )
	self.Texture:SetTextureSampleProcessingWeight( TEX_SAMPLE_PROCESSING_ALPHA_AS_RGB, self.SampleAlpha )
end

function EHT.Particle:SetAutoPositionEnabled( enabled )
	self.AutoPositionEnabled = enabled
end

function EHT.Particle:GetAutoPositionEnabled()
	return self.AutoPositionEnabled ~= false
end

function EHT.Particle:SetAutoColorEnabled( enabled )
	self.AutoColorEnabled = enabled
end

function EHT.Particle:GetAutoColorEnabled()
	return self.AutoColorEnabled
end

-- Deprecated
function EHT.Particle:GetViewingAngle()
	local _, viewAngle = EHT.World:GetDistanceAndAngleFromPlayer( CameraX, CameraY, CameraZ )
	local _, yaw = self:GetOrientation()
	return ( viewAngle - yaw ) % RAD180
end

function EHT.Particle:GetViewingAngleAlpha()
	return ZO_EaseInQuartic( 2 * math.abs( self:GetCameraNormal() ) )
end

function EHT.Particle:GetDrawLevel()
	return self.DrawLevelOffset or 0
end

function EHT.Particle:SetDrawLevel( offset )
	self.DrawLevelOffset = offset or self.DrawLevelOffset or 0
	self.Texture:SetDrawLevel( DRAW_LEVEL_EFFECTS + self.DrawLevelOffset )
end

function EHT.Particle:SetAutoDrawLevelEnabled( enabled )
	self.AutoDrawLevelEnabled = enabled
end

function EHT.Particle:AutoUpdateDrawLevel( cameraChanged, cacheOnly )
	if false ~= self.AutoDrawLevelEnabled and false ~= self.Effect.AutoDrawLevelEnabled then
		if not (cameraChanged or self.Dirty) then
			return false
		end

		local minDistance = 0
		if self.X and self.SizeX then
			if self.CameraFacing then
				minDistance = zo_distance3D( CameraX, CameraY, CameraZ, self.X, self.Y, self.Z )
				self.Dirty = false
			else
				if self.Dirty and self.Texture then
					local px1, py1, pz1 = self.X, self.Y, self.Z
					local px2, py2, pz2 = GuiRender3DPositionToWorldPosition( self.Texture:Convert3DLocalPositionToWorldPosition( self.SizeX / 200, 0, 0 ) )
					local px3, py3, pz3 = GuiRender3DPositionToWorldPosition( self.Texture:Convert3DLocalPositionToWorldPosition( 0, self.SizeY / 200, 0 ) )
					local pnX = ( py2 - py1 ) * ( pz3 - pz1 ) - ( py3 - py1 ) * ( pz2 - pz1 )
					local pnY = ( pz2 - pz1 ) * ( px3 - px1 ) - ( pz3 - pz1 ) * ( px2 - px1 )
					local pnZ = ( px2 - px1 ) * ( py3 - py1 ) - ( px3 - px1 ) * ( py2 - py1 )
					self.planeX, self.planeY, self.planeZ = NormalVector( pnX, pnY, pnZ )
					self.Dirty = false
				end

				if self.planeX then
					minDistance = GetPlanarDrawDistance( self.X, self.Y, self.Z, self.planeX, self.planeY, self.planeZ, 0.5 * self.SizeX, 0.5 * self.SizeY )
				end
			end
		end

		local distance = zo_clamp( 200000 - minDistance + ( self.EffIndex or 0 ), 1, 200000 )
		if 1 < self.EffIndex then
			if self.PredecessorRelativeDrawLevel or self.Effect.EffectType.OrderDrawLevelByIndex then
				local pred = self.Effect.Particles[self.EffIndex - 1]
				if pred then
					local predLevel = pred:GetDrawLevel()
					if predLevel >= distance then
						distance = predLevel + ( self.Effect.EffectType.ReverseOrderDrawLevel and -1 or 1 )
					end
				end
			end
		end

		if cacheOnly then
			self.DrawLevelOffset = distance
		else
			self:SetDrawLevel( distance )
		end

		return true
	end

	return nil
end

function EHT.Particle:CanModifyColor()
	return false ~= self.AllowColorModifier
end

function EHT.Particle:SetCanModifyColor( enabled )
	self.AllowColorModifier = false ~= enabled
end

function EHT.Particle:GetAutoSizeEnabled()
	return self.AutoSizeEnabled
end

function EHT.Particle:SetAutoSizeEnabled( enabled )
	self.AutoSizeEnabled = enabled
end

function EHT.Particle:GetSize()
	local x, y = self.Texture:Get3DLocalDimensions()
	return 100 * x, 100 * y
end

function EHT.Particle:SetSize(x, y)
	if x or y then
		self.SizeX, self.SizeY = x or self.SizeX, y or self.SizeY
		self.Texture:Set3DLocalDimensions((self.SizeX * 0.01), (self.SizeY * 0.01))
		self.Dirty = true
	end
end

function EHT.Particle:Tile( tileX, tileY, offsetX, offsetY, coeffX, coeffY )
	local x, y = self:GetSize()
	offsetX, offsetY = offsetX or 0, offsetY or 0
	coeffX, coeffY = coeffX or 1, coeffY or 1

	x, y = x / tileX, y / tileY
	x, y = x + offsetX, y + offsetY

	local x1, x2, y1, y2 = offsetX, x, offsetY, y
	if 0 > coeffX then  local t = x1 x1 = x2 x2 = t  end
	if 0 > coeffY then  local t = y1 y1 = y2 y2 = t  end

	self.TileX1, self.TileX2, self.TileY1, self.TileY2 = x1, x2, y1, y2
	self:SetTextureWrapping( true )
	self:SetTextureCoords( x1, x2, y1, y2 )
end

do
	function EHT.Particle:GetEffectiveColor( r, g, b, a )
		r, g, b, a = r or self.ColorR or 1, g or self.ColorG or 1, b or self.ColorB or 1, a or self.Alpha or 1

		local m = self.Effect.ColorModifier
		if m then
			local ratio = m[5] or 1
			if self:CanModifyColor() then
				r = zo_lerp( r, ( m[1] or r ), ratio )
				g = zo_lerp( g, ( m[2] or g ), ratio )
				b = zo_lerp( b, ( m[3] or b ), ratio )
			end
			a = zo_lerp( a, ( m[4] or a ), ratio )
		end

		return r, g, b, a * self.Effect:GetTransparency()
	end

	function EHT.Particle:GetColor()
		return self:GetEffectiveColor()
	end

	function EHT.Particle:GetAlpha()
		local _, _, _, a = self:GetEffectiveColor()
		return a
	end

	function EHT.Particle:SetAlpha( a )
		self.Alpha = a or self.Alpha
		local _, _, _, ea = self:GetEffectiveColor( nil, nil, nil, self.Alpha )
		self.Texture:SetAlpha( ea )
	end

	function EHT.Particle:SetColor( r, g, b, a )
		if self:CanModifyColor() then
			self.ColorR, self.ColorG, self.ColorB, self.Alpha = r or self.ColorR or 1, g or self.ColorG or 1, b or self.ColorB or 1, a or self.Alpha or 1
		else
			self.Alpha = a or self.Alpha or 1
		end

		if not self.VertexColors then
			local er, eg, eb, ea = self:GetEffectiveColor( self.ColorR, self.ColorG, self.ColorB, self.Alpha )
			self.Texture:SetColor( er, eg, eb, ea )
		else
			self:RefreshVertexColors()
		end
	end

	function EHT.Particle:SetVertexColors( v, r, g, b, a )
		local vc = self.VertexColors
		if not vc then
			vc = { }
			self.VertexColors = vc
		end

		if hasbit( v, BIT1 ) then vc[1] = { r, g, b, a } end
		if hasbit( v, BIT2 ) then vc[2] = { r, g, b, a } end
		if hasbit( v, BIT4 ) then vc[3] = { r, g, b, a } end
		if hasbit( v, BIT8 ) then vc[4] = { r, g, b, a } end

		r, g, b, a = self:GetEffectiveColor( r, g, b, a )
		self.Texture:BaseSetVertexColors( v, r, g, b, a )
	end

	function EHT.Particle:RefreshVertexColors()
		local vc = self.VertexColors
		if vc then
			for v = 1, 4 do
				local c = vc[v]
				if c then
					local r, g, b, a = self:GetEffectiveColor( c[1], c[2], c[3], c[4] )
					self.Texture:BaseSetVertexColors( bit(v), r, g, b, a )
				end
			end
		end
	end

	function EHT.Particle:SetIntervalColorOffsets( baseR, rangeR, baseG, rangeG, baseB, rangeB, baseA, rangeA, interval, intervalOffset )
		local r, g, b, a = GetIntervalColor( baseR, rangeR, baseG, rangeG, baseB, rangeB, baseA, rangeA, interval, intervalOffset )
		self:SetColorOffsets( r, g, b, a )
	end

	function EHT.Particle:SetIntervalVertexColors( baseR, rangeR, baseG, rangeG, baseB, rangeB, baseA, rangeA, interval, intervalOffset, vertexDelta1, vertexDelta2, vertexDelta3 )
		local effR, effG, effB, effA = self.ColorR, self.ColorG, self.ColorB, self.Alpha
		local r, g, b, a, vertex, offset
		vertex, offset = 1, 0

		r, g, b, a = GetIntervalColor( baseR, rangeR, baseG, rangeG, baseB, rangeB, baseA, rangeA, interval, intervalOffset + offset )
		self:SetVertexColors( 1, self:GetEffectiveColor( effR * r, effG * g, effB * b, effA * a ) )

		r, g, b, a = GetIntervalColor( baseR, rangeR, baseG, rangeG, baseB, rangeB, baseA, rangeA, interval, intervalOffset + offset + vertexDelta1 )
		self:SetVertexColors( 2, self:GetEffectiveColor( effR * r, effG * g, effB * b, effA * a ) )

		r, g, b, a = GetIntervalColor( baseR, rangeR, baseG, rangeG, baseB, rangeB, baseA, rangeA, interval, intervalOffset + offset + ( vertexDelta2 or ( vertexDelta1 * 2 ) ) )
		self:SetVertexColors( 8, self:GetEffectiveColor( effR * r, effG * g, effB * b, effA * a ) )

		r, g, b, a = GetIntervalColor( baseR, rangeR, baseG, rangeG, baseB, rangeB, baseA, rangeA, interval, intervalOffset + offset + ( vertexDelta3 or ( vertexDelta1 * 3 ) ) )
		self:SetVertexColors( 4, self:GetEffectiveColor( effR * r, effG * g, effB * b, effA * a ) )
	end
end

function EHT.Particle:GetAdditive()
	return self.Texture:GetBlendMode() == TEX_BLEND_MODE_ADD
end

function EHT.Particle:SetAdditive( enabled )
	self.Texture:SetBlendMode( enabled and TEX_BLEND_MODE_ADD or TEX_BLEND_MODE_ALPHA )
end

function EHT.Particle:GetDodge()
	return self.Texture:GetBlendMode() == TEX_BLEND_MODE_COLOR_DODGE
end

function EHT.Particle:SetDodge( enabled )
	self.Texture:SetBlendMode( enabled and TEX_BLEND_MODE_COLOR_DODGE or TEX_BLEND_MODE_ALPHA )
end

function EHT.Particle:GetTextureWrapping()
	return self.Texture:GetAddressMode() == TEX_MODE_WRAP
end

function EHT.Particle:SetTextureWrapping( enabled )
	self.Texture:SetAddressMode( enabled and TEX_MODE_WRAP or TEX_MODE_CLAMP )
end

function EHT.Particle:GetUseDepthBuffer()
	self.Texture:Does3DRenderSpaceUseDepthBuffer()
end

function EHT.Particle:SetUseDepthBuffer( buffered )
	self.Texture:Set3DRenderSpaceUsesDepthBuffer( buffered and enableDepthBuffer )
end

function EHT.Particle:GetTextureCoords()
	return self.TCLeft or 0, self.TCRight or 1, self.TCTop or 0, self.TCBottom or 1
end

function EHT.Particle:SetTextureCoords( left, right, top, bottom )
	self.TCLeft, self.TCRight, self.TCTop, self.TCBottom = left or self.TCLeft, right or self.TCRight, top or self.TCTop, bottom or self.TCBottom

	if self.Texture:IsTextureLoaded() then
		self.Texture:SetTextureCoords( self.TCLeft, self.TCRight, self.TCTop, self.TCBottom )
	else
		zo_callLater( function() self:SetTextureCoords() end, 1 )
	end
end

function EHT.Particle:SetTextureRotation( angle )
	self.Texture:SetTextureCoordsRotation( angle )
end

function EHT.Particle:GetVertexUV( vertexIndex )
	return self.Texture:GetVertexUV( vertexIndex )
end

function EHT.Particle:SetVertexUV( vertexIndex, u, v )
	self.Texture:SetVertexUV( vertexIndex, u, v )
end

function EHT.Particle:GetDesaturation()
	return self.Desaturation
end

function EHT.Particle:SetDesaturation( value )
	self.Desaturation = value or self.Desaturation
	self.Texture:SetDesaturation( self.Desaturation )
end

function EHT.Particle:GetVertices()
	return	self.X1, self.Y1, self.Z1,
			self.X2, self.Y2, self.Z2,
			self.X3, self.Y3, self.Z3,
			self.X4, self.Y4, self.Z4
end

function EHT.Particle:GetVertexBounds()
	self:UpdateVertices()

	return	self.XMin, self.YMin, self.ZMin,
			self.XMax, self.YMax, self.ZMax
end

function EHT.Particle:UpdateVertices()
	local sizeX, sizeY = self.SizeX or 0, self.SizeY or 0
	sizeX, sizeY = 0.5 * sizeX, 0.5 * sizeY

	local pitch, yaw, roll = self.Pitch or 0, self.Yaw or 0, self.Roll or 0
	local xx, xy, xz = EHT.World.Rotate( sizeX, 0, 0, pitch, yaw, roll )
	local yx, yy, yz = EHT.World.Rotate( 0, sizeY, 0, pitch, yaw, roll )

	local x, y, z = self.X or 0, self.Y or 0, self.Z or 0
	self.X1, self.Y1, self.Z1 = x +  xx + yx, y +  xy + yy, z +  xz + yz
	self.X2, self.Y2, self.Z2 = x +  xx - yx, y +  xy - yy, z +  xz - yz
	self.X3, self.Y3, self.Z3 = x + -xx + yx, y + -xy + yy, z + -xz + yz
	self.X4, self.Y4, self.Z4 = x + -xx - yx, y + -xy - yy, z + -xz - yz

	self.XMin, self.YMin, self.ZMin = math.min( self.X1, self.X2, self.X3, self.X4 ), math.min( self.Y1, self.Y2, self.Y3, self.Y4 ), math.min( self.Z1, self.Z2, self.Z3, self.Z4 )
	self.XMax, self.YMax, self.ZMax = math.max( self.X1, self.X2, self.X3, self.X4 ), math.max( self.Y1, self.Y2, self.Y3, self.Y4 ), math.max( self.Z1, self.Z2, self.Z3, self.Z4 )
end

function EHT.Particle:ShortestDistance( x, y, z )
	local xl, yl, zl, xh, yh, zh = self:GetVertexBounds()
	local dx, dy, dz = zo_clamp( x, xl, xh ), zo_clamp( y, yl, yh ), zo_clamp( z, zl, zh )
	local px, py, pz = dx - x, dy - y, dz - z

	return math.sqrt( px * px + py * py + pz * pz )
end

function EHT.Particle:GetOrientation()
	return self.Texture:Get3DRenderSpaceOrientation()
end

function EHT.Particle:SetOrientation(pitch, yaw, roll)
	if pitch or yaw or roll then
		self.Pitch, self.Yaw, self.Roll = pitch or self.Pitch or 0, yaw or self.Yaw or 0, roll or self.Roll or 0
		self.Texture:Set3DRenderSpaceOrientation(self.Pitch, self.Yaw, self.Roll)
		self.Dirty = true
		self.normalX = nil
	end
end

function EHT.Particle:GetPosition()
	return 0 == self.X and 1 or self.X or 1, self.Y or 1, self.Z or 1
end

function EHT.Particle:SetPosition(x, y, z)
	if x or y or z then
		self.X, self.Y, self.Z = x or self.X or 0, y or self.Y or 0, z or self.Z or 0
		self.Texture:Set3DRenderSpaceOrigin(WorldPositionToGuiRender3DPosition(x, y, z))
		self.Dirty = true
	end
end

function EHT.Particle:GetPositionAndOrientation()
	local x, y, z = self.X, self.Y, self.Z
	if not x then
		x, y, z = GuiRender3DPositionToWorldPosition(self.Texture:Get3DRenderSpaceOrigin())
	end
	local pitch, yaw, roll = self.Pitch, self.Yaw, self.Roll
	if not pitch then
		pitch, yaw, roll = self.Texture:Get3DRenderSpaceOrientation()
	end
	return x, y, z, pitch, yaw, roll
end

function EHT.Particle:SetPositionAndOrientation( x, y, z, pitch, yaw, roll )
	self:SetOrientation(pitch, yaw, roll)
	self:SetPosition(x, y, z)
end

local function RotateCoords( tex, theta, centerX, centerY, scaleX, scaleY )
	centerX, centerY = centerX or 0.5, centerY or 0.5
	scaleX = 1 / (scaleX or 1)
	scaleY = scaleY and (1 / scaleY) or scaleX

	local x1, _, y1 = EHT.World.RotateAxisY(-0.5, 0, -0.5, theta)
	local x2, _, y2 = EHT.World.RotateAxisY( 0.5, 0, -0.5, theta)
	local x4, _, y4 = EHT.World.RotateAxisY(-0.5, 0,  0.5, theta)
	local x8, _, y8 = EHT.World.RotateAxisY( 0.5, 0,  0.5, theta)

	tex:SetVertexUV(1, centerX + scaleX * x1, centerY + scaleY * y1)
	tex:SetVertexUV(2, centerX + scaleX * x2, centerY + scaleY * y2)
	tex:SetVertexUV(4, centerX + scaleX * x4, centerY + scaleY * y4)
	tex:SetVertexUV(8, centerX + scaleX * x8, centerY + scaleY * y8)
end

function EHT.World.RotateTexture(...)
	return RotateCoords(...)
end

function EHT.Particle:RotateCoords(theta, centerX, centerY, scaleX, scaleY)
	if self:IsTextureLoaded() then
		RotateCoords(self.Texture, theta, centerX, centerY, scaleX, scaleY)
	else
		zo_callLater(function()
			self:RotateCoords(theta, centerX, centerY, scaleX, scaleY)
		end, 1)
	end
end

function EHT.Particle:GetPlayerDistance()
	local x, y, z = self:GetPosition()
	return zo_distance3D(x, y, z, CameraX, CameraY, CameraZ)
end

function EHT.Particle:GetPlayerCharacterDistance()
	local x, y, z = self:GetPosition()
	return zo_distance3D(x, y, z, PlayerX, PlayerY, PlayerZ)
end

function EHT.Particle:GetOffsets()
	return self.OffsetX, self.OffsetY, self.OffsetZ, self.OffsetPitch, self.OffsetYaw, self.OffsetRoll, self.OffsetR, self.OffsetG, self.OffsetB, self.OffsetA, self.OffsetSizeX, self.OffsetSizeY
end

function EHT.Particle:GetPositionOffsets()
	return self.OffsetX, self.OffsetY, self.OffsetZ
end

function EHT.Particle:GetPositionOffsetValues()
	local oX, oY, oZ = self.OffsetX or 0, self.OffsetY or 0, self.OffsetZ or 0
	local sX, sY, sZ = self.Effect:GetSize()

	if 0 ~= oX and -1 <= oX and 1 >= oX then oX = oX * sX end
	if 0 ~= oY and -1 <= oY and 1 >= oY then oY = oY * sY end
	if 0 ~= oZ and -1 <= oZ and 1 >= oZ then oZ = oZ * sZ end

	return oX, oY, oZ
end

function EHT.Particle:GetOrientationOffsets()
	return self.OffsetPitch, self.OffsetYaw, self.OffsetRoll
end

function EHT.Particle:GetColorOffsets()
	return self.OffsetR, self.OffsetG, self.OffsetB, self.OffsetA
end

function EHT.Particle:GetSizeOffsets()
	return self.OffsetSizeX, self.OffsetSizeY
end

function EHT.Particle:SetOffsets( x, y, z, pitch, yaw, roll, r, g, b, a, sizeX, sizeY )
	self.OffsetX, self.OffsetY, self.OffsetZ = x or self.OffsetX, y or self.OffsetY, z or self.OffsetZ
	self.OffsetPitch, self.OffsetYaw, self.OffsetRoll = pitch or self.OffsetPitch, yaw or self.OffsetYaw, roll or self.OffsetRoll
	self.OffsetR, self.OffsetG, self.OffsetB, self.OffsetA = r or self.OffsetR, g or self.OffsetG, b or self.OffsetB, a or self.OffsetA
	self.OffsetSizeX, self.OffsetSizeY = sizeX or self.OffsetSizeX, sizeY or self.OffsetSizeY
end

function EHT.Particle:SetPositionOffsets( x, y, z )
	self.OffsetX, self.OffsetY, self.OffsetZ = x or self.OffsetX, y or self.OffsetY, z or self.OffsetZ
	self.X, self.Y, self.Z = nil, nil, nil
end

function EHT.Particle:SetOrientationOffsets( pitch, yaw, roll )
	self.OffsetPitch, self.OffsetYaw, self.OffsetRoll = pitch or self.OffsetPitch, yaw or self.OffsetYaw, roll or self.OffsetRoll
end

function EHT.Particle:SetColorOffsets( r, g, b, a )
	self.OffsetR, self.OffsetG, self.OffsetB, self.OffsetA = r or self.OffsetR, g or self.OffsetG, b or self.OffsetB, a or self.OffsetA
end

function EHT.Particle:SetSizeOffsets( sizeX, sizeY )
	self.OffsetSizeX, self.OffsetSizeY = sizeX or self.OffsetSizeX, sizeY or self.OffsetSizeY
end

function EHT.Particle:GetScale()
	return self.ScaleX, self.ScaleY
end

function EHT.Particle:GetScaleOffsets()
	return self.ScaleOffsetX, self.ScaleOffsetY
end

function EHT.Particle:SetScale( scaleX, scaleY, offsetX, offsetY )
	self.ScaleX, self.ScaleY = scaleX or self.ScaleX or 1, scaleY or self.ScaleY or 1
	self.ScaleOffsetX, self.ScaleOffsetY = offsetX or self.ScaleOffsetX or 0, offsetY or self.ScaleOffsetY or 0
	self:Rescale()
end

function EHT.Particle:SetScaleOffsets( offsetX, offsetY )
	self.ScaleOffsetX, self.ScaleOffsetY = offsetX or self.ScaleOffsetX or 0, offsetY or self.ScaleOffsetY or 0
	self:Rescale()
end

function EHT.Particle:Rescale()
	local scaleX, scaleY = 1 / self.ScaleX, 1 / self.ScaleY
	local offsetX, offsetY = scaleX * self.ScaleOffsetX, scaleY * self.ScaleOffsetY
	self:SetTextureCoords( -scaleX + offsetX, scaleX + offsetX + 1, -scaleY + offsetY, scaleY + offsetY + 1 )
end

function EHT.Particle:GetForward()
	local ox, oy, oz = self.Texture:Convert3DWorldPositionToLocalPosition(0, 0, 0)
	local vx, vy, vz = self.Texture:Convert3DWorldPositionToLocalPosition(0, 0, 1)
	return NormalVector(vx - ox, vy - oy, vz - oz)
end

function EHT.Particle:GetRight()
	local ox, oy, oz = self.Texture:Convert3DWorldPositionToLocalPosition(0, 0, 0)
	local vx, vy, vz = self.Texture:Convert3DWorldPositionToLocalPosition(1, 0, 0)
	return NormalVector(vx - ox, vy - oy, vz - oz)
end

function EHT.Particle:GetUp()
	local ox, oy, oz = self.Texture:Convert3DWorldPositionToLocalPosition(0, 0, 0)
	local vx, vy, vz = self.Texture:Convert3DWorldPositionToLocalPosition(0, 1, 0)
	return NormalVector(vx - ox, vy - oy, vz - oz)
end

function EHT.Particle:GetRightUpForward()
	local ox, oy, oz = self.Texture:Convert3DWorldPositionToLocalPosition(0, 0, 0)
	local rx, ry, rz = self.Texture:Convert3DWorldPositionToLocalPosition(1, 0, 0)
	local ux, uy, uz = self.Texture:Convert3DWorldPositionToLocalPosition(0, 1, 0)
	local fx, fy, fz = self.Texture:Convert3DWorldPositionToLocalPosition(0, 0, 1)
	rx, ry, rz = NormalVector(rx - ox, ry - oy, rz - oz)
	ux, uy, uz = NormalVector(ux - ox, uy - oy, uz - oz)
	fx, fy, fz = NormalVector(fx - ox, fy - oy, fz - oz)
	return rx, ry, rz, ux, uy, uz, fx, fy, fz
end
--[[
function EHT.Particle:GetForward()
	return self.Texture:Convert3DWorldPositionToLocalPosition(0, 0, 1)
end

function EHT.Particle:GetRight()
	return self.Texture:Convert3DWorldPositionToLocalPosition(1, 0, 0)
end

function EHT.Particle:GetUp()
	return self.Texture:Convert3DWorldPositionToLocalPosition(0, 1, 0)
end

function EHT.Particle:GetNormalVector()
	local fx, fy, fz = self.Texture:Convert3DLocalPositionToWorldPosition(0, 0, 1)
	local ox, oy, oz = self.Texture:Convert3DLocalPositionToWorldPosition()
	local dx, dy, dz = fx - ox, fy - oy, fz - oz

	return EHT.World:GetNormalVector(dx, dy, dz)
end

function EHT.Particle:GetCameraUVOffsets()
	local nx, ny, nz = self:GetNormalVector()
	local px, py, pz = self:GetPosition()
	local dx, dy, dz = CameraX - px, CameraY - py, CameraZ - pz
	local dc = 1 / math.sqrt(dx * dx + dy * dy + dz * dz)
	local dnx, dny, dnz = dx * dc, dy * dc, dz * dc
	local ox, oy = dnx * nx + dnz * nz, dny * ny
	return ox, oy
end

function EHT.Particle:GetViewAngleOffsets()
	local nx, ny, nz = self:GetNormalVector()
	local vx = math.abs( CameraForwardX ) - math.abs( nx )
	local vy = math.abs( CameraForwardY ) - math.abs( ny )
	local vz = math.abs( CameraForwardZ ) - math.abs( nz )
	return vx, vy, vz
end
]]
function EHT.Particle:GetCameraDistance()
	local tex = self.Texture
	local sx, sy = self:GetSize()	sx, sy = 0.5 * sx, 0.5 * sy
	local pitch, yaw, roll = self:GetOrientation()
	local x, y, z = self:GetPosition()
	local cx, cy, cz = CameraX - x, CameraY - y, CameraZ - z

	local x0, y0, z0 = EHT.World.Rotate( sx, sy, 0, pitch, yaw, roll )
	local x1, y1, z1 = EHT.World.Rotate( sx, -sy, 0, pitch, yaw, roll )
	local x2, y2, z2 = EHT.World.Rotate( -sx, sy, 0, pitch, yaw, roll )
	local x3, y3, z3 = EHT.World.Rotate( -sx, -sy, 0, pitch, yaw, roll )

	return 0.5 * ( GetMinPointLineDistance( cx, cy, cz, x0, y0, z0, x1, y1, z1 ) + GetMinPointLineDistance( cx, cy, cz, x2, y2, z2, x3, y3, z3 ) )
end

function EHT.Particle:GetCameraDepth()
	local _, _, depth = CameraWindow.CameraControl:Convert3DWorldPositionToLocalPosition( self.Texture:Get3DRenderSpaceOrigin() )
	return depth * 100
end

function EHT.Particle:GetSurfaceNormal()
	if not self.normalX then
		local tex = self.Texture
		local x0, y0, z0 = tex:Convert3DWorldPositionToLocalPosition( 0, 0, 0 )
		local x1, y1, z1 = tex:Convert3DWorldPositionToLocalPosition( 1, 0, 0 )
		local x2, y2, z2 = tex:Convert3DWorldPositionToLocalPosition( 0, 1, 0 )
		self.normalX, self.normalY, self.normalZ = CrossProduct( x1 - x0, y1 - y0, z1 - z0, x2 - x0, y2 - y0, z2 - z0 )
	end
	return self.normalX, self.normalY, self.normalZ
end

function EHT.Particle:GetUpVector()
	local tex = self.Texture
	local x0, y0, z0 = tex:Convert3DWorldPositionToLocalPosition( 0, 0, 0 )
	local x1, y1, z1 = tex:Convert3DWorldPositionToLocalPosition( 0, 1, 0 )
	return NormalVector( x1 - x0, y1 - y0, z1 - z0 )
end
--[[
-- Equally functional and performant as EHT.Particle:GetSurfaceNormal()...
function EHT.Particle:GetNormal()
	if not self.normalX then
		local tex = self.Texture
		local x, y, z = tex:Get3DRenderSpaceOrigin()
		local worldX, worldY, worldZ = tex:Convert3DLocalPositionToWorldPosition( 0, 0, 1 )
		self.normalX, self.normalY, self.normalZ = NormalVector( worldX - x, worldY - y, worldZ - z )
	end
	return self.normalX, self.normalY, self.normalZ
end
]]
function EHT.Particle:GetCameraNormal()
	local x, y, z = self:GetSurfaceNormal()
	return DotProduct( CameraNormalX, CameraNormalY, CameraNormalZ, x, y, z )
end

function EHT.Particle:GetForwardCameraNormal()
	local originX, originY, originZ = self.Texture:Convert3DWorldPositionToLocalPosition( 0, 0, 0 )
	local forwardX, forwardY, forwardZ = self.Texture:Convert3DWorldPositionToLocalPosition( 0, 1, 0 )
	local vectorX, vectorY, vectorZ = NormalVector( forwardX - originX, forwardY - originY, forwardZ - originZ )
	local cameraOriginX, cameraOriginY, cameraOriginZ = CameraWindow.CameraControl:Convert3DWorldPositionToLocalPosition( 0, 0, 0 )
	local cameraForwardX, cameraForwardY, cameraForwardZ = CameraWindow.CameraControl:Convert3DWorldPositionToLocalPosition( 0, 1, 0 )
	local cameraVectorX, cameraVectorY, cameraVectorZ = NormalVector( cameraForwardX - cameraOriginX, cameraForwardY - cameraOriginY, cameraForwardZ - cameraOriginZ )

	return DotProduct( cameraVectorX, cameraVectorY, cameraVectorZ, vectorX, vectorY, vectorZ )
end

function EHT.Particle:FaceCamera()
	self:SetOrientation( FaceCameraPitch, FaceCameraYaw, FaceCameraRoll )
end

function EHT.Particle:SetCameraFacing( value )
	self.CameraFacing = false ~= value

	if self.CameraFacing then
		CameraFacingParticles[self] = true
	else
		CameraFacingParticles[self] = nil
	end
end

function EHT.Particle:GetVectorFromCamera()
	return self.X - CameraX, self.Y - CameraY, self.Z - CameraZ
end

function EHT.Particle:GetVectorToCamera()
	return CameraX - self.X, CameraY - self.Y, CameraZ - self.Z
end

function EHT.Particle:TurnToCamera()
	local nx, ny, nz = self:GetUpVector()
	local dx, dz = CameraX - self.X, CameraZ - self.Z
	local angle = math.atan2( dx, dz )
	local cp = math.abs( ny )
	local cy = 1 - cp
	--local pitch, yaw, roll = angle * math.abs( ny ), angle * ( math.abs( nx ) + math.abs( nz ) ), 0
	local pitch, yaw, roll = angle * cp, angle * cy, 0

	--pitch, yaw, roll = self.Texture:Convert3DLocalOrientationToWorldOrientation( pitch, yaw, roll )
	self:SetOrientation( pitch, yaw, roll )
	return pitch, yaw, roll, angle
end

------[ Effect ]------

function EHT.Effect:GetLimit()
	return MAX_EFFECTS
end

function EHT.Effect:GetAll()
	return EffectList
end

function EHT.Effect:GetNumPlacedEffects()
	local count = 0
	for _, effect in pairs( EffectList ) do
		if effect.Active and not effect.Deleted and not effect.EffectType:IsReserved() then
			count = count + 1
		end
	end
	return count
end

function EHT.Effect:GetByIndex( index )
	return EffectList[ index ]
end
if not eff then function eff( index ) return EHT.Effect:GetByIndex( index ) end end

function EHT.Effect:GetById( id, fallbackToIndex )
	local effects = EffectList

	if EHT.Housing.IsEffectGroupId( id ) then
		local groupBit = EHT.Housing.GetEffectGroupBit( id )
		local list = { }

		for index, effect in ipairs( effects ) do
			if hasbit( effect.Groups or 0, groupBit ) then
				table.insert( list, effect )
			end
		end

		return list
	else
		for index, effect in ipairs( effects ) do
			if id == effect:GetRecordId() then
				return { effect }
			end
		end
	end

	if fallbackToIndex then
		return { effects[ id ] }
	end

	return { }
end

function EHT.Effect:GetByIds( ids, fallbackToIndex )
	local list = { }
	local effects = EffectList

	for index, effect in ipairs( effects ) do
		if EHT.Util.IsListValue( ids, effect:GetRecordId() ) then
			table.insert( list, effect )
		elseif fallbackToIndex and EHT.Util.IsListValue( ids, index ) then
			table.insert( list, effect )
		end
	end

	return list
end

function EHT.Effect:GetByRecord( record )
	local effect
	for index = 1, #EffectList do
		effect = EffectList[index]
		if effect and effect.Record == record then return effect end
	end
end

function EHT.Effect:GetByRecordId( id )
	id = tonumber( id )
	if nil == id then return nil end

	local effect
	for index = 1, #EffectList do
		effect = EffectList[index]
		if effect and effect.Record and effect.Record.Id == id then return effect end
	end

	return nil
end

do
	local EventDescriptor = EVENT_PREFIX .. "OnUpdate"
	local Interval = UPDATE_EFFECTS_INTERVAL
	local UpdateRegistered = false

	function EHT.Effect:RegisterOnUpdate()
		if not UpdateRegistered and not EHT.EffectUI.AreEffectsHidden() then
			UpdateRegistered = true
			EVENT_MANAGER:RegisterForUpdate( EventDescriptor, Interval, EHT.World.OnUpdateEffects )
		end
	end

	function EHT.Effect:UnregisterOnUpdate()
		if UpdateRegistered then
			UpdateRegistered = false
			EVENT_MANAGER:UnregisterForUpdate( EventDescriptor )
		end
	end
end

do
	local EventDescriptor = EVENT_PREFIX .. "OnReorderParticles"
	local Interval = REORDER_PARTICLES_INTERVAL
	local UpdateRegistered = false

	function EHT.Effect:RegisterOnReorderParticles()
		if not UpdateRegistered and not EHT.EffectUI.AreEffectsHidden() then
			UpdateRegistered = true
			EVENT_MANAGER:RegisterForUpdate( EventDescriptor, Interval, EHT.World.OnReorderParticles )
		end
	end

	function EHT.Effect:UnregisterOnReorderParticles()
		if UpdateRegistered then
			UpdateRegistered = false
			EVENT_MANAGER:UnregisterForUpdate( EventDescriptor )
		end
	end
end

function EHT.Effect:OnEffectGroupsChanged( effect, newGroups, prevGroups )
	local effectId = effect:GetRecordId()

	for _, e in pairs( EHT.Effect:GetAll() ) do
		local id = tonumber( e:GetMetaData( "Target Effect" ) )

		if id and 0 ~= id and e.EffectType.OnMetaDataChanged then
			local update = false

			if id == effectId then
				update = true
			else
				local groupBit = EHT.Housing.GetEffectGroupBit( id )
				if groupBit and ( hasbit( newGroups or 0, groupBit ) or hasbit( prevGroups or 0, groupBit ) ) then
					update = true
				end
			end

			if update then
				e.EffectType.OnMetaDataChanged( e, "Target Effect", id, id )
			end
		end
	end
end

SLASH_COMMANDS["/resetfxwarnings"] = function()
	EHT.SavedVars.LastWarningShownForSubSamplingSetting, EHT.SavedVars.NumWarningShownForSubSamplingSetting = nil, nil
	EHT.SavedVars.LastWarningShownForDisplayModeSetting, EHT.SavedVars.NumWarningShownForDisplayModeSetting = nil, nil
	d( "Warnings reset." )
end

function EHT.Effect:CheckEffectsRelatedSettings( forcePrompt )
	local invalidSubsampling, invalidDisplayMode = false, false

	if	tostring( SUB_SAMPLING_MODE_NORMAL ) ~= GetSetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_SUB_SAMPLING ) or
		tostring( FULLSCREEN_MODE_FULLSCREEN_WINDOWED ) ~= GetSetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_FULLSCREEN ) then
		--tostring(ANTIALIASING_TYPE_TAA) == GetSetting(SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_ANTI_ALIASING) then
		local adjustFXSettings = EHT.CONST.ADJUST_FX_SETTINGS[ EHT.GetSetting( "AdjustFXSettings" ) ]

		if forcePrompt then
			zo_callLater(function()
				EHT.UI.ShowEffectsRelatedSettingsAdjustmentPrompt( forcePrompt )
			end, 5000)
		elseif "Always" == adjustFXSettings then
			EHT.Effect:AdjustEffectsRelatedSettings()
		elseif "Never" == adjustFXSettings then
			return
		else
			local owner, houseId = EHT.Housing.GetHouseOwner()

			if EHT.LastEffectsRelatedSettingsAdjustment and EHT.LastEffectsRelatedSettingsAdjustment.Owner == owner and EHT.LastEffectsRelatedSettingsAdjustment.HouseId == houseId then
				EHT.Effect:AdjustEffectsRelatedSettings()
			elseif not EHT.LastEffectsRelatedSettingsCheck or EHT.LastEffectsRelatedSettingsCheck.Owner ~= owner or EHT.LastEffectsRelatedSettingsCheck.HouseId ~= houseId then
				EHT.LastEffectsRelatedSettingsCheck =
				{
					Owner = owner,
					HouseId = houseId,
				}
				
				zo_callLater(function()
					EHT.UI.ShowEffectsRelatedSettingsAdjustmentPrompt()
				end, 5000)
			end
		end
	elseif forcePrompt then
		EHT.UI.ConfirmEffectsRelatedSettingsPrompt()
	end
end

function EHT.Effect:AdjustEffectsRelatedSettings( alwaysAdjustSettings )
	local owner, houseId = EHT.Housing.GetHouseOwner()
	if true == alwaysAdjustSettings then
		EHT.SavedVars.AdjustFXSettings = EHT.CONST.ADJUST_FX_SETTINGS_VALUES[ "Always" ]
	elseif not EHT.LastEffectsRelatedSettingsAdjustment or EHT.LastEffectsRelatedSettingsAdjustment.Owner ~= owner or EHT.LastEffectsRelatedSettingsAdjustment.HouseId ~= houseId then
		EHT.LastEffectsRelatedSettingsAdjustment =
		{
			Owner = owner,
			HouseId = houseId,
		}
	else
		EHT.UI.DisplayNotification( "Essential Housing Tools has temporarily adjusted your settings to support FX in this home.\n\n" ..
			"This option may be configured in Settings || Addons || Essential Housing Tools" )
	end
	EHT.LastEffectsRelatedSettingsCheck = nil

	EHT.Util.ModifySetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_SUB_SAMPLING, tostring( SUB_SAMPLING_MODE_NORMAL ) )
	EHT.Util.ModifySetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_FULLSCREEN, tostring( FULLSCREEN_MODE_FULLSCREEN_WINDOWED ) )

	if KEYBOARD_OPTIONS and KEYBOARD_OPTIONS.UpdateAllPanelOptions then
		KEYBOARD_OPTIONS:UpdateAllPanelOptions()
	end
end

function EHT.Effect:RestoreEffectsRelatedSettings()
	EHT.Util.RestoreSetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_SUB_SAMPLING )
	EHT.Util.RestoreSetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_FULLSCREEN )
end

function EHT.Effect:New( effectType, index, cacheOnly, temporary, deferredSetupFunction )
	if not cacheOnly then
		self:CheckEffectsRelatedSettings()
	end

	if #EffectList >= MAX_EFFECTS then
		df("You have reached the maximum number of effects (%d).", MAX_EFFECTS)
		return nil
	end

    local obj = ZO_Object.New( self )
    return obj:Initialize( effectType, index, cacheOnly, temporary, deferredSetupFunction )
end

do
	local EFFECT_CLEAN_UP_HELP_TEXT = "\n|cffffffType |c00ffff/cleanfx|cffffff to remove the deprecated FX and dismiss this message."

	function EHT.Effect:Initialize( effectType, index, cacheOnly, temporary, deferredSetupFunction )
		self.Particles = {}

		if "number" == type( effectType ) then
			local effectTypeId = effectType
			effectType = EHT.EffectType:GetByIndex( effectTypeId )
			if not Assert( nil ~= effectType and effectType.Active, string.format( "Cannot initialize effect. Effect Type number %d not found.%s", effectTypeId, EFFECT_CLEAN_UP_HELP_TEXT ) ) then return end
			if nil == effectType or not effectType.Active then return end
		elseif "string" == type( effectType ) then
			local name = effectType
			effectType = EHT.EffectType:GetByName( name )
			if not Assert( nil ~= effectType and effectType.Active, string.format( "Cannot initialize effect. Effect Type '%s' not found.%s", name or "(nil)", EFFECT_CLEAN_UP_HELP_TEXT ) ) then return end
			if nil == effectType or not effectType.Active then return end
		end

		if not Assert( nil ~= effectType and effectType.Active, "Cannot initialize effect. Effect Type is invalid." ) then return end
		if nil == effectType or not effectType.Active then return end

		self.Active = nil
		self.DeferredSetupFunction = deferredSetupFunction
		self.Deleted = nil
		self.ReadyMS = nil
		self.ForceReadyMS = GetGameTimeMilliseconds() + 10000
		self.Resetting = nil
		self.Temporary = temporary
		self.EffectType = effectType
		self._effectTypeId = self.EffectType.Index
		self.OrderDrawLevelByIndex = true == self.EffectType.OrderDrawLevelByIndex
		self.Record = nil
		self.AnchorId = nil
		self.TranslateX = 0
		self.TranslateY = 0
		self.TranslateZ = 0
		self.X = 0
		self.Y = 0
		self.Z = 0
		self.Pitch = 0
		self.Yaw = 0
		self.Roll = 0
		self.ColorR = 1
		self.ColorG = 1
		self.ColorB = 1
		self.Alpha = 1
		self.SizeX = 100
		self.SizeY = 100
		self.SizeZ = 100
		self.TileX = 0
		self.TileY = 0
		self.Contrast = 1
		self.TintRatio = 1
		self.AutoColorEnabled = true
		self.AutoDrawLevelEnabled = true
		self.AutoSizeEnabled = true
		self.AutoPositionEnabled = true
		self.AutoOrientationEnabled = true
		self.CameraFacing = false
		self.IntervalOffset = 0
		self.IntervalOffsetRange = 0
		self.Groups = 0
		self:SetState(EFFECT_STATE_NEW)

		if cacheOnly then
			self.Index = index
		else
			if index and index <= #EffectList then
				local previousEffect = EffectList[self.Index]
				if previousEffect and not previousEffect.Deleted then
					previousEffect:Delete(true)
				end

				self.Index = index
				EffectList[self.Index] = self
			elseif not self.Index then
				table.insert(EffectList, self)
				index = #EffectList
				self.Index = index
			end

			self:Init()
		end

		EHT.TotalEffectsInstantiated = EHT.TotalEffectsInstantiated + 1

		if not self.Temporary then
			EHT.UI.SetToolDialogWindowTitle()
		end

		return self
	end
end

function EHT.Effect:SetState(state)
	self.EffectState = state
	--if EHT.IsDev then df("[DEBUG %.3fms] '%s' state set to %s.", GetGameTimeMilliseconds() / 1000, self.EffectType.Name, EFFECT_STATE_NAMES[self.EffectState] or "(nil)") end
end

function EHT.Effect:Init()
	self:SetState(EFFECT_STATE_INITIALIZING)

	if self.EffectType.Init then
		self.EffectType.Init(self)
	end

	self.ForceReadyMS = GetGameTimeMilliseconds() + 10000
	self.ReadyMS = nil
	self.Active = false
	self:EnqueueEffectInit()
end

local function OnUpdateDeferralQueue()
	local queue = EHT.DeferredEffects
	local ts = GetGameTimeMilliseconds()
	local registerEvents = false
	
	for effect in pairs(queue) do
		if effect.Active or effect.Deleted or not effect.EffectType or effect.EffectState ~= EFFECT_STATE_INITIALIZING then
			queue[effect] = nil
		else
			if (effect.ReadyMS and ts > effect.ReadyMS) or ts > effect.ForceReadyMS then
				queue[effect] = nil
				effect.ReadyMS = nil
				effect.ForceReadyMS = nil

				-- Order matters
				effect.Active = true
--if EHT.IsDev then df("[DEBUG %.3fms] '%s' particles ready.", GetGameTimeMilliseconds()/1000, effect.EffectType.Name) end
				effect:SetState(EFFECT_STATE_INITIALIZED)
				effect:Reset()

				if not effect.Temporary and effect.EffectType:UsesGlobalTray() then
					EHT.GetEffectEditor():RegisterGlobalEffect(effect)
				end

				if effect.Temporary then
					local x, y, z = effect:GetPosition()
					local oX, oY, oZ = math.sin(CameraHeading or 0) * -400, 50, math.cos(CameraHeading or 0) * -400
					effect:SetPosition((x or PlayerX or 0) + oX, (y or PlayerY or 0) + oY, (z or PlayerZ or 0) + oZ)
				end

				effect:SetEffectGroup(effect:GetEffectGroupBitmask())

				if effect.Particles then
					for index, particle in ipairs(effect.Particles) do
						particle:SetColor()
						particle:SetSampleProcessing()
						particle:RefreshHidden()
					end
				end

				if effect.DeferredSetupFunction then
					effect:DeferredSetupFunction()
				end

				registerEvents = true
			elseif not effect.ReadyMS then
				if effect:AreParticlesReady() then
					effect.ReadyMS = ts + 1000
				end
			end
		end
	end

	if registerEvents then
		EHT.Effect:RegisterOnUpdate()
		EHT.Effect:RegisterOnReorderParticles()
	end
end

function EHT.Effect:ResetDeferralQueues()
	ZO_ClearTable(EHT.DeferredEffects)
end

function EHT.Effect:RegisterDeferralQueue()
	EVENT_MANAGER:RegisterForUpdate("EHT.Effect.DeferralQueue", 500, OnUpdateDeferralQueue)
end

function EHT.Effect:EnqueueEffectInit()
	EHT.DeferredEffects[self] = true
	self:RegisterDeferralQueue()
end

function EHT.Effect:Clone()
	local valid = EHT.Effect:EnforceUniqueConstraint(self:GetUniqueClass(), true)
	if not valid then
		EHT.UI.ShowAlertDialog( "",
			string.format( "Only one |cffff00%s|r effect may be placed at a time.\n\nTo replace this effect, add a new effect of this same type.", self:GetUniqueClass() or "of this" ) )
		return false
	end

	if not self.Active or self.Deleted then
		return false
	end

	local cloneAttributes = { }
	for key, value in pairs( self ) do
		local sKey, sType = string.lower( key ), type( value )
		--if "effecttype" ~= sKey and "particles" ~= sKey and "record" ~= sKey and ( "boolean" == sType or "number" == sType or "string" == sType or ( "table" == sType and "metadata" == sKey ) ) then
		if "effecttype" ~= sKey and "particles" ~= sKey and "record" ~= sKey then
			if ( "boolean" == sType or "number" == sType or "string" == sType ) or ( "table" == sType and "metadata" == sKey ) then
				if "table" ~= sType then
					cloneAttributes[ key ] = value
				else
					cloneAttributes[ key ] = EHT.Util.CloneTable( value )
				end
			end
		end
	end

	cloneAttributes.Active = nil
	cloneAttributes.Deleted = nil

	local deferredSetup = function( effect )
		if effect and not effect.Deleted then
			for key, value in pairs( cloneAttributes ) do
				if "table" == type( value ) then
					effect[ key ] = EHT.Util.CloneTable( value )
				else
					effect[ key ] = value
				end
			end
			effect:Reset()
			effect:Update()
			EHT.EffectUI.AddEffect( effect )
			if cloneAttributes.Groups then
				effect:SetEffectGroup( cloneAttributes.Groups )
			end

			local editor = EHT.GetEffectEditor()
			editor:BindToEffect( effect )
			editor:ShowEditor()
		end
	end

	local effect = EHT.Effect:New( self.EffectType.Name, nil, nil, nil, deferredSetup )
	if not effect then return nil end

	local editor = EHT.GetEffectEditor()
	editor:HideEditor()
	editor:UpdateEditButtons()

	EHT.UI.RefreshPlacedEffectsList()
	EHT.UI.PlaySoundEffectCloned()
	EHT.UI.DisplayNotification( "Effect has been cloned." )

	return effect
end

function EHT.Effect:Delete(fastDeletion)
	if CurrentEditorEffect == self then
		EHT.GetEffectEditor():HideEditor()
	end

	if not self.Temporary and self.EffectType:UsesGlobalTray() then
		EHT.GetEffectEditor():UnregisterGlobalEffect(self)
	end

	if self.EffectType.Destroy then
		self.EffectType.Destroy(self)
	end

	self.Active = false
	self.Deleted = true
	self:DeleteParticles()

	if true ~= fastDeletion then
		EHT.DeferredEffects[self] = nil

		for index, effect in ipairs(EffectList) do
			if effect == self then
				table.remove(EffectList, index)
			end
		end
	end

	EHT.UI.SetToolDialogWindowTitle()
	return true
end

function EHT.Effect:DeleteAll()
	EHT.GetEffectEditor():HideEditor()

	ZO_ClearTable(EHT.DeferredEffects)

	local FAST_DELETION = true
	for index, effect in ipairs(EffectList) do
		effect:Delete(FAST_DELETION)
	end

	ZO_ClearNumericallyIndexedTable(EffectList)
	EHT.UI.SetToolDialogWindowTitle()
end

function EHT.Effect:DeleteParticle(index)
	if index <= #self.Particles then
		self.Particles[index]:Delete()
	end
end

function EHT.Effect:DeleteParticles()
	if self.Particles then
		local FAST_DELETION = true
		for index = #self.Particles, 1, -1 do
			self.Particles[index]:Delete(FAST_DELETION)
		end
	end

	self.Particles = {}
end

function EHT.Effect:EnforceUniqueConstraint( effect, verifyOnly )
	if effect then
		local isObject = "table" == type( effect )
		local uniqueClass = isObject and effect.EffectType.UniqueClass or effect

		if not uniqueClass then return true end

		if string.find( uniqueClass, "Reserved" ) then verifyOnly = false end

		local effects = self:GetAll()
		local eff

		for index = #effects, 1, -1 do
			eff = effects[index]

			-- if eff and eff ~= effect and class == eff.EffectType.UniqueClass then
			if eff and eff.EffectType.UniqueClass == uniqueClass then
				if verifyOnly then return false end

				if eff.Record then EHT.Data.DeleteEffectRecord( eff.Record ) end
				eff:Delete()
			end
		end
	end

	return true
end

if EHT.IsDev then
	SLASH_COMMANDS[ "/fxdebug" ] = function( index )
		local dbg = EHT.SerializeEffectDebug
		local dbgBlocks = EHT.SerializeEffectDebugBlocks

		if not dbg or "table" ~= type( dbg ) then
			d( "No FX debug data captured." )
		else
			index = tonumber( index )
			if index then
				if index > #dbgBlocks then
					df( "Block index exceeds the %d blocks.", index )
				else
					df( "Message block %d of %d", index, #dbgBlocks )
					d( "-start of block-" )
					d( dbgBlocks[index] )
					d( "-end of block-" )
				end
			else
				d( "Debug data:" )
				d( table.concat( dbg, "\n" ) )
			end
		end
	end
end

function EHT.Effect:SerializeChatcast( isMailcast, houseId, owner, isGuildcast )
	local maxLength, timestamp, value1, value2, value3, value4, value5, value6
	local dbg, dbgBlocks = { }, { }
	EHT.SerializeEffectDebug = dbg
	EHT.SerializeEffectDebugBlocks = dbgBlocks

	table.insert( dbg, string.format( "SerializeChatcast( houseId=%s, owner=%s, mail=%s, guild=%s )", tostring( houseId ), tostring( owner ), tostring( isMailcast ), tostring( isGuildcast ) ) )

	if isMailcast then
		maxLength = MAX_MAILCAST_LENGTH
	elseif isGuildcast then
		maxLength = MAX_GUILDCAST_LENGTH
	else
		maxLength = MAX_CHATCAST_LENGTH
	end

	local effects, numEffects, thirdParty
	local messages = { }

	maxLength = maxLength - 2

	if not houseId then houseId = EHT.Housing.GetHouseId() end
	houseId = tonumber( houseId )

	if nil == houseId then return end

	effects, timestamp = EHT.Data.GetHouseEffects( houseId, owner )

	if not effects or "table" ~= type( effects ) then
		effects = { }
	end

	numEffects = #effects

	thirdParty = owner and "" ~= owner and string.lower( EHT.Util.Trim( owner ) ) ~= string.lower( EHT.Util.Trim( GetDisplayName() ) )
	if not thirdParty then timestamp = GetTimeStamp() end

	local blockPrefix
	if thirdParty then
		blockPrefix = string.format( "%s%d%s ", CHATCAST_PREFIX, houseId, owner)
	else
		blockPrefix = string.format( "%s%d ", CHATCAST_PREFIX, houseId )
	end
	blockPrefix = blockPrefix .. EHT.Util.IntToBase88( CHATCAST_VERSION )
	if timestamp then
		blockPrefix = blockPrefix .. "," .. EHT.Util.IntToBase88( timestamp )
	end
	local blockFragmentPrefix = blockPrefix .. ","
	blockPrefix = blockPrefix .. " "

	local blockFragmentPrefixSize = #blockFragmentPrefix + 8 -- Up to 4 digit effect index + "," + Up to 2 digit fragment index + " "
	local blockPrefixSize = #blockPrefix
	local eff, message = "", blockPrefix
	local effs = { }
	local idMap = { }
	local nextEffIndex = 0

	for index = 1, numEffects do
		local eff = effects[index]
		if eff and not eff.Temporary and eff.EffectType then
			local effectTypeIndex = tonumber( eff.EffectType.Index )
			if effectTypeIndex and effectTypeIndex > 0 and not eff.EffectType:IsReserved() then
				nextEffIndex = nextEffIndex + 1
				effs[nextEffIndex] = eff
				local eKey = tonumber( eff.Id ) or tonumber( nextEffIndex )
				idMap[eKey] = nextEffIndex
			end
		end
	end

	numEffects = #effs
	table.insert( dbg, string.format( "NumEffects( %s )", tostring( numEffects ) ) )

	for index = 1, numEffects + 1 do
		local block

		if index <= numEffects then
			eff = effs[ index ]
			local x, y, z, pitch, yaw, roll, sizeX, sizeY, sizeZ, colorR, colorG, colorB, alpha, contrast, groups = eff.X, eff.Y, eff.Z, eff.Pitch, eff.Yaw, eff.Roll, eff.SizeX, eff.SizeY, eff.SizeZ, eff.ColorR, eff.ColorG, eff.ColorB, eff.Alpha, eff.Contrast, eff.Groups
			local etIndex = tonumber( eff.EffectType.Index ) or 1

			x = "number" == type( x ) and x or 1
			y = "number" == type( y ) and y or 1
			z = "number" == type( z ) and z or 1
			pitch = "number" == type( pitch ) and pitch or 1
			yaw = "number" == type( yaw ) and yaw or 1
			roll = "number" == type( roll ) and roll or 1
			sizeX = "number" == type( sizeX ) and sizeX or 1
			sizeY = "number" == type( sizeY ) and sizeY or 1
			sizeZ = "number" == type( sizeZ ) and sizeZ or 1
			colorR = "number" == type( colorR ) and colorR or 1
			colorG = "number" == type( colorG ) and colorG or 1
			colorB = "number" == type( colorB ) and colorB or 1
			alpha = "number" == type( alpha ) and alpha or 1
			contrast = "number" == type( contrast ) and contrast or 1
			groups = EHT.Housing.GetEffectGroupId("number" == type(groups) and groups or 0) or 0

			local value1 = EHT.Util.IntToBase88( EHT.Util.CompressInteger( index, 4, etIndex, 4 ) )
			local value2 = EHT.Util.IntToBase88( EHT.Util.CompressInteger( x, 6, y, 6 ) )
			local value3 = EHT.Util.IntToBase88( EHT.Util.CompressInteger( z, 6, sizeX, 6 ) )
			local value4 = EHT.Util.IntToBase88( EHT.Util.CompressInteger( sizeY, 6, sizeZ, 6 ) )
			local value5 = EHT.Util.IntToBase88( EHT.Util.CompressInteger( 10 * ( math.deg( pitch % math.rad( 360 ) ) ), 4, 10 * ( math.deg( yaw % math.rad( 360 ) ) ), 4, 10 * ( math.deg( roll % math.rad( 360 ) ) ), 4 ) )
			local value6 = EHT.Util.IntToBase88( EHT.Util.CompressInteger( 100 * colorR, 3, 100 * colorG, 3, 100 * colorB, 3 ) )
			local value7 = EHT.Util.IntToBase88( EHT.Util.CompressInteger( zo_clamp( 100 * alpha, 0, 100 ), 4, zo_clamp( 100 * contrast, 0, 400 ), 4 ) )
			local value8 = EHT.Util.IntToBase88( EHT.Util.CompressInteger( groups, 8 ) )
			block = value1 .. value2 .. value3 .. value4 .. value5 .. value6 .. value7 .. value8

			metaParams = eff.EffectType:GetMetaParams()
			if metaParams and 0 < #metaParams then
				if "table" ~= type( eff.MetaData ) then eff.MetaData = { } end

				for paramDefIndex = 1, #metaParams do
					param = metaParams[paramDefIndex]

					local paramDef = GetMetaParamByName( param.Name )
					local paramIndex = paramDef and paramDef.Index

					if not paramIndex then
						local msg = string.format( "Failed to serialize effect type (%s) metadata parameter \"%s\": Invalid parameter index.", tostring( etIndex ) or "", tostring( param and param.Name ) or "" )
						df( msg )
						local dbgEffect = string.format( "Effect( index=%s, type=%s, position=%d,%d,%d, orientation=%.2f,%.2f,%.2f, color=%.2f,%.2f,%.2f,%.2f )", tostring( index ) or "", tostring( etIndex ) or "", x or -1, y or -1, z or -1, math.deg( pitch or 0 ), math.deg( yaw or 0 ), math.deg( roll or 0 ), colorR or -1, colorG or -1, colorB or -1, alpha or -1 )

						table.insert( dbg, dbgEffect )
						table.insert( dbg, msg )

						return
					end

					local value = eff.MetaData[ string.lower( param.Name ) ]

					if "Target Effect" == param.Name then
						local targetId = tonumber( value )
						if targetId then
							if targetId >= EHT.CONST.EFFECT_GROUP_ID_MIN and targetId <= EHT.CONST.EFFECT_GROUP_ID_MAX then
								value = targetId
							else
								local newTargetId = tonumber( idMap[targetId] )
								if newTargetId then
									value = newTargetId
								end
							end
						end
					end

					local sValue = param.Serializer( value )

					block = block .. string.format( "%s%s", EHT.Util.IntToBase88( paramIndex ), sValue )
				end
			end

			block = block .. "\""
		else
			block = string.format( "!!%d", numEffects )
		end

		local blockSize, messageSize = #block, #message

		if ( blockSize + blockPrefixSize ) > maxLength then
			message = message .. EHT.Util.ComputeCRC( message )
			table.insert( messages, message )
			table.insert( dbgBlocks, message )
			local fragmentIndex = 1

			repeat
				local blockPart = string.sub( block, 1, maxLength - blockFragmentPrefixSize - 1 )
				message = string.format( "%s%d,%d %s", blockFragmentPrefix, index, fragmentIndex, blockPart )
				message = message .. EHT.Util.ComputeCRC( message )
				table.insert( messages, message )
				table.insert( dbgBlocks, message )

				block = string.sub( block, #blockPart + 1 )
				fragmentIndex = fragmentIndex + 1
			until #block == 0

			message = blockPrefix
		elseif ( blockSize + messageSize ) > maxLength then
			message = message .. EHT.Util.ComputeCRC( message )
			table.insert( messages, message )
			table.insert( dbgBlocks, message )

			message = blockPrefix .. block
		else
			message = message .. block
		end
	end

	if blockPrefixSize < #message then
		message = message .. EHT.Util.ComputeCRC( message )
		table.insert( messages, message )
		table.insert( dbgBlocks, message )
		message = ""
	end

	table.insert( dbg, string.format( "NumBlocks( %s )", tostring( #messages ) ) )

	return messages
end

function EHT.Effect:DeserializeChatcast( player, data )
	local sender = player

	if nil == data then return nil, "Effect data is empty." end
	if type( data ) ~= "string" then return nil, "Effect data is an invalid data type." end

	local crcSignature = string.sub( data, -2, -1 )
	data = string.sub( data, 1, -3 )
	local crc = EHT.Util.ComputeCRC( data )

	if crcSignature ~= crc then
		return nil, "Please verify that you and the sender have the latest version of Essential Housing Tools."
	end

	local thirdparty = false
	if string.sub( data, 1, #EHT.CHATCAST_PREFIX ) == EHT.CHATCAST_PREFIX then
		data = string.sub( data, ( #EHT.CHATCAST_PREFIX + 1 ) )
	else
		return nil, "Effect data header is invalid."
	end

	local houseId, timestamp
	local dataIndex = string.find( data, " " )

	if nil == dataIndex or 1 >= dataIndex then return nil, "House Id is missing." end

	houseId = string.sub( data, 1, dataIndex - 1 )

	if string.find( houseId, "@" ) then
		thirdparty = true
		local atIndex = string.find( houseId, "@" )

		if not atIndex then
			houseId, player = nil, nil
		else
			player = string.sub( houseId, atIndex )
			houseId = tonumber( string.sub( houseId, 1, atIndex - 1 ) )
		end
	else
		houseId = tonumber( houseId )
	end

	if sender then sender = EHT.Util.Trim( sender ) end
	if player then player = EHT.Util.Trim( player ) end

	if not houseId then
		return nil, "Effect data \"House ID\" is invalid."
	elseif not player or "" == player or "@" ~= string.sub( player, 1, 1 ) then
		return nil, "Effect data \"Player\" is invalid."
	end

	dataIndex = dataIndex + 1

	local sVersion = string.sub( data, dataIndex, dataIndex )
	local version = EHT.Util.Base88ToInt( sVersion )

	if not version then
		return nil, "Effect data version is invalid."
	elseif version < CHATCAST_VERSION then
		return nil, string.format( "Effect data was sent with an OLDER version of Essential Housing Tools.\n(Protocol version: %s)", tostring( version or -1 ) )
	elseif version > CHATCAST_VERSION then
		return nil, string.format( "Effect data was sent with an NEWER version of Essential Housing Tools.\nPlease update to the latest version of Essential Housing Tools.\n(Protocol version: %s)", tostring( version or -1 ) )
	end

	dataIndex = dataIndex + 1
	local blockInfo =
	{
		isFragment = false,
	}

	if "," == string.sub( data, dataIndex, dataIndex ) then
		dataIndex = dataIndex + 1
	
		local separatorIndex = string.find( data, ",", dataIndex + 5 )
		local separatorIndex2 = string.find( data, " ", dataIndex + 5 )
		if not separatorIndex and not separatorIndex2 then
			return nil, "Effect data timestamp is invalid."
		end
		if not separatorIndex2 or ( separatorIndex and separatorIndex < separatorIndex2 ) then
			blockInfo.isFragment = true
		else
			separatorIndex = separatorIndex2
		end

		timestamp = EHT.Util.Base88ToInt( string.sub( data, dataIndex, separatorIndex - 1 ), true )
		if not timestamp then
			return nil, "Effect data timestamp is invalid."
		end
		dataIndex = separatorIndex + 1
	end

	if blockInfo.isFragment then
		local separatorIndex = string.find( data, ",", dataIndex )
		if not separatorIndex then
			return nil, "Effect fragment effect Id is invalid."
		end
		blockInfo.fragmentEffectId = string.sub( data, dataIndex, separatorIndex - 1 )
		if "" == blockInfo.fragmentEffectId then
			return nil, "Effect fragment effect Id is missing."
		end
		dataIndex = separatorIndex + 1

		local separatorIndex = string.find( data, " ", dataIndex )
		if not separatorIndex then
			return nil, "Effect fragment index is invalid."
		end
		blockInfo.fragmentIndex = string.sub( data, dataIndex, separatorIndex - 1 )
		if "" == blockInfo.fragmentIndex then
			return nil, "Effect fragment index is missing."
		end
		dataIndex = separatorIndex + 1
	end

	local zoneId = GetHouseZoneId( houseId )
	local collectibleId = GetCollectibleIdForHouse( houseId )
	if nil == zoneId or 0 >= zoneId then return nil, string.format( "House Id '%s' is invalid.", houseId or "nil" ) end

	local isLocal = string.lower( sender ) == string.lower( GetDisplayName() )
	if isLocal and not ENABLE_CHATCAST_REFLECTION then
		-- Prepare the next Chatcast message.
		EHT.Effect:SendNextChatcast()
		return "success", "Essential FX data has been sent."
	end

	if string.lower( player ) == string.lower( GetDisplayName() ) and not ENABLE_CHATCAST_REFLECTION then
		return nil, "Disregarding third-party sharing of your home's FX data."
	end

	houseName = GetCollectibleName( collectibleId )
	if "" == houseName then houseName = "home" end

	local newerTimestamp = EHT.Data.ValidateSharedEffectTimestamp( player, houseId, timestamp )
	if newerTimestamp then
		newerTimestamp = tonumber( newerTimestamp )

		if EHT.DEBUG_MODE then
			df( "Received TS: %d\nRecord TS: %d", timestamp or 0, newerTimestamp or 0 )
		end

		return nil, string.format( "Effect data is out-of-date. More recent data from %s was received.", newerTimestamp and GetDateStringFromTimestamp( newerTimestamp ) or "?" )
	end

	blockInfo.player = player
	blockInfo.houseId = houseId
	blockInfo.houseName = houseName
	blockInfo.timestamp = timestamp
	blockInfo.data = string.sub( data, dataIndex )

	local responseHouseName, responseMessage, responseOwner
	if blockInfo.isFragment then
		EHT.Effect.QueueChatcastFragmentDeserialization( blockInfo )
		responseHouseName, responseMessage, responseOwner = houseName, nil, player
	else
		responseHouseName, responseMessage, responseOwner = EHT.Effect.DeserializeChatcastBlock( blockInfo )
	end

	if isLocal and ENABLE_CHATCAST_REFLECTION then
		-- Repeated logic only for ChatCast reflection.
		EHT.Effect:SendNextChatcast()
	end

	return responseHouseName, responseMessage, responseOwner
end

function EHT.Effect.DeserializeChatcastBlock( blockInfo )
	local player = blockInfo.player
	local houseId = blockInfo.houseId
	local houseName = blockInfo.houseName
	local timestamp = blockInfo.timestamp
	local data = blockInfo.data
	local dataIndex = 1
	local exception

	local function GetNextBytes(length)
		if nil == dataIndex then
			return ""
		end

		local endDataIndex = dataIndex + length - 1
		local bytes = string.sub(data, dataIndex, endDataIndex)
		dataIndex = endDataIndex + 1

		return bytes
	end

	local function GetNextValue(length, context)
		local base88 = GetNextBytes(length)

		if "" == base88 or "!!" == string.sub(base88, 1, 2) then
			return base88
		else
			local value
			value, exception = EHT.Util.Base88ToInt(base88)
			if exception then
				if context then
					exception = string.format("%s (Record #%d, Effect #%d, Field '%s')", exception, context.record or 0, context.effectIndex or 0, context.field or "")
				end

				return ""
			end

			return tostring(value)
		end
	end

	local loops = 1
	local context =
	{
		record = 0,
		effectIndex = 0,
		field = "",
	}

	while 1000 >= loops do
		local value, effectTypeId, effectIndex, x, y, z, pitch, yaw, roll, sizeX, sizeY, sizeZ, colorR, colorG, colorB, alpha, contrast, groups

		context.record = loops
		context.effectIndex = 0

		context.field = "Effect Index/Type"
		value = GetNextValue( 5 )
		if "" == value then break end
		loops = loops + 1

		if "!!" ~= string.sub( value, 1, 2 ) then
			effectIndex, effectTypeId = EHT.Util.DecompressInteger( value, 1, 4 ), EHT.Util.DecompressInteger( value, 5, 8 )
			context.effectIndex = effectIndex

			context.field = "Position X/Position Y"
			value = GetNextValue( 7 )
			if "" == value then break end
			x, y = EHT.Util.DecompressInteger( value, 1, 6 ), EHT.Util.DecompressInteger( value, 7, 12 )

			context.field = "Position Z/Size X"
			value = GetNextValue( 7 )
			if "" == value then break end
			z, sizeX = EHT.Util.DecompressInteger( value, 1, 6 ), EHT.Util.DecompressInteger( value, 7, 12 )

			context.field = "Size Y/Size Z"
			value = GetNextValue( 7 )
			if "" == value then break end
			sizeY, sizeZ = EHT.Util.DecompressInteger( value, 1, 6 ), EHT.Util.DecompressInteger( value, 7, 12 )

			context.field = "Pitch/Yaw/Roll"
			value = GetNextValue( 7 )
			if "" == value then break end
			pitch, yaw, roll = EHT.Util.DecompressInteger( value, 1, 4 ), EHT.Util.DecompressInteger( value, 5, 8 ), EHT.Util.DecompressInteger( value, 9, 12 )
			pitch, yaw, roll = ( pitch or 0 ) / 10, ( yaw or 0 ) / 10, ( roll or 0 ) / 10

			context.field = "Color RGB"
			value = GetNextValue( 5 )
			if "" == value then break end
			colorR, colorG, colorB = EHT.Util.DecompressInteger( value, 1, 3 ), EHT.Util.DecompressInteger( value, 4, 6 ), EHT.Util.DecompressInteger( value, 7, 9 )
			colorR, colorG, colorB = ( colorR or 0 ) / 100, ( colorG or 0 ) / 100, ( colorB or 0 ) / 100

			context.field = "Alpha/Contrast"
			value = GetNextValue( 5 )
			if "" == value then break end
			alpha, contrast = ( EHT.Util.DecompressInteger( value, 1, 4 ) or 100 ) / 100, ( EHT.Util.DecompressInteger( value, 5, 8 ) or 100 ) / 100

			context.field = "Effect Group Bitmask"
			value = GetNextValue( 5 )
			if "" == value then break end
			groups = EHT.Housing.GetEffectGroupBit( EHT.Util.DecompressInteger( value, 1, 8 ) or 0 ) or 0

			context.field = nil
			local metaParamCount = 0
			local metaData, paramIndex, paramDef

			repeat
				paramIndex = GetNextBytes(1)
				if "" == paramIndex or "\"" == paramIndex then
					break
				end

				paramIndex = EHT.Util.Base88ToInt( paramIndex )
				paramDef = GetMetaParamByIndex( paramIndex )
				if not paramIndex or not paramDef then
					return nil, string.format( "Effect metadata parameter index is invalid: %s", tostring( paramIndex ) )
				end

				if not metaData then
					metaData = { }
				end

				local value
				value, dataIndex = paramDef.Deserializer( data, dataIndex )
				metaData[ string.lower( paramDef.Name ) ] = value
				metaParamCount = metaParamCount + 1
			until 100 < metaParamCount

			local eff = EHT.Effect:New( effectTypeId, effectIndex, true )
			if eff then
				eff.SizeX, eff.SizeY, eff.SizeZ = sizeX, sizeY, sizeZ
				eff.ColorR, eff.ColorG, eff.ColorB = colorR, colorG, colorB
				eff.Alpha, eff.Contrast = alpha or 1, contrast or 1
				eff.X, eff.Y, eff.Z, eff.Pitch, eff.Yaw, eff.Roll = x, y, z, math.rad( pitch ), math.rad( yaw ), math.rad( roll )
				eff.Groups = groups
				eff.MetaData = metaData

				EHT.Data.CacheEffectRecord( player, houseId, tonumber( effectIndex ), eff )
			end
		else
			-- Read the remainder of the "Total Number of Effects" final value (if any),
			-- remove the "!!" prefix and convert to an integer.

			value = value .. GetNextValue( 5 )
			value = string.sub( value, 3 )
			value = tonumber( value )

			if nil ~= value then
				EHT.Data.CullEffectRecords( player, houseId, value + 1 )
			end

			-- Assumption is that this block is the final block of the entire chain.
			break
		end

	end

	if exception then
		return nil, string.format( "Effect data was invalid or incomplete: %s", tostring( exception ) )
	end

	local currentHouseOwner, currentHouseId = EHT.Housing.GetHouseOwner()
	if string.lower( currentHouseOwner ) == string.lower( player ) and tostring( currentHouseId ) == tostring( houseId ) then
		EVENT_MANAGER:UnregisterForUpdate( "EHTEffectsRefreshAll" )
		EVENT_MANAGER:RegisterForUpdate( "EHTEffectsRefreshAll", EFFECT_REFRESH_DELAY, EHT.EffectUI.RefreshAll )
	end

	return houseName, nil, player
end

do
	local queue = { }
	
	local function FragmentComparator( left, right )
		return left.index < right.index
	end

	function EHT.Effect.ProcessChatcastFragmentDeserializationQueue()
		local currentTimestamp = GetTimeStamp()
		local pendingQueueEntries = 0

		for queueEntryKey, queueEntry in pairs( queue ) do
			if not queueEntry.processed and currentTimestamp >= queueEntry.processBy then
				local fragments = queueEntry.fragments
				local orderedFragments = { }

				for fragmentIndex, fragmentData in pairs( fragments ) do
					table.insert( orderedFragments, { index = fragmentIndex, data = fragmentData } )
				end

				if NonContiguousCount( fragments ) == #orderedFragments then
					local aggregateBlockInfo = EHT.Util.CloneTable( queueEntry.blockInfo )
					aggregateBlockInfo.isFragment = nil
					aggregateBlockInfo.data = ""

					table.sort( orderedFragments, FragmentComparator )
					for fragmentIndex, fragmentData in ipairs( orderedFragments ) do
						aggregateBlockInfo.data = aggregateBlockInfo.data .. fragmentData.data
					end

					local houseName, message, player = EHT.Effect.DeserializeChatcastBlock( aggregateBlockInfo )
					queueEntry.processed = true
				end
			end

			if currentTimestamp >= queueEntry.expiresBy then
				queue[queueEntryKey] = nil
			else
				pendingQueueEntries = pendingQueueEntries + 1
			end
		end

		if 0 == pendingQueueEntries then
			EVENT_MANAGER:UnregisterForUpdate( "EHT.Effect.ProcessChatcastFragmentDeserializationQueue" )
		end
	end

	function EHT.Effect.QueueChatcastFragmentDeserialization( blockInfo )
		EVENT_MANAGER:UnregisterForUpdate( "EHT.Effect.ProcessChatcastFragmentDeserializationQueue" )

		local currentTimestamp = GetTimeStamp()
		local fragmentIndex = tonumber( blockInfo.fragmentIndex )
		local data = blockInfo.data
		local queueEntryKey = string.format( "%d_%s_%d", tonumber( blockInfo.houseId ), tostring( blockInfo.player ), tonumber( blockInfo.fragmentEffectId ) )
		local queueEntry = queue[queueEntryKey]

		if queueEntry and queueEntry.expiresBy <= currentTimestamp then
			queueEntry = nil
		end

		if not queueEntry then
			queueEntry =
			{
				blockInfo = blockInfo,
				fragments = { },
			}
			queue[queueEntryKey] = queueEntry
		end

		queueEntry.processed = false
		queueEntry.processBy = currentTimestamp + 5
		queueEntry.expiresBy = currentTimestamp + 30
		queueEntry.fragments[fragmentIndex] = data

		EVENT_MANAGER:RegisterForUpdate( "EHT.Effect.ProcessChatcastFragmentDeserializationQueue", 5000, EHT.Effect.ProcessChatcastFragmentDeserializationQueue )
	end
end

function EHT.Effect:ProcessInboundChatcast( player, data, source )
	local houseName, message, owner = EHT.Effect:DeserializeChatcast( player, data )
	local success = false

	if houseName and message then
		message = string.format( "|c00eeff%s|r", message )
	elseif message then
		message = string.format( "|cffaa00An invalid Essential Housing Tools FX update was received via %s from |r%s\n%s", source or "", player or "(unknown)", message )
	elseif houseName then
		if string.lower( owner ) ~= string.lower( player ) then 
			message = string.format( "Receiving Essential FX updates via %s for |c00ccff%s|r's |c00ffcc%s|r (by %s)", source or "", owner or "", houseName or "home", player or "" )
		else
			message = string.format( "Receiving Essential FX updates via %s for |c00ccff%s|r's |c00ffcc%s|r", source or "", owner or "", houseName or "home" )
		end

		success = true
	end

	local notification = message
	local suppression = success and false ~= EHT.SavedVars.SuppressDuplicateNotifications

	if suppression then
		local recents = EHT.SavedVars.RecentNotifications
		if "table" ~= type( recents ) then
			recents = { }
			EHT.SavedVars.RecentNotifications = recents
		end

		local now = GetTimeStamp()
		local lcm = string.lower( message )
		local lastShown = recents[ lcm ]

		if not lastShown or ( now - lastShown ) >= ( 60 * 60 * 24 ) then
			recents[ lcm ] = now
		else
			notification = nil
		end
	end

	if "Guild" == source and EHT.GetSetting( "SuppressGuildShareNotifications" ) then
		notification = nil
	end

	if notification and success and true == EHT.SavedVars.ShowEssentialEffectsReceivedOSD then
		EHT.UI.DisplayNotification( notification )
	end

	if suppression and notification then
		notification = notification .. "\n(Repeats of this message will be suppressed for 1 day)"
	end

	if notification and true == EHT.SavedVars.ShowEssentialEffectsReceived then
		d( notification )
	end

	return success, message
end

do
	local chatcastMessages
	local chatcastIndex = 0

	function EHT.Effect:GetPendingChatcastMessages()
		return chatcastMessages, chatcastIndex
	end

	function EHT.Effect:InitializeChatcast( channelId, houseId, owner )
		if not houseId and ( not owner or "" == owner ) and not EHT.Housing.IsOwner() then
			EHT.UI.ShowAlertDialog( "Not the homeowner", "You must be in a home that you own in order to share that home's Essential Effects(TM)." )
			return
		end

		local messages = self:SerializeChatcast( false, houseId, owner )

		if nil == messages or 0 >= #messages then
			EHT.UI.ShowAlertDialog( "No effects to send", "There are no Essential Effects(TM) to share." )
			return
		end

		if nil ~= channelId then CHAT_SYSTEM:SetChannel( channelId ) end

		chatcastMessages = messages
		chatcastIndex = 1

		EHT.Effect:SendNextChatcast()
	end

	function EHT.Effect:SendNextChatcast()
		EVENT_MANAGER:RegisterForUpdate( "EHT.Effect:SendNextChatcast", 1000, function() EHT.Effect:SendNextChatcastInt() end )
	end

	function EHT.Effect:SendNextChatcastInt()
		EVENT_MANAGER:UnregisterForUpdate( "EHT.Effect:SendNextChatcast" )

		if nil == chatcastMessages then return end

		if chatcastIndex > #chatcastMessages then
			EHT.UI.HideTutorialDialog()
			EHT.UI.ShowAlertDialog(
				"Done",
				"Done!\n\n" ..
				"Essential Effects(TM) data was sent to any player that just received your chat message(s).\n\n" ..
				"If a player did not properly receive this data, please make sure that " ..
				"both you and the other player are using the latest version of " ..
				"Essential Housing Tools." )

			chatcastMessages, chatcastIndex = nil, 0
			return
		end

		EHT.UI.ShowTutorialDialog(
			CHAT_SYSTEM.textEntry.control:GetOwningWindow(),
			"Sharing Essential Effects(TM)",
			string.format( "Please press |cffff00ENTER|r to send your\nEssential Effects(TM) data.\n\nThis is message |cffff00%d|r of |cffff00%d|r.", chatcastIndex, #chatcastMessages ),
			"",  "Cancel",
			nil,
			function()
				chatcastMessages, chatcastIndex = nil, 0
				CHAT_SYSTEM:CloseTextEntry(false)
			end )

		CHAT_SYSTEM:Maximize()
		StartChatInput( chatcastMessages[ chatcastIndex ] )
		zo_callLater( function() StartChatInput( "" ) end, 500 )

		chatcastIndex = chatcastIndex + 1
	end
end

function EHT.Effect:QueueGuildcast( houseId, owner, guilds )
	local messages = self:SerializeChatcast( false, houseId, owner, true )
	local estDuration = 0

	if messages then
		EHT.Guilds:PreserveGuildMemberNotes()

		for index, message in ipairs( messages ) do
			estDuration = estDuration + ( EHT.Guilds:SetGuildMemberNotes( message, guilds ) or 0 )
		end
	end

	return estDuration
end

SLASH_COMMANDS[ "/cleanfx" ] = function( params )
	local owner, houseId = EHT.Housing.GetHouseOwner()
	local house, effects = EHT.Data.GetCurrentHouseOrGuestHouse( houseId, player, false )
	local numEffects = effects and #effects or 0

	if numEffects == 0 then
		d( "There are no effects for this house." )
		return
	end

	local numEffectsDeleted = 0

	for index = numEffects, 1, -1 do
		local effect = effects[index]
		if effect and not effect.EffectType or not EHT.EffectType:GetByIndex( effect.EffectType ) then
			-- This effect's effect type ID no longer valid; delete the effect.
			table.remove( effects, index )
			numEffectsDeleted = numEffectsDeleted + 1
		end
	end

	if numEffectsDeleted > 0 then
		df( "Removed %d invalid effect database record%s.\nReloading effects...", numEffectsDeleted, numEffectsDeleted == 1 and "" or "s" )
		EHT.EffectUI.RefreshAll()
	else
		d( "No invalid effect records found.\nClean complete." )
	end
end

SLASH_COMMANDS[ "/sharefx" ] = function( params )
	local help = "\n\n" ..
		"|cffffffCommands:\n" ..
		"|c00ffff/sharefx mail, @name|cffffff\n" ..
		"|c00ffff/sharefx chat, house_name, [owner_@name]|cffffff\n" ..
		"|c00ffff/sharefx guild, house_name, guild_name|cffffff\n" ..
		"\n" ..
		"|cffffffExamples:\n" ..
		"|c009999/sharefx mail, @cardinal05|cffffff\n" ..
		"|c009999/sharefx chat, linchal|cffffff\n" ..
		"|c009999/sharefx chat, grand topal, @cardinal05|cffffff\n" ..
		"|c009999/sharefx guild, psijic villa, Divine Design|cffffff\n"

	local mode, house, option = string.match( params, "([^,]*),([^,]*),*([^,]*)" )

	mode = string.lower( EHT.Util.Trim( mode or "" ) )
	house = string.lower( EHT.Util.Trim( house or "" ) )
	option = string.lower( EHT.Util.Trim( option or "" ) )

	if "mail" == mode then
		if "" == house then
			d( "@Player name is missing." )
			return false
		else
			return EHT.Effect.MailcastCommand( house )
		end
	end

	local houses = EHT.Housing.FindHousesByName( house )
	local houseId, houseName

	if houses and 0 < #houses then
		houseId, houseName = houses[1].Id, houses[1].Name
	end

	if not houseId then
		df( "House name is missing or invalid.%s", help )
		return false
	end

	if "chat" == mode then
		if "" ~= option then
			EHT.Effect:InitializeChatcast( nil, houseId, option )
		else
			EHT.Effect:InitializeChatcast( nil, houseId )
		end

		return true
	end

	if "guild" == mode then
		local guild = EHT.Guilds:GetGuildByName( option )

		if not guild then
			df( "Guild name is missing or invalid.%s", help )
			return false
		end

		local guilds = { }
		guilds[ guild.Name ] = true

		local estDuration = EHT.Effect:QueueGuildcast( houseId, nil, guilds )
		df( "Sharing FX for %s (%d) with %s (est. %s min)...", houseName, houseId or -1, guild.Name, tostring( ( estDuration or 0 ) / 60 ) )

		return true
	end

	df( "Invalid command syntax.%s", help )
	return false
end

function EHT.Effect:PublishFX( houseId, suppressMessages )
	if not EssentialHousingHub:CheckCommunityConnection( suppressMessages ) then
		return false, "Publishing requires the Essential Housing Community companion add-on to be enabled."
	end

	if not houseId then
		houseId = EHT.Housing.GetHouseId()

		if not EHT.Housing.IsOwner() or not houseId then
			local message = "You may only publish FX for a home that you own.\n\n" ..
				"Note that any of your homes' FX may be published at any time directly from the Housing Hub."

			if not suppressMessages then
				EHT.UI.ShowAlertDialog( "", message )
			end

			return false, message
		end
	end

	local effects = EHT.Util.CloneTable( EHT.Data.GetEffectRecords( houseId, GetDisplayName() ) )
	effects = effects or { }

	local success, message = EssentialHousingHub:SetCommunityFXRecord( houseId, effects )
	if not success and message then
		if "Record size too large." == message then
			local message = "Publishing would exceed the maximum amount of data allowed.\n\n" ..
				"Please unpublish one or more home's FX, then try again."

			if not suppressMessages then
				EHT.UI.ShowAlertDialog( "", message )
			end

			return false, message
		end
	end

	return success
end

function EHT.Effect:UnpublishFX( houseId )
	if not EssentialHousingHub:CheckCommunityConnection() then
		return false, "Unpublishing requires the Essential Housing Community companion add-on to be enabled."
	end

	if not houseId then
		houseId = EHT.Housing.GetHouseId()

		if not EHT.Housing.IsOwner() or not houseId then
			EHT.UI.ShowAlertDialog( "", "You may only unpublish FX for a home that you own.\n\n" ..
				"Note that any of your homes' FX may be unpublished at any time directly from the Housing Hub." )
			return false
		end
	end

	if not EssentialHousingHub:SetCommunityFXRecord( houseId, nil ) then
		return false
	end

	return true
end

function EHT.Effect:ToggleMapcast()
	if false ~= EHT.SavedVars.EnableEffectsMapcast then
		EHT.SavedVars.EnableEffectsMapcast = false
	else
		EHT.SavedVars.EnableEffectsMapcast = true
	end

	return EHT.SavedVars.EnableEffectsMapcast
end

function EHT.Effect:OpenMailbox()
	if not SCENE_MANAGER:IsShowing( "mailInbox" ) and not SCENE_MANAGER:IsShowing( "mailSend" ) then
		RequestOpenMailbox()
	end
end

function EHT.Effect:CloseMailbox()
	if not SCENE_MANAGER:IsShowing( "mailInbox" ) and not SCENE_MANAGER:IsShowing( "mailSend" ) then
		CloseMailbox()
	end
end

function EHT.Effect:DeleteMailcasts()
	EVENT_MANAGER:UnregisterForUpdate( "EHT.Effect:DeleteMailcasts" )

	if EHT.DEBUG_MODE then
		d( "DEBUG: DeleteMailcasts()" )
	end

	local mailIds = EHT.DeleteMailcastIds

	if mailIds and 0 < #mailIds then
		if false == EHT.SavedVars.AutoDeleteMailcasts then
			EHT.DeleteMailcastIds = { }
			return
		end

		if EHT.DEBUG_MODE then
			df( "DEBUG: Queued ID count: %d", #mailIds )
		end

		local mailId = table.remove( mailIds, 1 )

		if mailId then
			if EHT.DEBUG_MODE then
				df( "DEBUG: Deleting Mail ID %s.", string.fromId64( mailId ) or "" )
			end

			self:OpenMailbox()
			DeleteMail( mailId )
			self:CloseMailbox()
		end

		EVENT_MANAGER:RegisterForUpdate( "EHT.Effect:DeleteMailcasts", 10000, function() self:DeleteMailcasts() end )
	end
end

function EHT.Effect:IsMailcastId( mailId )
	local senderDisplayName, _, subject, icon, unread, fromSystem, fromCustomerService, returned, numAttachments, attachedMoney, codAmount, expiresInDays, secsSinceReceived = GetMailItemInfo( mailId )

	if senderDisplayName and "" ~= senderDisplayName and "@" == string.sub( senderDisplayName, 1, 1 ) and not fromSystem and not fromCustomerService and not returned then
		if string.lower( subject ) == string.lower( MAILCAST_SUBJECT ) then
			if EHT.DEBUG_MODE then
				df( "DEBUG: Mail Id: %s", string.fromId64( mailId ) or "" )
				df( "DEBUG: Sender: %s", senderDisplayName or "" )
				df( "DEBUG: Subject: %s", subject or "" )
			end

			return true
		end
	end

	return false
end

function EHT.Effect:ProcessMailcasts()
	if EHT.DEBUG_MODE then
		d( "DEBUG: ProcessMailcasts()" )
	end

	EVENT_MANAGER:UnregisterForUpdate( "EHT.Effect:ProcessMailcasts" )

	local mailIds = EHT.ProcessMailcastIds
	if mailIds and mailIds[1] then
		local mailId = table.remove( mailIds, 1 )

		if EHT.DEBUG_MODE then
			df( "DEBUG: Processing Mail ID %s", string.fromId64( mailId ) or "" )
		end

		self:OpenMailbox()
		RequestReadMail( mailId )
		self:CloseMailbox()
	else
		if EHT.DeleteMailcastIds and EHT.DeleteMailcastIds[1] then
			EHT.Effect:DeleteMailcasts()
		end
	end
end

function EHT.Effect:ProcessMailInbox()
	if EHT.DEBUG_MODE then
		df( "DEBUG: Effect:ProcessMailInbox( %s )", string.fromId64( mailId ) or "" )
	end

	EVENT_MANAGER:UnregisterForUpdate( "EHT.Effect:ProcessMailInbox" )

	if not EHT.ProcessMailcastIds then EHT.ProcessMailcastIds = { } end
	if not EHT.DeleteMailcastIds then EHT.DeleteMailcastIds = { } end

	local queue = EHT.ProcessMailcastIds
	local mailId

	repeat
		mailId = GetNextMailId( mailId )
		if mailId then
			if EHT.Effect:IsMailcastId( mailId ) then
				local exists = false

				for _, id in ipairs( queue ) do
					if id == mailId then
						exists = true
						break
					end
				end

				if not exists then
					table.insert( queue, mailId )
				end
			end
		end
	until not mailId

	if EHT.DEBUG_MODE then
		d( "DEBUG: Inbox processing complete." )
		d( "DEBUG: ProcessMailcastIds:" )
		d( EHT.ProcessMailcastIds )
	end

	-- self:CloseMailbox()

	if 0 < #EHT.ProcessMailcastIds then
		EVENT_MANAGER:RegisterForUpdate( "EHT.Effect:ProcessMailcasts", 1000, function() EHT.Effect:ProcessMailcasts() end )
	end
end

function EHT.Effect:ProcessMailItem( mailId )
	if EHT.DEBUG_MODE then
		d( "DEBUG: Effect:ProcessMailItem()" )
		df( "DEBUG: Mail ID %s", string.fromId64( mailId ) or "" )
	end

	if not EHT.Effect:IsMailcastId( mailId ) or InvalidMailIds[ string.fromId64( mailId ) ] then
		return
	end

	self:OpenMailbox()
	local body = ReadMail( mailId )
	self:CloseMailbox()

	local sender = GetMailSender( mailId )
	if sender and "" ~= sender and "@" == string.sub( sender, 1, 1 ) and body and "" ~= body then
		if EHT.DEBUG_MODE then
			df( "DEBUG: Body:\n%s", body )
		end

		local dataIndex = string.find( body, CHATCAST_PREFIX )
		if dataIndex then
			body = string.sub( body, dataIndex )

			local success, message = EHT.Effect:ProcessInboundChatcast( sender, body, "Mail" )
			if not success then InvalidMailIds[ string.fromId64( mailId ) ] = true end

			if not EHT.DeleteMailcastIds then EHT.DeleteMailcastIds = { } end
			table.insert( EHT.DeleteMailcastIds, mailId )

			if EHT.DEBUG_MODE then
				df( "DEBUG: Processed Mail ID %s", string.fromId64( mailId ) or "" )
				df( "DEBUG: Success: %s", tostring( success ) or "nil" )
			end
		end
	end

	EVENT_MANAGER:RegisterForUpdate( "EHT.Effect:ProcessMailcasts", 1000, function() EHT.Effect:ProcessMailcasts() end )
end

function EHT.Effect:GetMailcastQueue()
	local queue = EHT.MailcastQueue
	if not queue then
		queue = { }
		EHT.MailcastQueue = queue
	end

	return queue
end

function EHT.Effect:ClearMailcastQueue()
	EHT.MailcastQueue = { }
end

function EHT.Effect:Mailcast( player, suppressDialogs )
	if not player or "" == player or "@" ~= string.sub( player, 1, 1 ) then
		return false, "Please specify a valid @Player name."
	end

	local queue = EHT.Effect:GetMailcastQueue()

	if not EHT.Housing.IsHouseZone() or not EHT.Housing.IsOwner() then
		return false, "You must be in one of your homes to mail FX."
	end

	local data = EHT.Effect:SerializeChatcast( true )
	if nil == data or 0 >= #data then
		return false, "There are no effects in the current house."
	end

	local task = {
		To = player,
		Sent = GetTimeStamp(),
		HouseId = EHT.Housing.GetHouseId(),
		CurrentIndex = 0,
		Data = data,
		Status = "Queued",
		SuppressDialogs = suppressDialogs,
	}

	if EHT.DEBUG_MODE then
		d( "DEBUG: Queue task data:" )
		d( task )
	end

	table.insert( queue, task )
	EHT.Effect:ScheduleMailcastProcessor()

	return true
end

function EHT.Effect.MailcastCommand( player )
	local success, message = EHT.Effect:Mailcast( player, true )
	if not success then
		df( "Mail FX failed:\n%s", message or "Unknown exception." )
	else
		df( "Mail FX queued to send to %s.", player or "" )
	end
	return success
end
SLASH_COMMANDS[ "/mailfx" ] = EHT.Effect.MailcastCommand

function EHT.Effect:ScheduleMailcastProcessor()
	EVENT_MANAGER:UnregisterForUpdate( "EHT.Effect.MailcastQueueProcessor" )
	EVENT_MANAGER:RegisterForUpdate( "EHT.Effect.MailcastQueueProcessor", 1000, EHT.Effect.MailcastQueueProcessor )
	EHT.UI.ShowSendingMapcast( "Mail FX", true )
end

function EHT.Effect:UnscheduleMailcastProcessor()
	EVENT_MANAGER:UnregisterForUpdate( "EHT.Effect.MailcastQueueProcessor" )
	EHT.Effect:ClearMailcastQueue()
end

function EHT.Effect.MailcastQueueProcessor()
	local queue = EHT.Effect:GetMailcastQueue()

	if EHT.DEBUG_MODE then
		d( "DEBUG: EHT.Effect.MailcastQueueProcessor" )
	end

	if queue and queue[1] then
		local task = queue[1]
		local ft = FrameTime
		local message

		if "Queued" == task.Status then
			local currentIndex = task.CurrentIndex + 1
			local to, subject, body = task.To, MAILCAST_SUBJECT, task.Data[currentIndex]

			if body then
				EHT.UI.ShowSendingMapcast( "Mail FX", true )

				task.CurrentIndex, task.Status, task.Timeout = currentIndex, "Sending", ft + MAILCAST_SEND_TIMEOUT

				EHT.Effect:OpenMailbox()
				SendMail( to, subject, body )
				zo_callLater( function() EHT.Effect:CloseMailbox() end, 1000 )

				if EHT.DEBUG_MODE then
					df( "DEBUG: Sending email %d", currentIndex )
					df( "DEBUG: To: %s\nDEBUG: Subject: %s\nDEBUG: Body:\n%s", to, subject, body )
				end
			else
				message = string.format( "Effects data mailed to %s.", to )
				task.Status = "Complete"
				table.remove( queue, 1 )
			end
		elseif "Failed" == task.Status then
			message = string.format( "Failed to finish mailing FX data to %s:\n%s", task.To or "?", task.Reason or "Unknown exception" )
			table.remove( queue, 1 )
		elseif task.Timeout and task.Timeout < ft then
			message = string.format( "Failed to finish mailing FX data to %s:\n%s", task.To or "?", "Server is not responding or timed out." )
			table.remove( queue, 1 )
		else
			EHT.UI.ShowSendingMapcast( "Mail FX", true )
		end

		if message then
			d( message )

			if not task.SuppressDialogs then
				EHT.UI.ShowAlertDialog( "", message )
			end
		end
	else
		EHT.Effect:UnscheduleMailcastProcessor()
	end
end

function EHT.Effect:AddParticle( textureFile, offsetX, offsetY, offsetZ, offsetPitch, offsetYaw, offsetRoll, offsetR, offsetG, offsetB, offsetA, offsetSizeX, offsetSizeY, useDepthBuffer, isAdditive, wrapTexture )
	if nil == useDepthBuffer then useDepthBuffer = true end
	if nil == isAdditive then isAdditive = false end

	local p = EHT.Particle:New(self, textureFile)
	table.insert(self.Particles, p)
	local index = #self.Particles

	p.EffIndex = index
	p:SetOffsets( offsetX, offsetY, offsetZ, offsetPitch, offsetYaw, offsetRoll, offsetR, offsetG, offsetB, offsetA, offsetSizeX, offsetSizeY )
	p:SetUseDepthBuffer( useDepthBuffer )
	p:SetAdditive( isAdditive )
	p:SetPositionAndOrientation( self.X, self.Y, self.Z, self.Pitch, self.Yaw, self.Roll )
	if self.CameraFacing then p:SetCameraFacing( true ) end
	if nil ~= wrapTexture then p:SetTextureWrapping( wrapTexture ) end
	p:RefreshHidden()

	return p
end

function EHT.Effect:AddParticle2D( ... )
	local p = self:AddParticle( ... )
	if p then
		p.Texture:Destroy3DRenderSpace()
		p.Texture:ClearAnchors()
		p.Texture:SetParent( GetParticleWindow2D() )
		p.Texture:SetAnchorFill()
		p.Texture:SetMouseEnabled( false )
	end

	return p
end

function EHT.Effect:CloneParticle( particle )
	if not particle then return end

	local p = self:AddParticle( particle:GetTextureFile() )
	p:CopyFrom( particle )
	if particle.CameraFacing then p:SetCameraFacing( true ) end
	p:AutoUpdateDrawLevel( true )

	return p
end

function EHT.Effect:AddScaledParticle( textureFile, relativeSizeX, relativeSizeY, relativeOffsetX, relativeOffsetY, offsetR, offsetG, offsetB, offsetA, blendMode )
	local index = #self.Particles + 1
	local p = EHT.Particle:New( self, textureFile )
	table.insert( self.Particles, p )

	p.EffIndex = index
	p:SetPositionOffsets( 0, 0, 0 )
	p:SetOrientationOffsets( 0, 0, 0 )
	p:SetColorOffsets( offsetR, offsetG, offsetB, offsetA )
	p:SetSizeOffsets( 1, 1 )
	p:SetUseDepthBuffer( true )
	if 2 == blendMode then
		p:SetAdditive( true )
	elseif 3 == blendMode then
		p:SetDodge( true )
	end
	p:SetTextureWrapping( false )
	p:SetScale( relativeSizeX, relativeSizeY, relativeOffsetX, relativeOffsetY )
	p:RefreshHidden()

	return p
end

function EHT.Effect:AreParticlesReady()
	for index = 1, #self.Particles do
		local p = self.Particles[index]
		if p and not p:IsTextureLoaded() then return false end
	end

	return true
end

function EHT.Effect:RandomlyDistributeParticles()
	local width, height = self:GetSize()
	local maxParticles = #self.Particles

	for index = 1, maxParticles do
		self.Particles[index]:SetPositionOffsets( -0.5 * width + math.random() * width, height * ( index / maxParticles ), -0.5 * width + math.random() * width )
	end
end

function EHT.Effect:Reset( ... )
	local effectState = self.EffectState
	local initializedNow = effectState == EFFECT_STATE_INITIALIZED
	if not self.Resetting and (initializedNow or effectState == EFFECT_STATE_ACTIVE) then
		self.Resetting = true
		self:SetState(EFFECT_STATE_RESETTING)

		local resetFunction = self.EffectType.Reset
		if resetFunction then
			resetFunction(self, ...)
		end

		self:SetState(EFFECT_STATE_ACTIVE)
		self.Resetting = nil

		if initializedNow then
			self:Update()
			self:Reset()
		end
	end
--	elseif EHT.IsDev then df("[%.3fms] '%s' requested reset but isn't yet ready.", GetGameTimeMilliseconds() / 1000, self.EffectType.Name) end
end

function EHT.Effect:UpdateDependencies()
	if CurrentEditorEffect == self then
		local ft = FrameTime
		if self.Record and ( not self.LastChanged or self.LastChanged == ft or 500 < ( ft - self.LastChanged ) ) then
			self.LastChanged = ft
			EHT.GetEffectEditor():UpdateEditor()
		end
	end
end

function EHT.Effect:UpdateRecord( canSnap )
	if self.Record then
		local rec = self.Record
		local id = rec.Id
		local eType = EHT.EffectType:GetByIndex( rec.EffectType )
		local after, before, link

		link = EHT.Housing.GenerateEffectLink( rec.Id, rec.EffectType, eType and eType.Name or "" )
		before = { Id = id, EffectType = rec.EffectType, Link = link, X = rec.X, Y = rec.Y, Z = rec.Z, Pitch = rec.Pitch, Yaw = rec.Yaw, Roll = rec.Roll, SizeX = rec.SizeX, SizeY = rec.SizeY, SizeZ = rec.SizeZ, Color = rec.Color, Alpha = rec.Alpha, Contrast = rec.Contrast, MetaData = EHT.Util.CloneTable( rec.MetaData ), Groups = rec.Groups }
		EHT.Data.UpdateEffectRecord( rec, self )
		after = { Id = id, EffectType = rec.EffectType, Link = link, X = rec.X, Y = rec.Y, Z = rec.Z, Pitch = rec.Pitch, Yaw = rec.Yaw, Roll = rec.Roll, SizeX = rec.SizeX, SizeY = rec.SizeY, SizeZ = rec.SizeZ, Color = rec.Color, Alpha = rec.Alpha, Contrast = rec.Contrast, MetaData = EHT.Util.CloneTable( rec.MetaData ), Groups = rec.Groups }

		if canSnap then
			EHT.Handlers.OnFurnitureEditCommitted( after, before )
		else
			EHT.Handlers.OnFurnitureChanged( after, before )
		end
	end
end

function EHT.Effect:SetIntervalOffset( minOffset, maxOffset, dynamicRange )
	minOffset = tonumber( minOffset ) or 0
	maxOffset = math.max( tonumber( maxOffset ) or 60000, minOffset + 1 )
	dynamicRange = math.abs( tonumber( dynamicRange ) or 0 )

	self.IntervalOffset = math.random( minOffset, maxOffset )
	self.IntervalOffsetRange = dynamicRange
end

function EHT.Effect:GetIntervalOffset()
	local offset, range = self.IntervalOffset, self.IntervalOffsetRange
	return offset + ( 0 >= range and 0 or ( GetLoopInterval( 60000 ) * range ) )
end

function EHT.Effect:GetBounds()
	return self:GetParticleBounds()
end

function EHT.Effect:GetParticlePositionRange()
	local minX, minY, minZ, maxX, maxY, maxZ

	if self.Emitter then
		for _, p in pairs( self.Emitter.ActiveParticles ) do
			if p.Active then
				local x, y, z = p:GetPosition()

				if not minX or minX > x then minX = x end
				if not minY or minY > y then minY = y end
				if not minZ or minZ > z then minZ = z end

				if not maxX or maxX < x then maxX = x end
				if not maxY or maxY < y then maxY = y end
				if not maxZ or maxZ < z then maxZ = z end
			end
		end
	elseif self.Emitters then
		for _, emitter in pairs( self.Emitters ) do
			for _, p in pairs( emitter.ActiveParticles ) do
				if p.Active then
					local x, y, z = p:GetPosition()

					if not minX or minX > x then minX = x end
					if not minY or minY > y then minY = y end
					if not minZ or minZ > z then minZ = z end

					if not maxX or maxX < x then maxX = x end
					if not maxY or maxY < y then maxY = y end
					if not maxZ or maxZ < z then maxZ = z end
				end
			end
		end
	else
		for _, p in pairs( self.Particles ) do
			if p.Active then
				local x, y, z = p:GetPosition()

				if not minX or minX > x then minX = x end
				if not minY or minY > y then minY = y end
				if not minZ or minZ > z then minZ = z end

				if not maxX or maxX < x then maxX = x end
				if not maxY or maxY < y then maxY = y end
				if not maxZ or maxZ < z then maxZ = z end
			end
		end
	end

	return minX, minY, minZ, maxX, maxY, maxZ
end

function EHT.Effect:GetParticleBounds( includeInvisible )
	local maxX, maxY, maxZ, minX, minY, minZ = 0, 0, 0, 999999, 999999, 999999
	local p, x, y, z, x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4, sizeX, sizeY, pitch, yaw, roll

	for index, p in pairs( self.Particles ) do
		if includeInvisible or not p:GetHidden() then
			x, y, z, pitch, yaw, roll = p:GetPositionAndOrientation()
			if 0 == pitch % ( 0.5 * math.pi ) then pitch = pitch + math.deg( 1 ) end

			sizeX, sizeY = p:GetSize()
			sizeX, sizeY = 0.5 * sizeX, 0.5 * sizeY

			x1, y1, z1 = -sizeX, -sizeY, 0
			x2, y2, z2 =  sizeX, -sizeY, 0
			x3, y3, z3 = -sizeX,  sizeY, 0
			x4, y4, z4 =  sizeX,  sizeY, 0

			x1, y1, z1 = EHT.World.Rotate( x1, y1, z1, pitch, yaw, roll )
			x2, y2, z2 = EHT.World.Rotate( x2, y2, z2, pitch, yaw, roll )
			x3, y3, z3 = EHT.World.Rotate( x3, y3, z3, pitch, yaw, roll )
			x4, y4, z4 = EHT.World.Rotate( x4, y4, z4, pitch, yaw, roll )

			x1, y1, z1 = x + x1, y + y1, z + z1
			x2, y2, z2 = x + x2, y + y2, z + z2
			x3, y3, z3 = x + x3, y + y3, z + z3
			x4, y4, z4 = x + x4, y + y4, z + z4

			maxX, maxY, maxZ = math.max( maxX, x1, x2, x3, x4 ), math.max( maxY, y1, y2, y3, y4 ), math.max( maxZ, z1, z2, z3, z4 )
			minX, minY, minZ = math.min( minX, x1, x2, x3, x4 ), math.min( minY, y1, y2, y3, y4 ), math.min( minZ, z1, z2, z3, z4 )
		end
	end

	return minX, minY, minZ, maxX, maxY, maxZ
end

function EHT.Effect:GetLogicalBounds( overrideSizeX, overrideSizeY, overrideSizeZ )
	local posX, posY, posZ = self:GetPosition()
	local radX, radY, radZ = self:GetOrientation()
	local sizeX, sizeY, sizeZ = self:GetSize()

	radX, radY, radZ = radX or 0, radY or 0, radZ or 0
	sizeX, sizeY, sizeZ = overrideSizeX or sizeX, overrideSizeY or sizeY, overrideSizeZ or sizeZ
	sizeX, sizeY, sizeZ = 0.5 * sizeX, 0.5 * sizeY, 0.5 * sizeZ

	local x1, y1, z1 = EHT.World.Rotate( -sizeX, -sizeY, -sizeZ, radX, radY, radZ )
	local x2, y2, z2 = EHT.World.Rotate( sizeX, sizeY, sizeZ, radX, radY, radZ )

	x1, y1, z1, x2, y2, z2 = posX + x1, posY + y1, posZ + z1, posX + x2, posY + y2, posZ + z2
	return math.min( x1, x2 ), math.min( y1, y2 ), math.min( z1, z2 ), math.max( x1, x2 ), math.max( y1, y2 ), math.max( z1, z2 )
end

do
	local isUpdatingEffect = false

	function EHT.Effect:Update()
		if isUpdatingEffect or (self.EffectState ~= EFFECT_STATE_RESETTING and self.EffectState ~= EFFECT_STATE_ACTIVE) then
--if EHT.IsDev then df("[DEBUG %.3fms] '%s' update failed (isUpdating: %s, effectState: %s)", GetGameTimeMilliseconds()/1000, self.EffectType.Name, tostring(isUpdatingEffect), EFFECT_STATE_NAMES[self.EffectState]) end
			return
		end

		isUpdatingEffect = true

		local x, y, z, pitch, yaw, roll = self:GetPositionAndOrientation()
		local offsetX, offsetY, offsetZ, offsetPitch, offsetYaw, offsetRoll
		local offsetOrientation = 0 ~= yaw or 0 ~= pitch or 0 ~= roll

		self:SetSize()
		self:SetColor()

		if self.AutoPositionEnabled then
			for index = 1, #self.Particles do
				local p = self.Particles[index]

				if p.AutoPositionEnabled then
					local offsetX, offsetY, offsetZ = p:GetPositionOffsetValues()
					local offsetPitch, offsetYaw, offsetRoll = p:GetOrientationOffsets()

					if offsetOrientation then
						offsetX, offsetY, offsetZ = EHT.Housing.TransformVector( pitch, yaw, roll, offsetX, offsetY, offsetZ )
					end

					if self.AutoOrientationEnabled then
						offsetPitch, offsetYaw, offsetRoll = EHT.Housing.TransformOrientation( pitch, yaw, roll, offsetPitch, offsetYaw, offsetRoll )
						p:SetPositionAndOrientation( x + round( offsetX ), y + round( offsetY ), z + round( offsetZ ), offsetPitch, offsetYaw, offsetRoll )
					else
						p:SetPosition( x + round( offsetX ), y + round( offsetY ), z + round( offsetZ ) )
					end
				elseif p.AutoOrientationEnabled then
					local offsetPitch, offsetYaw, offsetRoll = p:GetOrientationOffsets()

					offsetPitch, offsetYaw, offsetRoll = EHT.Housing.TransformOrientation( pitch, yaw, roll, offsetPitch, offsetYaw, offsetRoll )
					p:SetOrientation( offsetPitch, offsetYaw, offsetRoll )
				end
			end
		elseif self.AutoOrientationEnabled then
			for index = 1, #self.Particles do
				local p = self.Particles[index]
				local offsetPitch, offsetYaw, offsetRoll = p:GetOrientationOffsets()
				p:SetOrientation( EHT.Housing.TransformOrientation( pitch, yaw, roll, offsetPitch, offsetYaw, offsetRoll ) )
			end
		end

		isUpdatingEffect = false
--if EHT.IsDev then df("[DEBUG %.3fms] '%s' updated.", GetGameTimeMilliseconds()/1000, self.EffectType.Name) end
	end
end

function EHT.Effect:GetRecord()
	return self.Record
end

function EHT.Effect:SetRecord( rec )
	self.Record = rec
end

function EHT.Effect:GetEffectType()
	return self.EffectType
end

function EHT.Effect:GetName()
	return self.EffectType.Name
end

function EHT.Effect:GetCategory()
	return self.EffectType.Category
end

function EHT.Effect:GetFullName()
	return string.format( "%s / %s", self.EffectType.Category, self.EffectType.Name )
end

function EHT.Effect:GetUniqueClass()
	return self.EffectType.UniqueClass
end

function EHT.Effect:GetRecordId()
	return self.Record and self.Record.Id or nil
end

function EHT.Effect:IsInEffectGroup( groupBit )
	return hasbit( self.Groups or 0, groupBit )
end

function EHT.Effect:SetEffectGroup( groupBit )
	local prevGroups = self.Groups
	self.Groups = groupBit
	local newGroups = self.Groups

	EHT.Effect:OnEffectGroupsChanged( self, newGroups, prevGroups )
end

function EHT.Effect:AddToEffectGroup( groupBit )
	self.Groups = setbit( self.Groups or 0, groupBit )
end

function EHT.Effect:RemoveFromEffectGroup( groupBit )
	self.Groups = clearbit( self.Groups or 0, groupBit )
end

function EHT.Effect:GetEffectGroupBitmask()
	return self.Groups or 0
end

function EHT.Effect:GetEffectTypeIndex()
	return self.EffectType.Index
end

function EHT.Effect:GetAutoDrawLevelEnabled()
	return false ~= self.AutoDrawLevelEnabled
end

function EHT.Effect:SetAutoDrawLevelEnabled( enabled )
	if nil == enabled then enabled = true end
	self.AutoDrawLevelEnabled = enabled
end

function EHT.Effect:GetAutoSizeEnabled()
	return self.AutoSizeEnabled
end

function EHT.Effect:SetAutoSizeEnabled( enabled )
	self.AutoSizeEnabled = enabled
end

function EHT.Effect:GetAutoOrientationEnabled()
	return self.AutoOrientationEnabled
end

function EHT.Effect:SetAutoOrientationEnabled( enabled )
	self.AutoOrientationEnabled = enabled
end

function EHT.Effect:GetAutoPositionEnabled()
	return self.AutoPositionEnabled
end

function EHT.Effect:SetAutoPositionEnabled( enabled )
	self.AutoPositionEnabled = enabled
end

function EHT.Effect:SetHidden( hidden )
	if hidden ~= self.Hidden then
		self.Hidden = hidden

		for _, p in ipairs( self.Particles ) do
			p:RefreshHidden()
		end

		if self.EffectType.OnVisibilityChanged then
			self.EffectType.OnVisibilityChanged( self, true == hidden )
		end
	end
end

function EHT.Effect:IsHidden()
	return true == self.Hidden
end

function EHT.Effect:GetSize()
	local sizeX, sizeY, sizeZ = self.SizeX or 1, self.SizeY or 1, self.SizeZ or 1
	local m = self.SizeModifier
	if m then
		sizeX, sizeY, sizeZ = m * sizeX, m * sizeY, m * sizeZ
	end
	return sizeX, sizeY, sizeZ
end

function EHT.Effect:SetSize( x, y, z )
	if nil ~= x or nil ~= y or nil ~= z then self.LastChanged = FrameTime end

	local m = self.SizeModifier
	local pSizeX, pSizeY, pSizeZ = self.SizeX, self.SizeY, self.SizeZ
	local sizeX, sizeY, sizeZ

	if m then
		sizeX, sizeY, sizeZ = self.EffectType:AdjustRequestedSize( x or self.SizeX, y or self.SizeY, z or self.SizeZ )
	else
		self.SizeX, self.SizeY, self.SizeZ = self.EffectType:AdjustRequestedSize( x or self.SizeX, y or self.SizeY, z or self.SizeZ )
		sizeX, sizeY, sizeZ = self.SizeX, self.SizeY, self.SizeZ
	end

	if m then
		sizeX, sizeY, sizeZ = m * sizeX, m * sizeY, m * sizeZ
	end

	if self:GetAutoSizeEnabled() then
		if self.EffectType:UsesSetSizeV2() then
			for index = 1, #self.Particles do
				local p = self.Particles[index]
				if false ~= p:GetAutoSizeEnabled() then
					local offsetX, offsetY = p:GetSizeOffsets()
					p:SetSize(math.ceil(offsetX * sizeX), math.ceil(offsetY * sizeY))
				end
			end
		else
			for index = 1, #self.Particles do
				local p = self.Particles[index]
				if false ~= p:GetAutoSizeEnabled() then
					local offsetX, offsetZ = p:GetSizeOffsets()
					p:SetSize(math.ceil(offsetX * sizeX), math.ceil(offsetZ * sizeZ))
				end
			end
		end
	end

	self:UpdateDependencies()
	
	if self.EffectType.ResetOnScale then
		if m or pSizeX ~= sizeX or pSizeY ~= sizeY or pSizeZ ~= sizeZ then
			self:Reset( RESET_SCALE )
		end
	end
end

function EHT.Effect:GetColor()
	return self.ColorR, self.ColorG, self.ColorB, self.Alpha
end

function EHT.Effect:GetAlpha()
	return self.Alpha
end

function EHT.Effect:GetLuminosity()
	local r, g, b = self:GetColor()
	return 0.33333 * ( r + g + b )
end

function EHT.Effect:GetAutoColorEnabled()
	return self.AutoColorEnabled
end

function EHT.Effect:SetAutoColorEnabled( enabled )
	self.AutoColorEnabled = enabled
end

function EHT.Effect:GetTintRatio()
	return self.TintRatio or 1
end

function EHT.Effect:SetTintRatio( ratio )
	self.TintRatio = ratio or 1
	self:SetColor()
end

function EHT.Effect:ModifyColor( r, g, b, a, ratio )
	local m = self.ColorModifier

	if not r and not g and not b and not a and not ratio then
		self.ColorModifier = nil
	else
		if not m then
			m = { }
			self.ColorModifier = m
		end

		m[1], m[2], m[3], m[4], m[5] = r or m[1], g or m[2], b or m[3], a or m[4], ratio
	end

	if self.Particles then
		for _, p in ipairs( self.Particles ) do
			p:SetColor()
		end
	end
end

function EHT.Effect:UnmodifyColor()
	self.ColorModifier = nil

	if self.Particles then
		for _, p in ipairs( self.Particles ) do
			p:SetColor()
		end
	end
end

function EHT.Effect:SetColor( r, g, b, a )
	r, g, b, a = r or self.ColorR, g or self.ColorG, b or self.ColorB, a or self.Alpha

	if r ~= self.ColorR or g ~= self.ColorG or b ~= self.ColorB or a ~= self.Alpha then
		self.LastChanged = FrameTime
		self.ColorR, self.ColorG, self.ColorB, self.Alpha = r, g, b, a
	end

	if self.Particles and self:GetAutoColorEnabled() then
		local tint = self:GetTintRatio()

		if 1 == tint then
			for index = 1, #self.Particles do
				local p = self.Particles[index]
				if p:GetAutoColorEnabled() then
					local offsetR, offsetG, offsetB, offsetA = p:GetColorOffsets()
					local cr, cg, cb, ca = offsetR * r, offsetG * g, offsetB * b, offsetA * a
					p:SetColor( cr, cg, cb, ca )
-- if EHT.IsDev then df("p:SetColor(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca) end
				end
			end
		else
			local tintBase = 1 - tint
			for index = 1, #self.Particles do
				local p = self.Particles[index]
				if p:GetAutoColorEnabled() then
					local offsetR, offsetG, offsetB, offsetA = p:GetColorOffsets()
					local cr, cg, cb, ca = tintBase + tint * ( offsetR * r ), tintBase + tint * ( offsetG * g ), tintBase + tint * ( offsetB * b ), tintBase + tint * ( offsetA * a )
					p:SetColor( cr, cg, cb, ca )
-- if EHT.IsDev then df("p:SetColor(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca) end
				end
			end
		end

		if self.EffectType.EnhanceContrast then
			if 0 == r and 0 == g and 0 == b then
				if not self.IsEnhancingBlack then
					self.IsEnhancingBlack = true
					for index = 1, #self.Particles do
						self.Particles[index]:SetSampleProcessing( 3, nil )
					end
				end
			else
				if self.IsEnhancingBlack then
					self.IsEnhancingBlack = false
					for index = 1, #self.Particles do
						self.Particles[index]:SetSampleProcessing( 1, nil )
					end
				end
			end
		end
	end

	self:UpdateDependencies()

	if self.EffectType.ResetOnColor then
		self:Reset( RESET_COLOR )
	end

	return true
end

function EHT.Effect:GetCompressedColor()
	local r, g, b, alpha = self:GetColor()
	local color = EHT.Util.CompressColor( r, g, b )
	return color, alpha
end

function EHT.Effect:SetCompressedColor( color, alpha )
	local cR, cG, cB = EHT.Util.DecompressColor( color )
	local r, g, b, a = self:GetColor()
	if r ~= cR or g ~= cG or b ~= cB or a ~= alpha then
		self:SetColor( cR, cG, cB, alpha )
	end
end

function EHT.Effect:GetContrast()
	return self.Contrast or 1
end

function EHT.Effect:SetContrast( value )
	--if not value or 0 >= value then value = 1 end
	self.Contrast = value or self.Contrast or 1
	for _, p in ipairs( self.Particles ) do
		p:SetSampleProcessing()
	end

	self:UpdateDependencies()
	if self.EffectType.ResetOnColor then
		self:Reset( RESET_COLOR )
	end
end

function EHT.Effect:GetTransparency()
	return self.Alpha or 1
end

function EHT.Effect:SetTransparency( value )
	self.Alpha = value or self.Alpha
	self:SetColor()
	self:UpdateDependencies()
	if self.EffectType.ResetOnColor then
		self:Reset( RESET_COLOR )
	end
end

function EHT.Effect:ModifySize( scale )
	self.SizeModifier = scale
	self:SetSize()
end

function EHT.Effect:UnmodifySize()
	self.SizeModifier = nil
	self:SetSize()
end

function EHT.Effect:GetViewingSide()
	local _, viewAngle = EHT.World:GetDistanceAndAngleFromPlayer( CameraX, CameraY, CameraZ )
	local _, yaw = self:GetOrientation()
	viewAngle = ( viewAngle - yaw ) % RAD360

	if RAD180 < viewAngle then
		return 1 - 0.5 * ( math.abs( viewAngle - ( 1.5 * RAD180 ) ) / ( 0.5 * RAD180 ) )
	else
		return 0.5 * ( math.abs( viewAngle - ( 0.5 * RAD180 ) ) / ( 0.5 * RAD180 ) )
	end
end

function EHT.Effect:GetViewingAngle()
	local _, viewAngle = EHT.World:GetDistanceAndAngleFromPlayer( CameraX, CameraY, CameraZ )
	local _, yaw = self:GetOrientation()
	return ( viewAngle - yaw ) % RAD180
end

function EHT.Effect:GetViewingAngleAlpha()
	local viewAngle = self:GetViewingAngle()
	return math.abs( RAD90 - viewAngle ) / RAD90
end

function EHT.Effect:Tile( tileX, tileY, skipFirstN )
	local x, y, z = self:GetSize()
	x, y = x / tileX, math.max( y, z ) / tileY
	self.TileX, self.TileY = x, y

	for index = ( skipFirstN or 0 ) + 1, #self.Particles do
		local p = self.Particles[index]
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0, x, 0, y )
	end
end

function EHT.Effect:TileRange(tileX, tileY, startIndex, endIndex)
	local x, y, z = self:GetSize()
	x, y = x / tileX, math.max( y, z ) / tileY
	self.TileX, self.TileY = x, y

	for index = startIndex, endIndex do
		local p = self.Particles[index]
		if p then
			p:SetTextureWrapping( true )
			p:SetTextureCoords( 0, x, 0, y )
		end
	end
end

function EHT.Effect:SetTextureCoords( left, right, top, bottom )
	for index = 1, #self.Particles do
		local p = self.Particles[index]
		p:SetTextureCoords( left, right, top, bottom )
	end
end

function EHT.Effect:GetAnchorId()
	return self.AnchorId
end

function EHT.Effect:ClearAnchorId()
	self.AnchorId = nil
end

function EHT.Effect:SetAnchorId( id )
	if not id then
		return false, "No furniture item selected."
	end

	id = EHT.Housing.FindFurnitureId( id )

	if not id then
		return false, "No furniture item selected."
	end

	if EHT.Housing.IsEffectId( id ) then
		return false, "Effects cannot be anchored to effects."
	end

	self.AnchorId = string.fromId64( id )
	return true
end

function EHT.Effect:GetOrientation()
	return self.Pitch, self.Yaw, self.Roll
end

local function AdjustEffectOrientation( self, pitch, yaw, roll )
	local pPitch, pYaw, pRoll = self.Pitch, self.Yaw, self.Roll
	if pitch or yaw or roll then
		self.LastChanged = FrameTime
	end

	if pitch then self.Pitch = math.rad( round( math.deg( pitch % RAD360 ), 1 ) ) end
	if yaw then self.Yaw = math.rad( round( math.deg( yaw % RAD360 ), 1 ) ) end
	if roll then self.Roll = math.rad( round( math.deg( roll % RAD360 ), 1 ) ) end

	if 0 ~= self.Pitch and 0 == self.Pitch % RAD90 then self.Pitch = self.Pitch + math.rad( 0.01 ) end
	if 0 ~= self.Roll and 0 == self.Roll % RAD90 then self.Roll = self.Roll + math.rad( 0.01 ) end

	if pPitch ~= self.Pitch or pYaw ~= self.Yaw or pRoll ~= self.Roll then
		self:Update()
		if EHT.PositionItemId == self:GetRecordId() then
			EHT.UI.RefreshPositionDialog()
		end
	end
end

local function AdjustEffectPosition( self, x, y, z )
	if x or y or z then
		self.LastChanged = FrameTime
	end

	if x then self.X = x end
	if y then self.Y = y end
	if z then self.Z = z end
end

function EHT.Effect:SetOrientation( pitch, yaw, roll )
	local pPitch, pYaw, pRoll = self.Pitch, self.Yaw, self.Roll
	AdjustEffectOrientation( self, pitch, yaw, roll )

	if pPitch ~= self.Pitch or pYaw ~= self.Yaw or pRoll ~= self.Roll then
		self:Update()

		if self.EffectType.ResetOnOrient then
			self:Reset( RESET_ORIENT )
		end

		self:UpdateDependencies()
	end

	return HOUSING_REQUEST_RESULT_SUCCESS
end

function EHT.Effect:GetCameraDistance()
	local x, y, z = self:GetPosition()
	return zo_distance3D( x, y, z, CameraX, CameraY, CameraZ )
end

function EHT.Effect:DistanceToCenter( pX, pY, pZ )
	local x, y, z = self:GetPosition()
	return zo_distance3D( x, y, z, pX, pY, pZ )
end

function EHT.Effect:GetPlayerDistance()
	local x, y, z = self:GetPosition()
	return zo_distance3D(x, y, z, PlayerX, PlayerY, PlayerZ)
end

function EHT.Effect:IsNearPlayer( maxDistance )
	local distance = self:GetPlayerDistance() or 0
	return distance <= maxDistance
end

function EHT.Effect:IsNearPosition( x, y, z, maxDistance )
	return self:DistanceToCenter( x, y, z ) <= maxDistance
end

function EHT.Effect:IsActionable()
	return self.EffectType:IsActionable()
end

do
	local function ActionableComparer( a, b )
		return a.EffectType.Name < b.EffectType.Name
	end

	function EHT.Effect:GetAllActionables( sorted )
		local list = { }

		for _, effect in pairs( self:GetAll() ) do
			if effect.Active and not effect.Deleted and effect:IsActionable() then
				table.insert( list, effect )
			end
		end

		if sorted then
			table.sort( list, ActionableComparer )
		end

		return list
	end
end

function EHT.Effect:GetMetaData(paramName)
	local data = self.MetaData
	if "table" ~= type(data) then
		return nil
	end

	if "string" ~= type(paramName) then
		return nil
	end

	paramName = string.lower(paramName)
	local paramValue = data[paramName]

	if nil == paramValue then
		return nil
	end

	local paramDef = GetMetaParamByName(paramName)
	if paramDef and paramDef.Cast then
		paramValue = paramDef.Cast(paramValue)
		if nil == paramValue and paramDef.Default then
			paramValue = paramDef.Default
		end
	end

	return paramValue
end

function EHT.Effect:ResetMetaData()
	if self.MetaData then
		self.MetaData = {}
	end
end

function EHT.Effect:SetMetaData(paramName, value)
	local data = self.MetaData
	if not data then
		data = { }
		self.MetaData = data
	end

	local param = self.EffectType:GetMetaParamByName(paramName)
	if not param then return false end

	paramName = string.lower(paramName)
	data[paramName] = value

	return true
end

function EHT.Effect:GetMetaDataTable()
	return self.MetaData
end

function EHT.Effect:SetMetaDataTable( data )
	self:ResetMetaData()

	if "table" == type( data ) then
		for key, value in pairs( data ) do
			self:SetMetaData( key, value )
		end
	end
end

function EHT.Effect:SetCameraFacing( value )
	self.CameraFacing = false ~= value
	if self.CameraFacing then self:SetAutoOrientationEnabled( false ) end

	if self.Particles then
		for _, p in pairs( self.Particles ) do
			p:SetCameraFacing( self.CameraFacing )
		end
	end
end

function EHT.Effect:GetNormalVector( nx, ny, nz )
	local dx, dy, dz = EHT.World.Rotate( nx or 0, ny or 0, nz or 0, self.Pitch, self.Yaw, self.Roll )
	return EHT.World:GetNormalVector( dx, dy, dz )
end

function EHT.Effect:GetViewAngleOffsets( nx, ny, nz )
	local nx, ny, nz = self:GetNormalVector( nx, ny, nz )
	local vx = math.abs( CameraForwardX ) - math.abs( nx )
	local vy = math.abs( CameraForwardY ) - math.abs( ny )
	local vz = math.abs( CameraForwardZ ) - math.abs( nz )
	return vx, vy, vz
end

function EHT.Effect:GetPositionModifier()
	return self.TranslateX, self.TranslateY, self.TranslateZ
end

function EHT.Effect:ModifyPosition( offsetX, offsetY, offsetZ )
	self.TranslateX, self.TranslateY, self.TranslateZ = offsetX, offsetY, offsetZ
	self:Update()
end

function EHT.Effect:UnmodifyPosition()
	self.TranslateX, self.TranslateY, self.TranslateZ = 0, 0, 0
	self:SetPosition( nil, nil, nil, true )
end

function EHT.Effect:GetPosition()
	return self.X + self.TranslateX, self.Y + self.TranslateY, self.Z + self.TranslateZ
end

function EHT.Effect:SetPosition( x, y, z, changed )
	local pX, pY, pZ = self.X, self.Y, self.Z
	AdjustEffectPosition( self, x, y, z )

	if changed or self.X ~= pX or self.Y ~= pY or self.Z ~= pZ then
		self:Update()
		if self.EffectType.ResetOnPosition then
			self:Reset( RESET_POSITION )
		end
		self:UpdateDependencies()
	end

	return HOUSING_REQUEST_RESULT_SUCCESS
end

function EHT.Effect:GetPositionAndOrientation()
	return self.X + self.TranslateX, self.Y + self.TranslateY, self.Z + self.TranslateZ, self.Pitch, self.Yaw, self.Roll
end

function EHT.Effect:SetPositionAndOrientation( x, y, z, pitch, yaw, roll )
	local pX, pY, pZ, pPitch, pYaw, pRoll = self.X, self.Y, self.Z, self.Pitch, self.Yaw, self.Roll

	AdjustEffectPosition( self, x, y, z )
	AdjustEffectOrientation( self, pitch, yaw, roll )

	local pChanged = pX ~= self.X or pY ~= self.Y or pZ ~= self.Z
	local oChanged = pPitch ~= self.Pitch or pYaw ~= self.Yaw or pRoll ~= self.Roll

	if pChanged or oChanged then
		self:Update()

		if ( self.EffectType.ResetOnPosition and pChanged ) or ( self.EffectType.ResetOnOrient and oChanged ) then
			self:Reset( ( pChanged and oChanged ) and RESET_TRANSFORM or pChanged and RESET_POSITION or RESET_ORIENT )
		end

		self:UpdateDependencies()
	end

	return HOUSING_REQUEST_RESULT_SUCCESS
end

function EHT.Effect:MoveToPlayer( offsetX, offsetY, offsetZ, matchPlayerYaw )
	local x, y, z = GetPlayerWorldPositionInHouse()
	local yaw = CameraHeading

	if not matchPlayerYaw then
		self:SetPosition( x + ( offsetX or 0 ), y + ( offsetY or 0 ), z + ( offsetZ or 0 ) )
	else
		offsetX, offsetY, offsetZ = EHT.World.Rotate( offsetX, offsetY, offsetZ, 0, yaw, 0 )
		self:SetPositionAndOrientation( x + ( offsetX or 0 ), y + ( offsetY or 0 ), z + ( offsetZ or 0 ), nil, yaw, nil )
	end
end

function EHT.Effect:SpawnAtPlayer( yOffset, matchPlayerYaw, zOffset )
	local x, y, z = GetPlayerWorldPositionInHouse()
	local sizeX, sizeY, sizeZ = self:GetSize()
	local yaw = CameraHeading

	if EHT.Biz.AreGuidelinesEnabled() then
		local gridYaw = EHT.Biz.GetGuidelinesYaw()
		if gridYaw then
			yaw = EHT.Housing.NearestRightAngle( yaw, gridYaw )
		end
	end

	y = y + ( yOffset or ( 0.5 * ( sizeY or 0 ) ) )

	if false ~= matchPlayerYaw then
		x, z = x - 150 * math.sin( yaw ), z - 150 * math.cos( yaw )
	end

	if zOffset then
		x, z = x + zOffset * math.sin( yaw ), z + zOffset * math.cos( yaw )
	end

	if false == matchPlayerYaw then
		self:SetPosition( x, y, z )
	else
		self:SetPositionAndOrientation( x, y, z, nil, yaw, nil )
	end
end

function EHT.Effect:GetDistanceFromPlayer()
	local x, y, z = GetPlayerWorldPositionInHouse()
	return zo_distance3D( x, y, z, self:GetPosition() )
end

---[ Effects : User Interface ]---

do
	local hidden = false

	function EHT.EffectUI.AreEditButtonsHidden()
		return EHT.GetSetting( "EditEffectButtonHidden" ) == true
	end

	function EHT.EffectUI.ShowHideEditButtons()
		EHT.SavedVars.EditEffectButtonHidden = not EHT.EffectUI.AreEditButtonsHidden()
		EHT.UI.DisplayNotification( string.format( "Edit Effect (Paint Bucket) buttons are now %s.", EHT.EffectUI.AreEditButtonsHidden() and "HIDDEN" or "VISIBLE" ) )
	end

	function EHT.EffectUI.AreEffectsHidden()
		return hidden
	end
	
	function EHT.EffectUI.ShowHideEffects()
		hidden = not hidden
		local w = EHT.Particle:GetWindow()

		if w then
			if hidden then
				EHT.Effect:UnregisterOnUpdate()
				EHT.Effect:UnregisterOnReorderParticles()
			else
				EHT.Effect:RegisterOnUpdate()
				EHT.Effect:RegisterOnReorderParticles()
			end

			w:SetHidden( hidden )

			for _, effect in ipairs( EffectList ) do
				if effect.EffectType.OnVisibilityChanged then
					effect.EffectType.OnVisibilityChanged( effect, hidden )
				end
			end
		end

		local ui = EHT.UI.EHTEffectsButtonContextMenu
		if ui then
			ui.ShowHideEffectsLabel:SetText( hidden and "Show FX" or "Hide FX" )
		end

		EHT.UI.DisplayNotification( string.format( "FX are now %s.", hidden and "OFF" or "ON" ) )
	end
end

do
	local Crossfade = ZO_InitializingObject:Subclass()

	function Crossfade:Initialize()
		EVENT_MANAGER:RegisterForEvent("EHT.CrossFade.OnPlayerActivated", EVENT_PLAYER_ACTIVATED, function()
			self:OnPlayerActivated()
		end)

		self.DefaultIntervalMS = 800
		self.MaxIntervalMS = 8000
		self.StateIntervalMS = 0
		self.StateStartMS = 0
		self.State = nil

		local w = WINDOW_MANAGER:CreateTopLevelWindow("EHTGlobalCrossfadeWindow")
		self.Window = w
		w:SetHidden(true)

		local t = WINDOW_MANAGER:CreateControl(nil, self.Window, CT_TEXTURE)
		self.Texture = t
		t:SetHidden(true)
		t:SetMouseEnabled(false)
		t:SetAnchor(CENTER, GuiRoot, CENTER)
		t:SetDimensions(8000, 8000)
		t:SetColor(0, 0, 0, 1)
	end
	
	function Crossfade:OnComplete()
		EVENT_MANAGER:UnregisterForUpdate("EHT.Crossfade.OnComplete")
		self:SetState(nil)

		SetShouldRenderWorld(true)
		self.Window:SetHidden(true)
		self.Texture:SetHidden(true)
		self.Texture:SetAlpha(0)

		self.StateIntervalMS = 0
		self.StateStartMS = 0
	end

	function Crossfade:OnPlayerActivated()
		self:BeginFadeInCompletionTimer()
	end

	function Crossfade:OnUpdate()
		if 0 == self.StateStartMS then
			return
		end

		local ts = GetFrameTimeMilliseconds()
		local interval = (ts - self.StateStartMS) / self.StateIntervalMS
		if 1 < interval then
			self:OnComplete()
		else
			self.Texture:SetAlpha(1 - interval)
		end
	end

	function Crossfade:BeginFadeInCompletionTimer()
		EVENT_MANAGER:UnregisterForUpdate("EHT.Crossfade.OnComplete")
		EVENT_MANAGER:RegisterForUpdate("EHT.Crossfade.OnComplete", self.MaxIntervalMS, function()
			self:OnComplete()
		end)
	end

	function Crossfade:SetState(state)
		if state ~= self.State then
			self.State = state

			if self.State then
				self:BeginFadeInCompletionTimer()
				EVENT_MANAGER:RegisterForUpdate("EHT.Crossfade.OnUpdate", 1, function() self:OnUpdate() end)
			else
				EVENT_MANAGER:UnregisterForUpdate("EHT.Crossfade.OnUpdate")
			end

			return true
		end
		
		return false
	end
	
	function Crossfade:RequestBlackOut()
		if self:SetState("blackout") then
			self.StateIntervalMS = 0
			self.StateStartMS = 0

			SetShouldRenderWorld(false)
			self.Texture:SetAlpha(1)
			self.Texture:SetHidden(false)
			self.Window:SetHidden(false)
		end
	end

	function Crossfade:RequestFadeIn(intervalMS)
		if self:SetState("fadein") then
			intervalMS = math.max(1, intervalMS or self.DefaultIntervalMS)
			self.StateIntervalMS = intervalMS
			self.StateStartMS = GetFrameTimeMilliseconds()

			self.Texture:SetAlpha(1)
			self.Texture:SetHidden(false)
			self.Window:SetHidden(false)
			SetShouldRenderWorld(true)
		end
	end

	EHT.GlobalCrossfade = Crossfade:New()
end

function EHT.EffectUI.SetRenderingHidden( hidden )
	if hidden ~= HideAllEffectsFlag then
		HideAllEffectsFlag = hidden

		local particles = EHT.Particle:GetAll()
		if particles then
			for index, p in ipairs( particles ) do
				p:RefreshHidden()
			end
		end

		if hidden then
			EHT.GlobalCrossfade:RequestBlackOut()
		else
			EHT.GlobalCrossfade:RequestFadeIn()
		end
	end
end

function EHT.EffectUI.PreloadAll()
	EHT.Effect:UnregisterOnUpdate()
	EHT.Effect:DeleteAll()

	if not EHT.Housing.IsHouseZone() then
		EHT.EffectUI.SetRenderingHidden(false)
		EHT.UI.HideProgressIndicatorDialog()
		return
	end

	EHT.EffectUI.SetRenderingHidden( true )
	EVENT_MANAGER:RegisterForUpdate( "EHTEffectsRefreshAll", 1, EHT.EffectUI.RefreshAll )
end

function EHT.EffectUI.RefreshAll()
	EVENT_MANAGER:UnregisterForUpdate( "EHTEffectsRefreshAll" )

	local function OnRefreshComplete()
		EVENT_MANAGER:UnregisterForUpdate( "EHTEffectsOnRefreshComplete" )
		EVENT_MANAGER:UnregisterForUpdate( "EHTEffectsRefreshAllProcess" )
		EVENT_MANAGER:UnregisterForUpdate( "EHTEffectsRefreshAllProcessWatchDog" )

		EHT.Effect:RegisterOnUpdate()
		EHT.UI.HideProgressIndicatorDialog()
		EHT.EffectUI.SetRenderingHidden( false )

		zo_callLater( function()
			EHT.Effect:SummonGuestbook()
			EHT.EffectUI.RefreshEditorButtons()
			EHT.EffectUI.RefreshPOIEffects()
		end, 500 )
	end

	if not EHT.Housing.IsHouseZone() then
		EHT.UI.HideProgressIndicatorDialog()
		EHT.EffectUI.SetRenderingHidden( false )
		return
	end

	if WINDOW_MANAGER:IsSecureRenderModeEnabled() then
		EHT.UI.HideProgressIndicatorDialog()
		EHT.EffectUI.SetRenderingHidden( false )
		EVENT_MANAGER:RegisterForUpdate( "EHTEffectsRefreshAll", 1000, EHT.EffectUI.RefreshAll )
		return
	end

	local effects = EHT.Data.GetEffectRecords()
	if not effects or 0 == #effects then
		EVENT_MANAGER:RegisterForUpdate( "EHTEffectsOnRefreshComplete", 100, OnRefreshComplete )
	else
		local effectIndex = 1
		local lastWatchDogEffectIndex = 0

		local function OnWatchDog()
			if effectIndex >= lastWatchDogEffectIndex then
				EVENT_MANAGER:RegisterForUpdate( "EHTEffectsOnRefreshComplete", 2500, OnRefreshComplete )
				return
			end

			lastWatchDogEffectIndex = effectIndex
		end

		local function OnLoadEffects()
			local numEffects = #effects
			if effectIndex > numEffects then
				EVENT_MANAGER:RegisterForUpdate( "EHTEffectsOnRefreshComplete", 2500, OnRefreshComplete )
				EVENT_MANAGER:UnregisterForUpdate( "EHTEffectsRefreshAllProcess" )
				EVENT_MANAGER:UnregisterForUpdate( "EHTEffectsRefreshAllProcessWatchDog" )
				return
			end

			local maxTime = GetGameTimeMilliseconds() + 32
			while effectIndex <= numEffects and GetGameTimeMilliseconds() < maxTime do
				local effect = effects[effectIndex]
				if effect then
					if not EHT.EffectUI.CreateEffectFromEffectRecord(effect) then
						table.remove(effects, effectIndex)
					else
						effectIndex = effectIndex + 1
					end
				else
					effectIndex = effectIndex + 1
				end
			end

			local progress = math.min(1, effectIndex / numEffects)
			EHT.UI.UpdateProgressIndicator( string.format( "Loading FX (%d%%)", 100 * progress ), progress )
		end

		EHT.Effect:UnregisterOnUpdate()

		EVENT_MANAGER:RegisterForUpdate( "EHTEffectsRefreshAllProcess", 33, OnLoadEffects )
		EVENT_MANAGER:RegisterForUpdate( "EHTEffectsRefreshAllProcessWatchDog", 3000, OnWatchDog )
	end
end

function EHT.EffectUI.IsPreviewingEffects()
	return nil ~= EHT.PreviewEffectHouseId
end

function EHT.EffectUI.ValidatePreviewMode( suppressNotification )
	if EHT.EffectUI.IsPreviewingEffects() then
		if not suppressNotification then
			EHT.UI.DisplayNotification( "Effects may not be edited while in preview mode." )
		end

		return false
	end

	return true
end

function EHT.EffectUI.PreviewEffects( effectRecords, effectTS )
	if "table" ~= type( effectRecords ) then
		return false, "Invalid effects data."
	end

	if WINDOW_MANAGER:IsSecureRenderModeEnabled() then
		return false, "Cannot preview effects while in secure render mode."
	end

	if not EHT.Housing.IsHouseZone() then
		return false, "You must be in a house."
	end

	if not EHT.Housing.IsOwner() then
		return false, "You must be the homeowner."
	end

	EHT.PreviewEffectHouseId, EHT.PreviewEffectHouseOwner, EHT.PreviewEffectTS = EHT.Housing.GetHouseId(), EHT.Housing.GetHouseOwner(), tonumber( effectTS ) or 0
	EHT.PreviewEffectRecords = EHT.Util.CloneTable( effectRecords )

	EHT.Effect:DeleteAll()

	if effectRecords then
		local index = 1
		local numRecords = #effectRecords
		while index <= numRecords do
			local rec = effectRecords[index]
			if rec then
				if EHT.EffectUI.CreateEffectFromEffectRecord(rec) then
					index = index + 1
				else
					table.remove(effectRecords, index)
					numRecords = numRecords - 1
				end
			else
				index = index + 1
			end
		end
	end

	EHT.EffectUI.RefreshEditorButtons()
	return true
end

function EHT.EffectUI.CancelPreviewEffects( skipRefresh )
	local houseId, owner, ts, records = tonumber( EHT.PreviewEffectHouseId ), EHT.PreviewEffectHouseOwner, EHT.PreviewEffectTS, EHT.PreviewEffectRecords
	EHT.PreviewEffectHouseId, EHT.PreviewEffectHouseOwner, EHT.PreviewEffectTS, EHT.PreviewEffectRecords = nil, nil, nil, nil

	if houseId and owner and records then
		if houseId == tonumber( EHT.Housing.GetHouseId() ) and string.lower( owner ) == string.lower( EHT.Housing.GetHouseOwner() ) then
			if not skipRefresh then
				EHT.Effect:DeleteAll()
				EVENT_MANAGER:RegisterForUpdate( "EHTEffectsRefreshAll", 1, EHT.EffectUI.RefreshAll )
			end

			return true
		else
			return false
		end
	else
		return false
	end
end

function EHT.EffectUI.AcceptPreviewEffects()
	local houseId, owner, ts, records = tonumber( EHT.PreviewEffectHouseId ), EHT.PreviewEffectHouseOwner, EHT.PreviewEffectTS, EHT.PreviewEffectRecords
	EHT.PreviewEffectHouseId, EHT.PreviewEffectHouseOwner, EHT.PreviewEffectTS, EHT.PreviewEffectRecords = nil, nil, nil, nil

	if houseId and owner and records then
		if houseId == tonumber( EHT.Housing.GetHouseId() ) and string.lower( owner ) == string.lower( EHT.Housing.GetHouseOwner() ) then
			do
				local effects = EHT.Util.CloneTable( EHT.Data.GetEffectRecords() )
				if nil ~= effects then
					local history = { Op = EHT.CONST.CHANGE_TYPE.REMOVE, Id = 0, Link = "Multiple Items" }
					local batch = { }
					history.Batch = batch

					for index = #effects, 1, -1 do
						local rec = effects[index]
						if rec then
							table.insert( batch, EHT.CT.CreateHistory( EHT.CONST.CHANGE_TYPE.REMOVE, rec, nil ) )
						end
					end

					if 0 < #batch then
						EHT.CT.AddHistory( history )
					end
				end
			end

			do
				EHT.Data.DeleteAllEffectRecords()

				for index, effect in ipairs( EHT.Effect:GetAll() ) do
					effect.Record = EHT.Data.CacheEffectRecord( owner, houseId, index, effect )
					if effect.Record then
						effect.Record.Id = EHT.Data.AcquireNewEffectId()
					end
				end

				EHT.Effect:DeleteAll()
				EHT.EffectUI.RefreshAll()
			end

			do
				local effects = EHT.Effect:GetAll()
				local history = { Op = EHT.CONST.CHANGE_TYPE.PLACE, Id = 0, Link = "Multiple Items" }
				local batch = { }
				history.Batch = batch

				for index, effect in pairs( effects ) do
					local recordId = effect:GetRecordId()
					local item = EHT.Data.CreateFurniture( recordId )

					if item then
						local historyItem = EHT.CT.CreateHistory( EHT.CONST.CHANGE_TYPE.PLACE, nil, item, true )

						if historyItem then
							table.insert( batch, historyItem )
						end
					end
				end

				if 0 < #batch then
					EHT.CT.AddHistory( history )
				end
			end

			EHT.UI.RefreshHistory()

			return true
		else
			return false
		end
	else
		return false
	end
end

function EHT.EffectUI.RefreshEditorButtons()
	EVENT_MANAGER:UnregisterForUpdate( "EHTEffectsRefreshEditorButtons" )

	local editor = EHT.GetEffectEditor()
	editor:UpdateEditButtons()
	editor:UpdateEditor()
end

function EHT.EffectUI.GetAllPlacedEffects()
	return EHT.Effect:GetAll()
end

function EHT.EffectUI.AddEffect( effectOrEffectTypeName, overwriteDuplicate, temporary )
	if not EHT.EffectUI.ValidatePreviewMode() then
		return nil
	end

	local editor = EHT.GetEffectEditor()
	local validatePermission = true
	local record

	if "string" == type( effectOrEffectTypeName ) and "Reserved:" == string.sub( effectOrEffectTypeName, 1, 9 ) then
		validatePermission = false
	elseif "table" == type( effectOrEffectTypeName ) and effectOrEffectTypeName.EffectType:IsReserved() then
		validatePermission = false
	end

	if validatePermission and not editor:CheckEditEffectPermission() then return false end

	local effect, effectClass

	if "table" == type( effectOrEffectTypeName ) then
		effectClass = effectOrEffectTypeName:GetUniqueClass()
	else
		effectClass = EHT.EffectType:GetByName( effectOrEffectTypeName )
		if effectClass then effectClass = effectClass.UniqueClass else effectClass = nil end
	end

	if effectClass and temporary then return nil end

	if effectClass and not EHT.Effect:EnforceUniqueConstraint( effectClass, not overwriteDuplicate ) then
		EHT.UI.ShowConfirmationDialog( "",
			string.format( "Only one |cffff00%s|r effect may be placed at a time.\n\nDo you want to overwrite this effect?", effectClass ),
			function() EHT.EffectUI.AddEffect( effectOrEffectTypeName, true ) end )

		return
	end

	if "table" == type( effectOrEffectTypeName ) then
		effect = effectOrEffectTypeName
	elseif "string" == type( effectOrEffectTypeName ) then
		effect = EHT.Effect:New( effectOrEffectTypeName, nil, nil, temporary )
	end

	if nil == effect then
		if EHT.DEBUG_MODE then
			df( "EHT.EffectUI.AddEffect failed to instantiate new effect:" )
			d( effectOrEffectTypeName )
		end

		return
	end

	if not temporary and not effect.EffectType:IsReserved() then
		record = EHT.Data.CreateEffectRecord( effect )
		if nil == record then
			if EHT.DEBUG_MODE then
				df( "EHT.EffectUI.AddEffect failed create effect data record:" )
				for key, value in pairs( effect ) do
					df( "Key: %s; Value: %s", key, tostring( value ) or "" )
				end
			end

			effect:Delete()
			return nil, nil
		else
			EHT.UI.PlaySoundEffectAdded()
			EssentialHousingHub:IncUMTD("n_fxp", 1)
		end

		if effect then
			EHT.Handlers.OnFurniturePlaced( nil, effect:GetRecordId(), nil )

			local e = effect
			zo_callLater( function()
				editor:BindToEffect( e )
				editor:ShowEditor()
			end, 500 )
		end
	end

	local used = EHT.SavedVars.UsedEffectTypes
	if not used then
		used = { }
		EHT.SavedVars.UsedEffectTypes = used
	end
	local effectTypeId = effect:GetEffectType().Index
	used[effectTypeId] = true

	-- EHT.Mapcast.BroadcastEffects()
	if not temporary then
		EHT.UI.RefreshPlacedEffectsList()
	end

	return record, effect
end

function EHT.EffectUI.CreateEffectFromEffectRecord(rec)
	if "table" ~= type(rec) then
		return false
	end

	if	nil == rec.EffectType or nil == rec.Color or
		nil == rec.X or nil == rec.Y or nil == rec.Z or
		nil == rec.Pitch or nil == rec.Yaw or nil == rec.Roll or
		nil == rec.SizeX or nil == rec.SizeY or nil == rec.SizeZ then
		return false
	end

	local cR, cG, cB = EHT.Util.DecompressColor(rec.Color)
	local effect = EHT.Effect:New(tonumber(rec.EffectType))

	if nil == effect then
		return false
	end

	effect.X, effect.Y, effect.Z = rec.X, rec.Y, rec.Z
	effect.Pitch, effect.Yaw, effect.Roll = rec.Pitch, rec.Yaw, rec.Roll
	effect.ColorR, effect.ColorG, effect.ColorB, effect.Alpha = cR, cG, cB, rec.Alpha or 1
	effect.Contrast = rec.Contrast or 1
	effect.SizeX, effect.SizeY, effect.SizeZ = rec.SizeX, rec.SizeY, rec.SizeZ
	effect.Groups = rec.Groups
	effect:SetMetaDataTable(rec.MetaData)
	effect:SetRecord(rec)
	effect:Reset()

	EHT.Handlers.OnFurniturePlaced(nil, effect:GetRecordId(), nil, true)

	return true
end

function EHT.EffectUI.DeleteAllEffects( confirm )
	local editor = EHT.GetEffectEditor()
	if not editor:CheckEditEffectPermission() then return false end

	if not confirm then
		EHT.UI.ShowConfirmationDialog( "Remove all placed effects", "Remove all Essential Effects(TM) that you have placed in this home?", function() EHT.EffectUI.DeleteAllEffects( true ) end )
		return true
	end

	EHT.Data.DeleteAllEffectRecords()
	editor:UpdateEditButtons()
	editor:HideEditor()
	EHT.UI.RefreshPlacedEffectsList()
	return true
end

------[ Effect Editor ]------

function EHT.GetEffectEditorWindow()
	return EffectEditorWindow
end

function EHT.GetEffectEditor()
	return EFFECT_EDITOR or EHT.EffectEditor:New()
end

function EHT.EffectEditor:New()
	if not EFFECT_EDITOR then
		EFFECT_EDITOR = ZO_Object.New(self)
		EFFECT_EDITOR:Initialize()
	end
	return EFFECT_EDITOR
end

function EHT.EffectEditor:GetEditEffectButton(index)
	local button = self.EditButtons[index]
	if not button then
		local prefix = EFFECT_EDIT_BUTTONS_PREFIX
		button = WINDOW_MANAGER:CreateControl( prefix .. "Edit" .. tostring( index ), EffectEditButtonsWindow, CT_TEXTURE )
		button:SetHidden( true )
		button:SetAnchor( CENTER, EffectEditButtonsWindow, CENTER, 0, 0 )
		button:SetAddressMode( TEX_MODE_CLAMP )
		button:SetBlendMode( TEX_BLEND_MODE_ALPHA )
		button:SetColor( 1, 1, 0.4, 0.4 )
		button:SetTexture( "esoui/art/dye/dyes_toolicon_fill_down.dds" )
		button:SetMouseEnabled( true )
		button:SetHandler( "OnMouseDown", EHT.EffectEditor.OnEditButtonClick )
		button:Create3DRenderSpace()
		button:Set3DRenderSpaceUsesDepthBuffer( false )
		button:Set3DRenderSpaceOrientation( 0, 0, 0 )
		--button:Set3DLocalDimensions( 0.5, 0.5 )

		self.EditButtons[index] = button
	end

	return button
end

local function RefreshParamTargetEffect( self, value )
	local list = self.ParamTargetEffect.TargetEffect
	list:ClearItems()

	list:AddItem( "Effect Groups..." )
	for index = EHT.CONST.EFFECT_GROUP_ID_MIN, EHT.CONST.EFFECT_GROUP_ID_MAX do
		list:AddItem( string.format( "   Effect Group %d", 1 + index - EHT.CONST.EFFECT_GROUP_ID_MIN ), nil, index )
	end

	list:AddItem( "" )
	list:AddItem( "Individual Effects..." )
	for index, effect in ipairs( EHT.Effect:GetAllActionables( true ) ) do
		local id = effect:GetRecordId() or index or 0

		if id then
			local distance = effect:GetPlayerDistance() / 100
			local distanceString = string.format( "%.1f", distance )
			local dlLen = #distanceString
			if dlLen < 7 then
				distanceString = string.rep( "0", 7 - dlLen ) .. distanceString
			end
			local effectName = string.format( "   %s (%sm away) [id %d]", effect:GetName(), distanceString, id )
			list:AddItem( effectName, nil, id )
		end
	end

	if value then
		self.ParamTargetEffect.TargetEffect:SetSelectedItem( value )
	else
		self.ParamTargetEffect.TargetEffect:SetSelectedItem( 1 )
	end

	list:Refresh()
end

local function RefreshParamFurniture( self, value )
	local _, _, _, _, _, _, _, _, _, furnitureName = EHT.Housing.GetFurnitureInfo( value )
	if not furnitureName or "" == furnitureName then
		furnitureName = "No furniture item selected"
	end

	self.FurnitureNameLabel:SetText( furnitureName )
end

function EHT.EffectEditor:Initialize()
	EHT.PushTS( "EHT.EffectEditor:Initialize" )

	local prefix = EFFECT_EDIT_BUTTONS_PREFIX
	local win = EffectEditButtonsWindow

	if nil == win then
		win = WINDOW_MANAGER:CreateTopLevelWindow( prefix )
		EffectEditButtonsWindow = win
		win:SetHidden( true )
		win:SetDimensions( 1, 1 )
		win:SetMovable( true )
		win:SetMouseEnabled( false )
		win:SetClampedToScreen( false )
		win:SetAnchor( TOPLEFT, GuiRoot, TOPLEFT, -10, -10 )
		win:SetHidden( false )
		win:Create3DRenderSpace()
		win:SetDrawLevel( MAX_EDITOR_DRAW_LEVEL )

		local tex
		self.EditButtons = { }

		tex = WINDOW_MANAGER:CreateControl( prefix .. "EditingEffectMarker", win, CT_TEXTURE )
		self.EditingEffectMarker = tex
		tex:SetHidden( true )
		tex:SetAnchor( CENTER, win, CENTER, 0, 0 )
		tex:SetAddressMode( TEX_MODE_CLAMP )
		tex:SetBlendMode( TEX_BLEND_MODE_ALPHA )
		tex:SetTexture( "esoui/art/dye/dyes_toolicon_fill_down.dds" )
		tex:SetColor( 0, 0.4, 0.5, 0.4 )
		tex:SetMouseEnabled( false )
		tex:Create3DRenderSpace()
		tex:Set3DRenderSpaceUsesDepthBuffer( false )
		tex:Set3DRenderSpaceOrientation( 0, 0, 0 )
		tex:Set3DLocalDimensions( 0.5, 0.5 )
		tex:SetDrawLevel( MAX_EDITOR_DRAW_LEVEL - 100 )
		tex:SetTextureSampleProcessingWeight( TEX_SAMPLE_PROCESSING_RGB, 1.5 )

		self.EditingEffectOutline = { }
		for index = 1, 4 do
			local tex = WINDOW_MANAGER:CreateControl( prefix .. "EditingEffectOutline" .. tostring( index ), win, CT_TEXTURE )
			table.insert( self.EditingEffectOutline, tex )
			tex:SetHidden( true )
			tex:SetAnchor( CENTER, win, CENTER, 0, 0 )
			tex:SetAddressMode( TEX_MODE_CLAMP )
			tex:SetBlendMode( TEX_BLEND_MODE_ALPHA )
			tex:SetMouseEnabled( false )
			tex:Create3DRenderSpace()
			tex:Set3DLocalDimensions( 1, 1 )
			tex:Set3DRenderSpaceUsesDepthBuffer( true )
			tex:SetDrawLevel( 1 )
			tex:SetTextureReleaseOption( RELEASE_TEXTURE_AT_ZERO_REFERENCES )
			zo_callLater( function() tex:SetTexture( TEXTURES.SOLID ) end, 1000 )
		end
	end

	prefix = GLOBAL_EFFECTS_PREFIX
	win = GlobalEffectsWindow

	if nil == win then
		local width, height = 80, 100
		local baseDrawLevel = 10000
		local c, panel

		self.GlobalEffects = { }
		self.ActiveGlobalEffects = 0

		win = WINDOW_MANAGER:CreateTopLevelWindow( prefix )
		GlobalEffectsWindow = win
		self.GlobalEffectsWindow = win
		win:SetDimensions( width, height )
		win:SetHidden( true )
		win:SetMovable( true )
		win:SetMouseEnabled( true )
		win:SetClampedToScreen( true )

		zo_callLater( function()
			local win = GlobalEffectsWindow
			local winTop, winLeft = EHT.SavedVars.GlobalEffectsWindowTop or 0, EHT.SavedVars.GlobalEffectsWindowLeft or 0

			if winTop and winLeft then
				win:SetAnchor( TOPLEFT, GuiRoot, TOPLEFT, winLeft, winTop )
			else
				win:SetAnchor( RIGHT, GuiRoot, RIGHT, -100, 0 )
			end
		end, 5000 )

		win:SetHandler( "OnMoveStop", function()
			local win = GlobalEffectsWindow
			EHT.SavedVars.GlobalEffectsWindowTop, EHT.SavedVars.GlobalEffectsWindowLeft = win:GetTop(), win:GetLeft()
		end )

		c = WINDOW_MANAGER:CreateControl( "esoui/art/buttons/gamepad/console-widget-checkbox.dds", win, CT_TEXTURE )
		win.Backdrop = c
		c:SetColor( 0, 0, 0, 0.65 )
		c:SetAnchor( TOPLEFT, win, TOPLEFT, 0, 0 )
		c:SetAnchor( BOTTOMRIGHT, win, BOTTOMRIGHT, 0, 0 )
		c:SetDrawLevel( baseDrawLevel )
		c:SetBlendMode( TEX_BLEND_MODE_ALPHA )

		panel = WINDOW_MANAGER:CreateControl( prefix .. "Panel", win, CT_CONTROL )
		win.Panel = panel
		panel:SetAnchor( CENTER, win, CENTER, 0, 0 )
		panel:SetResizeToFitDescendents( true )
		panel:SetDrawLevel( baseDrawLevel )

		c = WINDOW_MANAGER:CreateControl( nil, win, CT_LABEL )
		win.Title = c
		c:SetColor( 0, 1, 1, 1 )
		c:SetAnchor( TOP, win, TOP, 0, 3 )
		c:SetWidth( 70 )
		c:SetFont( "$(BOLD_FONT)|$(KB_16)|soft-shadow-thin" )
		c:SetHorizontalAlignment( TEXT_ALIGN_CENTER )
		c:SetMaxLineCount( 2 )
		c:SetText( "Global Effects" )
	end

	prefix = EFFECT_EDITOR_PREFIX
	win = EffectEditorWindow

	if nil == win then
		local function FadeInOnMouseOver( c, aLow, aHigh )
			local control = c
			local controlName = control:GetName()
			local alphaLow, alphaHigh = aLow or 0.5, aHigh or 1
			local fadingIn = false
			local lastChange = 0

			control:SetAlpha( alphaLow )
			control:SetMouseEnabled( true )
			control:SetHandler( "OnMouseEnter", function()
				control:SetAlpha( alphaHigh )

				if not fadingIn then
					fadingIn = true
					lastChange = FrameTime
				end

				EVENT_MANAGER:RegisterForUpdate( controlName, 20, function()
					if fadingIn and not EHT.UI.IsMouseOverControl( control ) then
						fadingIn = false
						lastChange = FrameTime
					elseif not fadingIn and EHT.UI.IsMouseOverControl( control ) then
						fadingIn = true
						lastChange = FrameTime
					end

					if fadingIn and control:GetAlpha() < alphaHigh then
						control:SetAlpha( math.min( alphaHigh, alphaLow + ( alphaHigh - alphaLow ) * ( ( FrameTime - lastChange ) / 250 ) ) )
					elseif not fadingIn then
						if control:GetAlpha() > alphaLow then
							control:SetAlpha( math.max( alphaLow, alphaHigh - ( alphaHigh - alphaLow ) * ( ( FrameTime - lastChange ) / 250 ) ) )
						elseif EffectEditorWindow and not EHT.UI.IsMouseOverControl( EffectEditorWindow ) then
							EVENT_MANAGER:UnregisterForUpdate( controlName )
						end
					end
				end )
			end )
		end

		local width, height = 1100, 260 --1040, 260
		local baseDrawLevel = MAX_EDITOR_DRAW_LEVEL
		local c, panel, rpanel, panelPosition, panelBringToMe, panelPositionCardinal, panelPositionVertical, panelOrientation, panelScale, panelColor
		local tex, arrows, scales = nil, { }, { }

		self.Arrows, self.Scales = arrows, scales

		win = WINDOW_MANAGER:CreateTopLevelWindow( prefix )
		EffectEditorWindow = win
		win:SetHidden( true )
		win:SetMovable( false )
		win:SetMouseEnabled( true )
		win:SetClampedToScreen( true )
		win:SetDrawLevel( baseDrawLevel )
		win:SetDimensions( width, height )
		win:SetAnchor( BOTTOM, GuiRoot, BOTTOM, 0, -80 )
		win:SetAlpha( 0.75 )
		FadeInOnMouseOver( win )

		rpanel = WINDOW_MANAGER:CreateControl( prefix .. "RootPanel", win, CT_CONTROL )
		self.RootPanel = rpanel
		rpanel:SetAnchorFill( win )
		rpanel:SetDrawLevel( baseDrawLevel )
		--FadeInOnMouseOver( rpanel )

		panelBringToMe = WINDOW_MANAGER:CreateControl( prefix .. "PositionBringToMePanel", rpanel, CT_CONTROL )
		self.PositionBringToMePanel = panelBringToMe
		panelBringToMe:SetAnchor( TOPLEFT, rpanel, TOPLEFT, 0, 5 )
		panelBringToMe:SetDrawLevel( baseDrawLevel )
		panelBringToMe:SetDimensions( 80, 140 )
		--panelBringToMe:SetInheritAlpha( false )
		--FadeInOnMouseOver( panelBringToMe )

		panelPositionCardinal = WINDOW_MANAGER:CreateControl( prefix .. "CardinalPositionPanel", rpanel, CT_CONTROL )
		self.PanelPositionCardinal = panelPositionCardinal
		panelPositionCardinal:SetSimpleAnchorParent( 130, 5 )
		panelPositionCardinal:SetDrawLevel( baseDrawLevel )
		panelPositionCardinal:SetDimensions( 120, 140 )
		--panelPositionCardinal:SetInheritAlpha( false )
		--FadeInOnMouseOver( panelPositionCardinal )

		panelPositionVertical = WINDOW_MANAGER:CreateControl( prefix .. "VerticalPositionPanel", rpanel, CT_CONTROL )
		self.PanelPositionVertical = panelPositionVertical
		panelPositionVertical:SetSimpleAnchorParent( 260, 5 )
		panelPositionVertical:SetDrawLevel( baseDrawLevel )
		panelPositionVertical:SetDimensions( 100, 140 )
		--panelPositionVertical:SetInheritAlpha( false )
		--FadeInOnMouseOver( panelPositionVertical )

		panelOrientation = WINDOW_MANAGER:CreateControl( prefix .. "OrientationPanel", rpanel, CT_CONTROL )
		self.OrientationPanel = panelOrientation
		panelOrientation:SetSimpleAnchorParent( 380, 5 )
		panelOrientation:SetDrawLevel( baseDrawLevel )
		panelOrientation:SetDimensions( 120, 140 )
		--panelOrientation:SetInheritAlpha( false )
		--FadeInOnMouseOver( panelOrientation )

		panelScale = WINDOW_MANAGER:CreateControl( prefix .. "ScalePanel", rpanel, CT_CONTROL )
		self.ScalePanel = panelScale
		panelScale:SetSimpleAnchorParent( 550, 5 )
		panelScale:SetDrawLevel( baseDrawLevel )
		panelScale:SetDimensions( 120, 140 )
		--panelScale:SetInheritAlpha( false )
		--FadeInOnMouseOver( panelScale )

		panelColor = WINDOW_MANAGER:CreateControl( prefix .. "ColorPanel", rpanel, CT_CONTROL )
		self.ColorPanel = panelColor
		panelColor:SetSimpleAnchorParent( 710, 5 )
		panelColor:SetDrawLevel( baseDrawLevel )
		panelColor:SetDimensions( 220, 185 ) --( 160, 185 )
		--panelColor:SetInheritAlpha( false )
		--FadeInOnMouseOver( panelColor )

		panelOptions = WINDOW_MANAGER:CreateControl( prefix .. "OptionsPanel", rpanel, CT_CONTROL )
		self.OptionsPanel = panelOptions
		panelOptions:SetAnchor( TOPRIGHT, rpanel, TOPRIGHT, 0, 5 )
		panelOptions:SetDrawLevel( baseDrawLevel )
		panelOptions:SetDimensions( 120, 140 )
		--panelOptions:SetInheritAlpha( false )
		--FadeInOnMouseOver( panelOptions )

		panelCycle = WINDOW_MANAGER:CreateControl( prefix .. "CyclePanel", win, CT_CONTROL )
		self.CyclePanel = panelCycle
		panelCycle:SetAnchor( BOTTOMLEFT, win, TOPLEFT, 0, -48 )
		panelCycle:SetDimensions( 120, 50 )
		panelCycle:SetDrawLevel( baseDrawLevel )
		--panelCycle:SetInheritAlpha( false )
		--FadeInOnMouseOver( panelCycle )

		local label

		label = WINDOW_MANAGER:CreateControl( nil, panelBringToMe, CT_LABEL )
		label:SetAnchor( BOTTOMLEFT, panelBringToMe, TOPLEFT, 0, 8 )
		label:SetColor( 1, 1, 1, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_24)|thick-outline" )
		label:SetText( "Here" )

		label = WINDOW_MANAGER:CreateControl( nil, panelPositionCardinal, CT_LABEL )
		label:SetAnchor( BOTTOM, panelPositionCardinal, TOP, 0, 8 )
		label:SetColor( 1, 1, 1, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_24)|thick-outline" )
		label:SetText( "Position" )

		label = WINDOW_MANAGER:CreateControl( nil, panelPositionVertical, CT_LABEL )
		label:SetAnchor( BOTTOM, panelPositionVertical, TOP, 0, 8 )
		label:SetColor( 1, 1, 1, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_24)|thick-outline" )
		label:SetText( "Height" )

		label = WINDOW_MANAGER:CreateControl( nil, panelOrientation, CT_LABEL )
		label:SetAnchor( BOTTOM, panelOrientation, TOP, 0, 8 )
		label:SetColor( 1, 1, 1, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_24)|thick-outline" )
		label:SetText( "Rotation" )

		label = WINDOW_MANAGER:CreateControl( nil, panelScale, CT_LABEL )
		label:SetAnchor( BOTTOM, panelScale, TOP, 0, 8 )
		label:SetColor( 1, 1, 1, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_24)|thick-outline" )
		label:SetText( "Size" )

		label = WINDOW_MANAGER:CreateControl( nil, panelColor, CT_LABEL )
		label:SetAnchor( BOTTOM, panelColor, TOP, 0, 8 )
		label:SetColor( 1, 1, 1, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_24)|thick-outline" )
		label:SetText( "Color / Transparency" )

		label = WINDOW_MANAGER:CreateControl( nil, rpanel, CT_LABEL )
		label:SetAnchor( BOTTOM, rpanel, BOTTOM, 0, -20 )
		label:SetColor( 0.8, 0.8, 0.8, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_18)|thick-outline" )
		label:SetText( "|cffffeeCTRL + Click|r = |cffffeesmall|r changes      |cffffeeSHIFT + Click|r = |cffffeelarge|r changes      |cffffeeALT + Click|r = |cffffeehuge|r changes" )
		label:SetHorizontalAlignment( TEXT_ALIGN_CENTER )

		label = WINDOW_MANAGER:CreateControl( nil, win, CT_LABEL )
		self.EffectName = label
		label:SetAnchor( LEFT, self.CyclePanel, RIGHT, 210, 0 )
		label:SetColor( 1, 0.8, 0.4, 1 )
		label:SetWidth( 600 )
		label:SetFont( "$(GAMEPAD_MEDIUM_FONT)|$(KB_26)|thick-outline" )
		label:SetText( "" )
		label:SetMaxLineCount( 1 )
		label:SetHorizontalAlignment( TEXT_ALIGN_LEFT )

		local pCustom = WINDOW_MANAGER:CreateControl( prefix .. "MetaDataPanel", rpanel, CONTROL )
		self.CustomPanel = pCustom
		pCustom:SetAnchor( BOTTOMLEFT, self.CyclePanel, TOPLEFT, 0, -20 )
		pCustom:SetDrawLevel( baseDrawLevel )
		pCustom:SetInheritAlpha( false )
		pCustom:SetMouseEnabled( true )
		pCustom:SetResizeToFitDescendents( true )

		local pCustomBackdrop = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_TEXTURE )
		self.CustomPanelBackdrop = pCustomBackdrop
		pCustomBackdrop:SetExcludeFromResizeToFitExtents( true )
		pCustomBackdrop:SetAnchor( TOPLEFT, pCustom, TOPLEFT, -10, -10 )
		pCustomBackdrop:SetAnchor( BOTTOMRIGHT, pCustom, BOTTOMRIGHT, 10, 10 )
		pCustomBackdrop:SetInheritAlpha( false )
		pCustomBackdrop:SetMouseEnabled( false )
		pCustomBackdrop:SetColor( 0, 0, 0, 0.3 )

		tex = WINDOW_MANAGER:CreateControl( nil, panelOptions, CT_TEXTURE )
		self.SaveButton = tex
		tex:SetAnchor( TOPLEFT, panelOptions, TOPLEFT, 5, 10 )
		tex:SetAnchor( BOTTOMRIGHT, panelOptions, TOPRIGHT, -5, 44 )
		tex:SetDrawLayer(DL_CONTROLS)
		tex:SetVertexColors( 1, 0, 0.5, 0.7, 1 )
		tex:SetVertexColors( 2 + 4, 0, 0.25, 0.45, 0.85 )
		tex:SetVertexColors( 8, 0, 0.1, 0.2, 0.7 )
		tex:SetMouseEnabled( true )
		tex:SetHandler( "OnMouseDown", EHT.EffectEditor.OnDoneButtonClick )

		label = WINDOW_MANAGER:CreateControl( nil, self.SaveButton, CT_LABEL )
		self.SaveLabel = label
		label:SetAnchor( CENTER, self.SaveButton, CENTER, 0, 0 )
		label:SetColor( 1, 1, 1, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_28)|thick-outline" )
		label:SetText( "Done" )
		label:SetMouseEnabled( false )
		label:SetHorizontalAlignment( TEXT_ALIGN_CENTER )

		tex = WINDOW_MANAGER:CreateControl( nil, panelOptions, CT_TEXTURE )
		self.SelectButton = tex
		tex:SetAnchor( TOPLEFT, self.SaveButton, BOTTOMLEFT, 0, 15 )
		tex:SetAnchor( BOTTOMRIGHT, self.SaveButton, BOTTOMRIGHT, 0, 45 )
		tex:SetDrawLayer(DL_CONTROLS)
		tex:SetVertexColors( 1, 0, 0.5, 0.7, 1 )
		tex:SetVertexColors( 2 + 4, 0, 0.25, 0.45, 0.85 )
		tex:SetVertexColors( 8, 0, 0.1, 0.2, 0.7 )
		tex:SetMouseEnabled( true )
		tex:SetHandler( "OnMouseDown", EHT.EffectEditor.OnSelectButtonClick )

		label = WINDOW_MANAGER:CreateControl( nil, self.SelectButton, CT_LABEL )
		self.SelectLabel = label
		label:SetAnchor( CENTER, self.SelectButton, CENTER, 0, 0 )
		label:SetColor( 1, 1, 1, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_18)|thick-outline" )
		label:SetText( "Select" )
		label:SetMouseEnabled( false )
		label:SetHorizontalAlignment( TEXT_ALIGN_CENTER )

		tex = WINDOW_MANAGER:CreateControl( nil, panelOptions, CT_TEXTURE )
		self.CloneButton = tex
		tex:SetAnchor( TOPLEFT, self.SelectButton, BOTTOMLEFT, 0, 15 )
		tex:SetAnchor( BOTTOMRIGHT, self.SelectButton, BOTTOMRIGHT, 0, 45 )
		tex:SetDrawLayer(DL_CONTROLS)
		tex:SetVertexColors( 1, 0, 0.5, 0.7, 1 )
		tex:SetVertexColors( 2 + 4, 0, 0.25, 0.45, 0.85 )
		tex:SetVertexColors( 8, 0, 0.1, 0.2, 0.7 )
		tex:SetMouseEnabled( true )
		tex:SetHandler( "OnMouseDown", EHT.EffectEditor.OnCloneButtonClick )

		label = WINDOW_MANAGER:CreateControl( nil, self.CloneButton, CT_LABEL )
		self.CloneLabel = label
		label:SetAnchor( CENTER, self.CloneButton, CENTER, 0, 0 )
		label:SetColor( 1, 1, 1, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_18)|thick-outline" )
		label:SetText( "Clone" )
		label:SetMouseEnabled( false )
		label:SetHorizontalAlignment( TEXT_ALIGN_CENTER )

		tex = WINDOW_MANAGER:CreateControl( nil, panelOptions, CT_TEXTURE )
		self.DeleteButton = tex
		tex:SetAnchor( TOPLEFT, self.CloneButton, BOTTOMLEFT, 0, 15 )
		tex:SetAnchor( BOTTOMRIGHT, self.CloneButton, BOTTOMRIGHT, 0, 45 )
		tex:SetDrawLayer(DL_CONTROLS)
		tex:SetVertexColors( 1, 0, 0.5, 0.7, 1 )
		tex:SetVertexColors( 2 + 4, 0, 0.25, 0.45, 0.85 )
		tex:SetVertexColors( 8, 0, 0.1, 0.2, 0.7 )
		tex:SetMouseEnabled( true )
		tex:SetHandler( "OnMouseDown", EHT.EffectEditor.OnDeleteButtonClick )

		label = WINDOW_MANAGER:CreateControl( nil, self.DeleteButton, CT_LABEL )
		self.DeleteLabel = label
		label:SetAnchor( CENTER, self.DeleteButton, CENTER, 0, 0 )
		label:SetColor( 1, 1, 1, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_18)|thick-outline" )
		label:SetText( "Delete" )
		label:SetMouseEnabled( false )
		label:SetHorizontalAlignment( TEXT_ALIGN_CENTER )

		local function AddButton( index, panel, anchorControl, anchorFrom, anchorTo, anchorX, anchorY, onClick, texture, textureAngle, textureWidth, textureHeight )
			if nil == anchorControl then anchorControl = panel end
			local tex = WINDOW_MANAGER:CreateControl( nil, panel, CT_TEXTURE )

			tex:SetHidden( true )
			tex:SetTexture( texture )
			tex.Index = index
			tex:SetAnchor( anchorFrom, anchorControl, anchorTo, anchorX, anchorY )
			--tex:SetDrawLevel( baseDrawLevel + 1 )
			--tex:SetDrawTier(DT_HIGH)
			tex:SetDrawLayer(DL_CONTROLS)
			tex:SetMouseEnabled( true )
			tex:SetBlendMode( TEX_BLEND_MODE_ALPHA )
			tex:SetColor( 1, 1, 1, 0.85 )

			if textureAngle then
				tex:SetTextureRotation( textureAngle )
				tex:SetDimensions( 64, 64 )
			end

			if textureWidth and textureHeight then
				tex:SetDimensions( textureWidth, textureHeight )
			end

			local handle = "EHT.OnEditEffectClick" .. tostring( index )
			local startUpdate, nextUpdate
			local UPDATE_INTERVAL, ANIM_INTERVAL = 200, 400

			tex:SetHandler( "OnMouseDown", function( control )
				onClick( control )
				local ft = FrameTime
				startUpdate, nextUpdate = ft, ft + UPDATE_INTERVAL
				tex:SetTextureSampleProcessingWeight( TEX_SAMPLE_PROCESSING_RGB, 1.5 )

				EVENT_MANAGER:RegisterForUpdate( handle, 1, function()
					local ft = FrameTime
					local delta = ft - nextUpdate

					if UPDATE_INTERVAL <= delta then
						onClick( control )
						nextUpdate = ft + UPDATE_INTERVAL
					end

					delta = 0.5 * math.sin( ( ( ( ft - startUpdate ) % ANIM_INTERVAL ) / ANIM_INTERVAL ) * 2 * math.pi )
					tex:SetTextureSampleProcessingWeight( TEX_SAMPLE_PROCESSING_RGB, 1 + delta )
				end )
			end )

			tex:SetHandler( "OnMouseUp", function()
				tex:SetTextureSampleProcessingWeight( TEX_SAMPLE_PROCESSING_RGB, 1 )
				EVENT_MANAGER:UnregisterForUpdate( handle )
			end )

			return tex
		end

		local MOVE_HERE_TEXTURE = "esoui/art/mappins/battlegrounds_capturepoint_pin_neutral.dds"
		local POSITION_ARROW_TEXTURE = TEXTURES.ARROW_1
		local ROTATION_ARROW_TEXTURE = TEXTURES.ARROW_1
		local SCALE_ICON_TEXTURE = "esoui/art/guild/gamepad/gp_guild_options_changeicon.dds"
		local SCALE_TEXTURE = TEXTURES.ARROW_1

		local MOVE_HERE_CLICK = EHT.EffectEditor.OnMoveHereButtonClick
		local ARROW_CLICK = EHT.EffectEditor.OnArrowButtonClick
		local COLOR_CLICK = EHT.EffectEditor.OnColorButtonClick
		local CONTRAST_CLICK = EHT.EffectEditor.OnContrastButtonClick
		local TRANSPARENCY_CLICK = EHT.EffectEditor.OnTransparencyButtonClick
		local SCALE_CLICK = EHT.EffectEditor.OnScaleButtonClick
		local CYCLE_CLICK = EHT.EffectEditor.OnCycleButtonClick

		self.MoveHere = AddButton( 1, panelBringToMe, nil, TOP, TOP, 0, 40, MOVE_HERE_CLICK, MOVE_HERE_TEXTURE, 0, 96, 96 )
		self.MoveHere:SetColor( 0, 0.7, 1, 0.85 )
		self.MoveHere:SetTextureCoords( 0.25, 0.75, 0, 1 )
		self.MoveHere:SetWidth( 48 )

		self.Arrows[ 1 ] = AddButton( 1, panelPositionCardinal, nil, TOP, TOP, 0, 10, ARROW_CLICK, POSITION_ARROW_TEXTURE, math.rad( 90 ) )
		self.Arrows[ 2 ] = AddButton( 2, panelPositionCardinal, nil, TOP, BOTTOM, 0, -10, ARROW_CLICK, POSITION_ARROW_TEXTURE, math.rad( 270 ) )
		self.Arrows[ 3 ] = AddButton( 3, panelPositionCardinal, nil, TOP, LEFT, 10, 0, ARROW_CLICK, POSITION_ARROW_TEXTURE, math.rad( 180 ) )
		self.Arrows[ 4 ] = AddButton( 4, panelPositionCardinal, nil, TOP, RIGHT, -10, 0, ARROW_CLICK, POSITION_ARROW_TEXTURE, math.rad( 0 ) )

		self.Arrows[ 6 ] = AddButton( 6, panelPositionVertical, nil, TOP, TOP, 0, 10, ARROW_CLICK, POSITION_ARROW_TEXTURE, math.rad( 90 ) )
		self.Arrows[ 5 ] = AddButton( 5, panelPositionVertical, nil, TOP, BOTTOM, 0, -10, ARROW_CLICK, POSITION_ARROW_TEXTURE, math.rad( 270 ) )

		self.Arrows[ 7 ] = AddButton( 7, panelOrientation, nil, TOP, LEFT, 10, 0, ARROW_CLICK, POSITION_ARROW_TEXTURE, math.rad( 180 ) )
		self.Arrows[ 8 ] = AddButton( 8, panelOrientation, nil, TOP, RIGHT, -10, 0, ARROW_CLICK, POSITION_ARROW_TEXTURE, math.rad( 0 ) )
		self.Arrows[ 9 ] = AddButton( 9, panelOrientation, nil, TOP, TOP, 0, 10, ARROW_CLICK, POSITION_ARROW_TEXTURE, math.rad( 90 ) )
		self.Arrows[ 10 ] = AddButton( 10, panelOrientation, nil, TOP, BOTTOM, 0, -10, ARROW_CLICK, POSITION_ARROW_TEXTURE, math.rad( 270 ) )

		self.Scales[ 1 ] = AddButton( 1, panelScale, nil, TOP, BOTTOM, 0, -10, SCALE_CLICK, POSITION_ARROW_TEXTURE, math.rad( 270 ) )
		self.Scales[ 2 ] = AddButton( 2, panelScale, nil, TOP, TOP, 0, 10, SCALE_CLICK, POSITION_ARROW_TEXTURE, math.rad( 90 ) )
		self.Scales[ 3 ] = AddButton( 3, panelScale, nil, TOP, LEFT, 10, 0, SCALE_CLICK, POSITION_ARROW_TEXTURE, math.rad( 180 ) )
		self.Scales[ 4 ] = AddButton( 4, panelScale, nil, TOP, RIGHT, -10, 0, SCALE_CLICK, POSITION_ARROW_TEXTURE, math.rad( 0 ) )

		self.Colors = WINDOW_MANAGER:CreateControl( "SColor", panelColor, CT_COLORSELECT )
		self.Colors:SetAnchor( TOPLEFT, panelColor, TOPLEFT, 0, 10 )
		self.Colors:SetDimensions( 132, 132 )
		self.Colors:SetDrawLevel( baseDrawLevel )
		self.Colors:SetMouseEnabled( true )
		self.Colors:SetHandler( "OnMouseUp", function() COLOR_CLICK( self.Colors ) end )

		self.CurrentColor = WINDOW_MANAGER:CreateControl( nil, panelColor, CT_TEXTURE )
		self.CurrentColor:SetAnchor( BOTTOM, self.Colors, TOP, 0, -4 )
		self.CurrentColor:SetDimensions( 32, 32 )
		self.CurrentColor:SetColor( 0, 0, 0, 1 )
		self.CurrentColor:SetDrawLayer( DL_OVERLAY )
		self.CurrentColor:SetDrawTier( DT_HIGH )
		self.CurrentColor:SetDrawLevel( baseDrawLevel + 1 )
		self.CurrentColor:SetTexture( TEXTURES.COLOR_PICKER )
		self.CurrentColor:SetMouseEnabled( false )

		self.Colors:SetColorWheelThumbTextureControl( self.CurrentColor )

		do
			local b = WINDOW_MANAGER:CreateControl( nil, self.CurrentColor, CT_TEXTURE )
			self.CurrentColorValueBackdrop = b
			b:SetTexture( TEXTURES.SOLID )
			b:SetAnchor( TOPLEFT, self.Colors, TOPLEFT, 150, 174 )
			b:SetAnchor( BOTTOMRIGHT, self.Colors, TOPLEFT, 225, 198 )
			b:SetColor( 0, 0, 0, 1 )
			--b:SetDrawLayer( DL_OVERLAY )
			--b:SetDrawTier( DT_HIGH )
			--b:SetDrawLevel( baseDrawLevel + 2 )
			b:SetDrawLayer(DL_CONTROLS)
			b:SetMouseEnabled( false )
			b:SetHidden( true )

			local c = WINDOW_MANAGER:CreateControl( nil, self.CurrentColorValueBackdrop, CT_LABEL )
			self.CurrentColorValueLabel = c
			c:SetAnchor( CENTER, self.CurrentColorValueBackdrop, CENTER, 0, 0 )
			c:SetColor( 1, 1, 1, 1 )
			c:SetDrawLayer( DL_OVERLAY )
			c:SetDrawTier( DT_HIGH )
			c:SetDrawLevel( baseDrawLevel + 3 )
			c:SetFont( "$(MEDIUM_FONT)|$(KB_16)" )
			c:SetText( "" )
			c:SetMouseEnabled( false )
			c:SetHorizontalAlignment( TEXT_ALIGN_CENTER )
		end

		local function OnHideColorValue()
			self.CurrentColorValueBackdrop:SetHidden( true )
		end

		local function OnColorValueChanged( value )
			EVENT_MANAGER:UnregisterForUpdate( "EHT.HideColorValue" )
			self.CurrentColorValueLabel:SetText( tostring( value ) )
			self.CurrentColorValueBackdrop:SetHidden( false )
			EVENT_MANAGER:RegisterForUpdate( "EHT.HideColorValue", 1000, OnHideColorValue )
		end

		do
			local function OnUpdate()
				local ctl = self.Gray
				local mouseX, mouseY = GetUIMousePosition()
				local left, top, right, bottom = ctl:GetScreenRect()
				local value = EHT.Util.SnapToPercent( zo_clamp( ( mouseX - left ) / ( right - left ), 0, 1 ) )
				COLOR_CLICK( nil, nil, value, value, value )
			end

			local b = WINDOW_MANAGER:CreateControl( nil, panelColor, CT_TEXTURE )
			b:SetAnchor( TOPLEFT, self.Colors, BOTTOMLEFT, 0, 12 )
			b:SetAnchor( TOPRIGHT, self.Colors, BOTTOMLEFT, 134, 12 )
			b:SetColor( 0, 0, 0, 1 )
			b:SetHeight( 24 )
			b:SetMouseEnabled( false )

			local c = WINDOW_MANAGER:CreateControl( nil, b, CT_TEXTURE )
			self.Gray = c
			c:SetAnchor( TOPLEFT, b, TOPLEFT, 2, 2 )
			c:SetAnchor( BOTTOMRIGHT, b, BOTTOMRIGHT, -2, -2 )
			--c:SetDrawLevel(baseDrawLevel + 10)
			--c:SetDrawTier(DT_HIGH)
			c:SetDrawLayer(DL_CONTROLS)
			c:SetInheritAlpha( false )
			c:SetVertexColors( 1 + 4, 0, 0, 0, 1 )
			c:SetVertexColors( 2 + 8, 1, 1, 1, 1 )
			c:SetMouseEnabled( true )
			c:SetHandler( "OnMouseDown", function( ctl ) OnUpdate() EVENT_MANAGER:RegisterForUpdate( "EHT.OnUpdateGray", 200, OnUpdate ) end )
			c:SetHandler( "OnMouseUp", function( ctl ) EVENT_MANAGER:UnregisterForUpdate( "EHT.OnUpdateGray" ) end )
			EHT.UI.SetInfoTooltip( c, "Grayscale" )
		end

		do
			local function OnUpdate()
				local ctl = self.Saturation
				local mouseX, mouseY = GetUIMousePosition()
				local left, top, right, bottom = ctl:GetScreenRect()
				local value = EHT.Util.SnapToPercent( zo_clamp( ( mouseY - bottom ) / ( top - bottom ), 0.01, 1 ) )
				COLOR_CLICK( nil, value )
			end

			local b = WINDOW_MANAGER:CreateControl( nil, panelColor, CT_TEXTURE )
			b:SetTexture( TEXTURES.SLIDER_BORDER )
			b:SetTextureReleaseOption( RELEASE_TEXTURE_AT_ZERO_REFERENCES )
			b:SetAnchor( TOPLEFT, self.Colors, TOPLEFT, 140, 0 )
			b:SetAnchor( BOTTOMRIGHT, self.Colors, TOPLEFT, 165, 170 )
			b:SetColor( 0, 0, 0, 1 )
			b:SetMouseEnabled( false )

			local c = WINDOW_MANAGER:CreateControl( nil, b, CT_TEXTURE )
			self.Saturation = c
			c:SetAnchor( TOPLEFT, b, TOPLEFT, 2, 2 )
			c:SetAnchor( BOTTOMRIGHT, b, BOTTOMRIGHT, -2, -2 )
			--c:SetDrawLevel(baseDrawLevel + 10)
			--c:SetDrawTier(DT_HIGH)
			c:SetDrawLayer(DL_CONTROLS)
			c:SetInheritAlpha( false )
			c:SetVertexColors( 1 + 2, 1, 1, 1, 1 )
			c:SetVertexColors( 4 + 8, 0, 0, 0, 1 )
			c:SetMouseEnabled( true )
			c:SetHandler( "OnMouseDown", function( ctl ) OnUpdate() EVENT_MANAGER:RegisterForUpdate( "EHT.OnUpdateSaturation", 200, OnUpdate ) end )
			c:SetHandler( "OnMouseUp", function( ctl ) EVENT_MANAGER:UnregisterForUpdate( "EHT.OnUpdateSaturation" ) end )
			EHT.UI.SetInfoTooltip( c, "Saturation" )
		end

		do
			local function OnUpdate()
				local ctl = self.Contrast
				local mouseX, mouseY = GetUIMousePosition()
				local left, top, right, bottom = ctl:GetScreenRect()
				local value = zo_clamp( EHT.Util.SnapToPercent( zo_lerp( 0.01, 4, ( mouseY - bottom ) / ( top - bottom ) ), self.Effect:GetContrast() ), 0.01, 4 )
				CONTRAST_CLICK( nil, value )
				OnColorValueChanged( string.format( "%d%%", 100 * value ) )
			end

			local b = WINDOW_MANAGER:CreateControl( nil, panelColor, CT_TEXTURE )
			self.ContrastBackdrop = b
			b:SetTexture( TEXTURES.SLIDER_BORDER )
			b:SetTextureReleaseOption( RELEASE_TEXTURE_AT_ZERO_REFERENCES )
			b:SetAnchor( TOPLEFT, self.Colors, TOPLEFT, 175, 0 )
			b:SetAnchor( BOTTOMRIGHT, self.Colors, TOPLEFT, 200, 170 )
			b:SetColor( 0, 0, 0, 1 )
			b:SetMouseEnabled( false )

			local cv = WINDOW_MANAGER:CreateControl( nil, b, CT_TEXTURE )
			self.CurrentContrast = cv
			cv:SetTexture( TEXTURES.SLIDER_INDICATOR )
			cv:SetTextureReleaseOption( RELEASE_TEXTURE_AT_ZERO_REFERENCES )
			cv:SetAnchor( TOPLEFT, b, TOPLEFT, -5, 0 )
			cv:SetAnchor( BOTTOMRIGHT, b, TOPRIGHT, 5, 5 )
			--cv:SetDrawLevel(baseDrawLevel + 11)
			--cv:SetDrawTier(DT_HIGH)
			cv:SetDrawLayer(DL_CONTROLS)
			cv:SetColor( 1, 1, 1, 0.8 )
			cv:SetInheritAlpha( false )
			cv:SetMouseEnabled( false )

			local baseColor = WINDOW_MANAGER:CreateControl( nil, b, CT_TEXTURE )
			self.ContrastBase = baseColor
			baseColor:SetAnchor( TOPLEFT, b, TOPLEFT, 2, 2 )
			baseColor:SetAnchor( BOTTOMRIGHT, b, BOTTOMRIGHT, -2, -2 )
			baseColor:SetColor( 1, 1, 1, 1 )
			baseColor:SetTextureSampleProcessingWeight( TEX_SAMPLE_PROCESSING_RGB, 0.5 )
			baseColor:SetMouseEnabled( false )

			local c = WINDOW_MANAGER:CreateControl( nil, b, CT_TEXTURE )
			self.Contrast = c
			c:SetAnchor( TOPLEFT, b, TOPLEFT, 2, 2 )
			c:SetAnchor( BOTTOMRIGHT, b, BOTTOMRIGHT, -2, -2 )
			--c:SetDrawLevel(baseDrawLevel + 10)
			--c:SetDrawTier(DT_HIGH)
			c:SetDrawLayer(DL_CONTROLS)
			c:SetInheritAlpha( false )
			c:SetVertexColors( 1 + 2, 1, 1, 1, 1 )
			c:SetVertexColors( 4 + 8, 1, 1, 1, 0 )
			c:SetTextureSampleProcessingWeight( TEX_SAMPLE_PROCESSING_RGB, 4 )
			c:SetMouseEnabled( true )
			c:SetHandler( "OnMouseDown", function( ctl ) OnUpdate() EVENT_MANAGER:RegisterForUpdate( "EHT.OnUpdateContrast", 200, OnUpdate ) end )
			c:SetHandler( "OnMouseUp", function( ctl ) EVENT_MANAGER:UnregisterForUpdate( "EHT.OnUpdateContrast" ) end )
			EHT.UI.SetInfoTooltip( c, "Contrast" )
		end

		do
			local function OnUpdate()
				local ctl = self.Transparency
				local mouseX, mouseY = GetUIMousePosition()
				local left, top, right, bottom = ctl:GetScreenRect()
				local value = zo_clamp( EHT.Util.SnapToPercent( ( mouseY - bottom ) / ( top - bottom ), self.Effect:GetTransparency() ), 0, 1 )
				TRANSPARENCY_CLICK( nil, value )
				OnColorValueChanged( string.format( "%d%%", 100 * value ) )
			end

			local b = WINDOW_MANAGER:CreateControl( nil, panelColor, CT_TEXTURE )
			self.TransparencyBackdrop = b
			b:SetTexture( TEXTURES.SLIDER_BORDER )
			b:SetTextureReleaseOption( RELEASE_TEXTURE_AT_ZERO_REFERENCES )
			b:SetAnchor( TOPLEFT, self.Colors, TOPLEFT, 210, 0 )
			b:SetAnchor( BOTTOMRIGHT, self.Colors, TOPLEFT, 235, 170 )
			b:SetColor( 0, 0, 0, 1 )
			b:SetMouseEnabled( false )

			local cv = WINDOW_MANAGER:CreateControl( nil, b, CT_TEXTURE )
			self.CurrentTransparency = cv
			cv:SetTexture( TEXTURES.SLIDER_INDICATOR )
			cv:SetTextureReleaseOption( RELEASE_TEXTURE_AT_ZERO_REFERENCES )
			cv:SetAnchor( TOPLEFT, b, TOPLEFT, -5, 0 )
			cv:SetAnchor( BOTTOMRIGHT, b, TOPRIGHT, 5, 5 )
			--cv:SetDrawLevel(baseDrawLevel + 11)
			--cv:SetDrawTier(DT_HIGH)
			cv:SetDrawLayer(DL_CONTROLS)
			cv:SetInheritAlpha( false )
			cv:SetColor( 1, 1, 1, 0.8 )
			cv:SetMouseEnabled( false )

			local c = WINDOW_MANAGER:CreateControl( nil, b, CT_TEXTURE )
			self.Transparency = c
			c:SetAnchor( TOPLEFT, b, TOPLEFT, 2, 2 )
			c:SetAnchor( BOTTOMRIGHT, b, BOTTOMRIGHT, -2, -2 )
			--c:SetDrawLevel(baseDrawLevel + 10)
			--c:SetDrawTier(DT_HIGH)
			c:SetDrawLayer(DL_CONTROLS)
			c:SetInheritAlpha( false )
			c:SetVertexColors( 1 + 2, 1, 1, 1, 0.8 )
			c:SetVertexColors( 4 + 8, 1, 1, 1, 0 )
			c:SetMouseEnabled( true )
			c:SetHandler( "OnMouseDown", function( ctl ) OnUpdate() EVENT_MANAGER:RegisterForUpdate( "EHT.OnUpdateTransparency", 200, OnUpdate ) end )
			c:SetHandler( "OnMouseUp", function( ctl ) EVENT_MANAGER:UnregisterForUpdate( "EHT.OnUpdateTransparency" ) end )
			EHT.UI.SetInfoTooltip( c, "Transparency" )
		end

		self.NextEffect = AddButton( 1, panelCycle, nil, BOTTOMRIGHT, BOTTOMRIGHT, 0, 0, CYCLE_CLICK, POSITION_ARROW_TEXTURE, math.rad( 0 ) )
		self.PreviousEffect = AddButton( 2, panelCycle, nil, BOTTOMLEFT, BOTTOMLEFT, 0, 0, CYCLE_CLICK, POSITION_ARROW_TEXTURE, math.rad( 180 ) )

		self.NextEffect:SetDimensions( 50, 50 )
		self.NextEffect:SetColor( 0, 1, 1, 1 )
		self.PreviousEffect:SetDimensions( 50, 50 )
		self.PreviousEffect:SetColor( 0, 1, 1, 1 )

		label = WINDOW_MANAGER:CreateControl( nil, panelPositionCardinal, CT_LABEL )
		self.TogglePositionSystem = label
		label:SetAnchor( BOTTOM, panelPositionCardinal, TOP, 0, -24 )
		label:SetColor( 1, 1, 0.8, 1 )
		label:SetFont( "$(BOLD_FONT)|$(KB_18)|thick-outline" )
		label:SetWidth( 200 )
		label:SetText( "Switch to N-S-E-W" )
		label:SetHorizontalAlignment( TEXT_ALIGN_CENTER )
		label:SetMouseEnabled( true )
		label:SetHandler( "OnMouseDown", EHT.EffectEditor.OnTogglePositionSystemClick )

		EHT.UI.SetInfoTooltip( self.NextEffect, "Edit the next nearest Effect." )
		EHT.UI.SetInfoTooltip( self.PreviousEffect, "Edit the previous nearest Effect." )

		do
			local groupId = EHT.UI.Picklist:New( "EffectGroupId", win, LEFT, self.CyclePanel, RIGHT, 40, 0, 140, 28 )
			self.EffectGroupId = groupId
			groupId:AddItem( "No Effect Group", nil, 0 )
			for index = EHT.CONST.EFFECT_GROUP_ID_MIN, EHT.CONST.EFFECT_GROUP_ID_MAX do
				groupId:AddItem( string.format( "Effect Group %d", 1 + index - EHT.CONST.EFFECT_GROUP_ID_MIN ), nil, EHT.Housing.GetEffectGroupBit( index ) )
			end
			groupId:Refresh()
			groupId:AddHandler( "OnSelectionChanged", function( control, item )
				local effect = self.Effect
				if effect then
					effect:SetEffectGroup( item.Value )
					effect:UpdateRecord()
				end
			end )
		end

		do
			local ui = { }
			self.ParamDestination = ui

			c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.TargetContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetResizeToFitDescendents( true )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControl( nil, ui.TargetContainer, CT_TEXTURE )
			ui.TargetPlayerContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOPLEFT, ui.TargetContainer, TOPLEFT, 8, 0 )
			c:SetInheritAlpha( false )
			c:SetColor( 0.5, 0.5, 0.5, 1 )
			c:SetDimensions( 204, 30 )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControlFromVirtual( nil, ui.TargetPlayerContainer, "ZO_EditBackdrop" )
			ui.TargetPlayerBackdrop = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( LEFT, ui.TargetPlayerContainer, LEFT, 2, 0 )
			c:SetAlpha( 1 )
			c:SetEdgeColor( 0, 0, 0, 1 )
			c:SetCenterColor( 0, 0, 0, 1 )
			c:SetDimensions( 200, 26 )
			c:SetInheritAlpha( false )

			c = WINDOW_MANAGER:CreateControlFromVirtual( nil, ui.TargetPlayerBackdrop, "ZO_DefaultEditForBackdrop" )
			ui.TargetPlayer = c
			c:SetFont( "$(MEDIUM_FONT)|$(KB_16)|soft-shadow-thin" )
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOPLEFT, ui.TargetPlayerBackdrop, TOPLEFT, 4, 2 )
			c:SetAnchor( BOTTOMRIGHT, ui.TargetPlayerBackdrop, BOTTOMRIGHT, -4, -2 )
			c:SetMaxInputChars( 64 )
			c:SetMultiLine( false )
			c:SetNewLineEnabled( false )
			c:SetMouseEnabled( true )
			c:SetText( DEFAULT_PARAM_TARGET_PLAYER_TEXT )
			c:SetHandler( "OnMouseUp", function() zo_callLater( function() ui.TargetPlayer:SelectAll() end, 50 ) end )
-- TRANSFER TO HUB
			c = EHT.UI.Picklist:New("EffectParamTargetHouse", ui.TargetContainer, LEFT, ui.TargetPlayerContainer, RIGHT, 10, 0, 360, 26)
			ui.TargetHouse = c
			local targetHouseControl = c
			c.HouseId = 0
			c:AddItem("Primary Home", nil, 0)
			local houses = {}
			for _, house in pairs(EHT.Housing.GetAllHouses()) do
				table.insert(houses, house)
			end
			table.sort(houses, function(itemA, itemB) return itemA.Name < itemB.Name end)
			for _, house in ipairs(houses) do
				c:AddItem(house.Name, nil, house.Id)
			end
			c:Refresh()
			c:AddHandler("OnSelectionChanged", function(control, item)
				targetHouseControl.HouseId = item.Value
			end)
-- TRANSFER TO HUB
			c = WINDOW_MANAGER:CreateControl( nil, ui.TargetContainer, CT_TEXTURE )
			ui.TargetButtonContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( LEFT, ui.TargetHouse:GetControl(), RIGHT, 10, 0 )
			c:SetDimensions( 60, 30 )
			c:SetColor( 1, 1, 1, 1 )

			c = WINDOW_MANAGER:CreateControl( nil, ui.TargetButtonContainer, CT_TEXTURE )
			ui.TargetButton = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( CENTER, ui.TargetButtonContainer, CENTER, 0, 0 )
			c:SetDimensions( 56, 26 )
			c:SetColor( 0.05, 0, 0.7, 1 )
			c:SetDrawLayer(DL_CONTROLS)
			c:SetMouseEnabled( true )
			c:SetHandler( "OnMouseDown", function()
				local houseId = ui.TargetHouse.HouseId
				local player = EHT.Util.Trim( ui.TargetPlayer:GetText() )
				if not player or "" == player or player == DEFAULT_PARAM_TARGET_PLAYER_TEXT or "@" ~= string.sub(player, 1, 1) then
					EHT.UI.ShowAlertDialog("", "Please enter the |cffff66@name|r of the homeowner.")
					return
				end

				local e = self.Effect
				e:SetMetaData("HouseId", houseId)
				e:SetMetaData("Owner", player)
				e:UpdateRecord()
				e:Reset()
			end )

			c = WINDOW_MANAGER:CreateControl( nil, ui.TargetButton, CT_LABEL )
			ui.TargetButtonLabel = c
			c:SetDrawLevel( baseDrawLevel + 2 )
			c:SetFont( "$(BOLD_FONT)|$(KB_18)|soft-shadow-thin" )
			c:SetAnchor( CENTER, ui.TargetButton, CENTER, 0, 0 )
			c:SetText( "Set" )
			c:SetColor( 1, 1, 1, 1 )
		end

		do
			local ui = { }
			self.ParamMessage = ui

			c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.MessageContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetResizeToFitDescendents( true )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControl( nil, ui.MessageContainer, CT_TEXTURE )
			ui.MessageOutline = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOPLEFT, ui.MessageContainer, TOPLEFT, 8, 0 )
			c:SetInheritAlpha( false )
			c:SetColor( 0.5, 0.5, 0.5, 1 )
			c:SetDimensions( 504, 56 )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControlFromVirtual( nil, ui.MessageOutline, "ZO_EditBackdrop" )
			ui.MessageBackdrop = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( LEFT, ui.MessageOutline, LEFT, 2, 0 )
			c:SetAlpha( 1 )
			c:SetEdgeColor( 0, 0, 0, 1 )
			c:SetCenterColor( 0, 0, 0, 1 )
			c:SetDimensions( 500, 52 )
			c:SetInheritAlpha( false )

			c = WINDOW_MANAGER:CreateControlFromVirtual( nil, ui.MessageBackdrop, "ZO_DefaultEditForBackdrop" )
			ui.Message = c
			c:SetFont( "$(CHAT_FONT)|$(KB_16)|soft-shadow-thin" )
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOPLEFT, ui.MessageBackdrop, TOPLEFT, 4, 2 )
			c:SetAnchor( BOTTOMRIGHT, ui.MessageBackdrop, BOTTOMRIGHT, -4, -2 )
			c:SetMaxInputChars( MAX_META_STRING_LEN )
			c:SetMultiLine( true )
			-- c:SetNewLineEnabled( true )
			c:SetMouseEnabled( true )
			c:SetText( DEFAULT_PARAM_TARGET_PLAYER_TEXT )
			c:SetHandler( "OnEnter", function( ... ) end )

			c = WINDOW_MANAGER:CreateControl( nil, ui.MessageContainer, CT_TEXTURE )
			ui.SetButtonOutline = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( LEFT, ui.MessageOutline, RIGHT, 10, 0 )
			c:SetDimensions( 60, 30 )
			c:SetColor( 1, 1, 1, 1 )

			c = WINDOW_MANAGER:CreateControl( nil, ui.SetButtonOutline, CT_TEXTURE )
			ui.SetButton = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetDrawLayer(DL_CONTROLS)
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( CENTER, ui.SetButtonOutline, CENTER, 0, 0 )
			c:SetDimensions( 56, 26 )
			c:SetColor( 0.05, 0, 0.7, 1 )
			c:SetMouseEnabled( true )
			c:SetHandler( "OnMouseDown", function()
				local msg = ui.Message:GetText()

				if msg and MAX_META_STRING_LEN < #msg then
					EHT.UI.ShowAlertDialog( "", string.format( "This field may may not exceed |cffff66%d|r characters.", MAX_META_STRING_LEN ) )
					return
				end

				msg = string.sub( TransformCharsForDeserialization( ExcludeInvalidStringChars( TransformCharsForSerialization( tostring( msg ) ) ) ), 1, MAX_META_STRING_LEN )
				ui.Message:SetText( msg )

				if not msg or "" == msg or msg == DEFAULT_PARAM_MESSAGE_TEXT then
					EHT.UI.ShowAlertDialog( "", "Please enter a |cffff66message|r." )
					return
				end

				local e = self.Effect
				e:SetMetaData( "Message", msg )
				e:UpdateRecord()
				e:Reset()
			end )

			c = WINDOW_MANAGER:CreateControl( nil, ui.SetButton, CT_LABEL )
			ui.SetButtonLabel = c
			c:SetDrawLevel( baseDrawLevel + 2 )
			c:SetFont( "$(BOLD_FONT)|$(KB_18)|soft-shadow-thin" )
			c:SetAnchor( CENTER, ui.SetButton, CENTER, 0, 0 )
			c:SetText( "Set" )
			c:SetColor( 1, 1, 1, 1 )
		end

		do
			local ui = { }
			self.ParamGuildId = ui

			local c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.GuildIdContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetResizeToFitDescendents( true )
			c:SetMouseEnabled( false )

			c = EHT.UI.Picklist:New( "EffectParamGuildId", ui.GuildIdContainer, LEFT, ui.GuildIdContainer, LEFT, 2, 0, 360, 26 )
			ui.GuildId = c
			c:SetDrawLevel( baseDrawLevel )

			c = WINDOW_MANAGER:CreateControl( nil, ui.GuildIdContainer, CT_TEXTURE )
			ui.SetButtonOutline = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( LEFT, ui.GuildId:GetControl(), RIGHT, 10, 0 )
			c:SetDimensions( 60, 30 )
			c:SetColor( 1, 1, 1, 1 )

			c = WINDOW_MANAGER:CreateControl( nil, ui.SetButtonOutline, CT_TEXTURE )
			ui.SetButton = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetDrawLayer(DL_CONTROLS)
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( CENTER, ui.SetButtonOutline, CENTER, 0, 0 )
			c:SetDimensions( 56, 26 )
			c:SetColor( 0.05, 0, 0.7, 1 )
			c:SetMouseEnabled( true )
			c:SetHandler( "OnMouseDown", function()
				local guildId = ui.GuildId:GetSelectedItemValue()

				if not guildId or 0 == guildId then
					EHT.UI.ShowAlertDialog( "", "Please select a |cffff66guild|r." )
					return
				end

				local bkgCat, bkgStyle, bkgColor1, bkgColor2, crestCat, crestStyle, crestColor = EHT.Guilds:GetGuildHeraldry( guildId )
				local e = self.Effect

				e:SetMetaData( "GuildId", guildId )
				e:SetMetaData( "HeraldryBkgCat", bkgCat )
				e:SetMetaData( "HeraldryBkgStyle", bkgStyle )
				e:SetMetaData( "HeraldryBkgColor1", bkgColor1 )
				e:SetMetaData( "HeraldryBkgColor2", bkgColor2 )
				e:SetMetaData( "HeraldryCrestCat", crestCat )
				e:SetMetaData( "HeraldryCrestStyle", crestStyle )
				e:SetMetaData( "HeraldryCrestColor", crestColor )
				e:UpdateRecord()
				e:Reset()
			end )

			c = WINDOW_MANAGER:CreateControl( nil, ui.SetButton, CT_LABEL )
			ui.SetButtonLabel = c
			c:SetDrawLevel( baseDrawLevel + 2 )
			c:SetFont( "$(BOLD_FONT)|$(KB_18)|soft-shadow-thin" )
			c:SetAnchor( CENTER, ui.SetButton, CENTER, 0, 0 )
			c:SetText( "Set" )
			c:SetColor( 1, 1, 1, 1 )
		end

		local function addTextParam( metaParamKey, defaultText, maxLen, multiLine )
			local ui = { }

			c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.Container = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetResizeToFitDescendents( true )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControl( nil, ui.Container, CT_TEXTURE )
			ui.MessageOutline = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOPLEFT, ui.Container, TOPLEFT, 8, 0 )
			c:SetInheritAlpha( false )
			c:SetColor( 0.5, 0.5, 0.5, 1 )
			c:SetDimensions( 504, multiLine and 54 or 28 )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControlFromVirtual( nil, ui.MessageOutline, "ZO_EditBackdrop" )
			ui.MessageBackdrop = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( LEFT, ui.MessageOutline, LEFT, 2, 0 )
			c:SetAlpha( 1 )
			c:SetEdgeColor( 0, 0, 0, 1 )
			c:SetCenterColor( 0, 0, 0, 1 )
			c:SetDimensions( 500, multiLine and 50 or 24 )
			c:SetInheritAlpha( false )

			c = WINDOW_MANAGER:CreateControlFromVirtual( nil, ui.MessageBackdrop, "ZO_DefaultEditForBackdrop" )
			ui.Message = c
			c:SetFont( "$(CHAT_FONT)|$(KB_16)|soft-shadow-thin" )
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOPLEFT, ui.MessageBackdrop, TOPLEFT, 4, 2 )
			c:SetAnchor( BOTTOMRIGHT, ui.MessageBackdrop, BOTTOMRIGHT, -4, -2 )
			c:SetMaxInputChars( maxLen or MAX_META_STRING_LEN )
			c:SetMultiLine( true == multiLine )
			c:SetMouseEnabled( true )
			c:SetText( DEFAULT_PARAM_TARGET_PLAYER_TEXT )
			c:SetHandler( "OnEnter", function( ... ) end )

			c = WINDOW_MANAGER:CreateControl( nil, ui.Container, CT_TEXTURE )
			ui.SetButtonOutline = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( LEFT, ui.MessageOutline, RIGHT, 10, 0 )
			c:SetDimensions( 60, 30 )
			c:SetColor( 1, 1, 1, 1 )

			c = WINDOW_MANAGER:CreateControl( nil, ui.SetButtonOutline, CT_TEXTURE )
			ui.SetButton = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetDrawLayer(DL_CONTROLS)
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( CENTER, ui.SetButtonOutline, CENTER, 0, 0 )
			c:SetDimensions( 56, 26 )
			c:SetColor( 0.05, 0, 0.7, 1 )
			c:SetMouseEnabled( true )
			c:SetHandler( "OnMouseDown", function()
				local msg = ui.Message:GetText()

				if msg and #msg > MAX_META_STRING_LEN then
					EHT.UI.ShowAlertDialog( "", string.format( "This field may not exceed |cffff66%d|r characters.", MAX_META_STRING_LEN ) )
					return
				end
 
				msg = string.sub( TransformCharsForDeserialization( ExcludeInvalidStringChars( TransformCharsForSerialization( tostring( msg ) ) ) ), 1, MAX_META_STRING_LEN )
				ui.Message:SetText( msg )

				if not msg or "" == msg or msg == defaultText then
					EHT.UI.ShowAlertDialog( "", string.format( "|cffff66%s|r.", defaultText ) )
					return
				end

				local e = self.Effect
				e:SetMetaData( metaParamKey, msg )
				e:UpdateRecord()
				e:Reset()
			end )

			c = WINDOW_MANAGER:CreateControl( nil, ui.SetButton, CT_LABEL )
			ui.SetButtonLabel = c
			c:SetDrawLevel( baseDrawLevel + 2 )
			c:SetFont( "$(BOLD_FONT)|$(KB_18)|soft-shadow-thin" )
			c:SetAnchor( CENTER, ui.SetButton, CENTER, 0, 0 )
			c:SetText( "Set" )
			c:SetColor( 1, 1, 1, 1 )

			return ui
		end

		self.ParamName = addTextParam( "Name", DEFAULT_PARAM_NAME_TEXT, 32, false )
		self.ParamTitle = addTextParam( "Title", DEFAULT_PARAM_TITLE_TEXT, 64, false )

		local function addNumericParam( metaParamKey, defaultValue, maxLen )
			local ui = { }

			c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.Container = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetResizeToFitDescendents( false )
			c:SetDimensions( 400, 30 )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControl( nil, ui.Container, CT_LABEL )
			ui.TextLabel = c
			c:SetAnchor( TOPLEFT, ui.Container, TOPLEFT, 0, 0 )
			c:SetColor( 1, 1, 1, 1 )
			c:SetDrawLevel( baseDrawLevel )
			c:SetFont( "$(BOLD_FONT)|$(KB_20)|soft-shadow-thin" )
			c:SetMouseEnabled( false )
			c:SetText( metaParamKey )
			c:SetWidth( 200 )

			c = WINDOW_MANAGER:CreateControl( nil, ui.Container, CT_TEXTURE )
			ui.TextOutline = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( LEFT, ui.TextLabel, RIGHT, 30 )
			c:SetInheritAlpha( false )
			c:SetColor( 0.5, 0.5, 0.5, 1 )
			c:SetDimensions( 50, 30 )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControlFromVirtual( nil, ui.TextOutline, "ZO_EditBackdrop" )
			ui.TextBackdrop = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOPLEFT, ui.TextOutline, nil, 2, 2 )
			c:SetAnchor( BOTTOMRIGHT, ui.TextOutline, nil, -2, -2 )
			c:SetAlpha( 1 )
			c:SetEdgeColor( 0, 0, 0, 1 )
			c:SetCenterColor( 0, 0, 0, 1 )
			c:SetInheritAlpha( false )

			c = WINDOW_MANAGER:CreateControlFromVirtual( nil, ui.TextBackdrop, "ZO_DefaultEditForBackdrop" )
			ui.Text = c
			c:SetFont( "$(CHAT_FONT)|$(KB_16)|soft-shadow-thin" )
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOPLEFT, nil, nil, 2, 2 )
			c:SetAnchor( BOTTOMRIGHT, nil, nil, -2, -2 )
			c:SetMaxInputChars( maxLen or MAX_META_STRING_LEN )
			c:SetMultiLine( false )
			c:SetMouseEnabled( true )
			c:SetText( tostring( defaultValue ) )
			c:SetHandler( "OnTextChanged", function( control )
				local e = self.Effect
				if not e then return end

				local msg = control:GetText()
				local val = tonumber( round( math.abs( tonumber( msg ) or defaultValue ) ) )

				e:SetMetaData( metaParamKey, val )
				e:UpdateRecord()
				e:Reset()
			end )

			local ADJUST_VALUE_HANDLE = "EHT.OnAdjust.MetaParam."..metaParamKey
			local MAX_VALUE = ( 10 ^ maxLen ) - 1
			local function AdjustValue( offset )
				if IsShiftKeyDown() then
					offset = offset * 5
				elseif IsAltKeyDown() then
					offset = offset * 10
				end
				local v = self.Effect:GetMetaData( metaParamKey ) or defaultValue
				v = round( math.abs( zo_clamp( v + offset, 0, MAX_VALUE ) ) )
				ui.Text:SetText( tostring( v ) )
			end

			local function CancelRequest()
				EVENT_MANAGER:UnregisterForUpdate( ADJUST_VALUE_HANDLE )
			end

			local function AdjustValueDown()
				AdjustValue( -1 )
			end

			local function AdjustValueUp()
				AdjustValue( 1 )
			end

			local function AdjustingValueDown()
				CancelRequest()
				EVENT_MANAGER:RegisterForUpdate( ADJUST_VALUE_HANDLE, 80, AdjustValueDown )
			end

			local function AdjustingValueUp()
				CancelRequest()
				EVENT_MANAGER:RegisterForUpdate( ADJUST_VALUE_HANDLE, 80, AdjustValueUp )
			end

			local function RequestAdjustValueDown()
				CancelRequest()
				EVENT_MANAGER:RegisterForUpdate( ADJUST_VALUE_HANDLE, 80, AdjustingValueDown )
				AdjustValueDown()
			end

			local function RequestAdjustValueUp()
				CancelRequest()
				EVENT_MANAGER:RegisterForUpdate( ADJUST_VALUE_HANDLE, 80, AdjustingValueUp )
				AdjustValueUp()
			end

			c = WINDOW_MANAGER:CreateControl( nil, ui.Container, CT_TEXTURE )
			ui.Decrease = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetDrawLayer(DL_CONTROLS)
			c:SetTextureReleaseOption( RELEASE_TEXTURE_AT_ZERO_REFERENCES )
			c:SetTexture( TEXTURES.ARROW_1 )
			c:SetAnchor( RIGHT, ui.TextOutline, LEFT, -5 )
			c:SetInheritAlpha( false )
			c:SetColor( 1, 1, 1, 1 )
			c:SetDimensions( 25, 25 )
			c:SetMouseEnabled( true )
			c:SetTextureCoords( 1, 0, 0, 1 )
			c:SetHandler( "OnMouseDown", RequestAdjustValueDown )
			c:SetHandler( "OnMouseUp", CancelRequest )

			c = WINDOW_MANAGER:CreateControl( nil, ui.Container, CT_TEXTURE )
			ui.Increase = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetDrawLayer(DL_CONTROLS)
			c:SetTextureReleaseOption( RELEASE_TEXTURE_AT_ZERO_REFERENCES )
			c:SetTexture( TEXTURES.ARROW_1 )
			c:SetAnchor( LEFT, ui.TextOutline, RIGHT, 5 )
			c:SetInheritAlpha( false )
			c:SetColor( 1, 1, 1, 1 )
			c:SetDimensions( 25, 25 )
			c:SetMouseEnabled( true )
			c:SetHandler( "OnMouseDown", RequestAdjustValueUp )
			c:SetHandler( "OnMouseUp", CancelRequest )

			return ui
		end

		self.ParamPatternScaleX = addNumericParam( "Pattern Scale % (X)", 100, 4 )
		self.ParamPatternScaleY = addNumericParam( "Pattern Scale % (Y)", 100, 4 )
		self.ParamScaleX = addNumericParam( "Scale % (X)", 100, 4 )
		self.ParamScaleY = addNumericParam( "Scale % (Y)", 100, 4 )
		self.ParamOffsetX = addNumericParam( "Offset % (X)", 0, 4 )
		self.ParamOffsetY = addNumericParam( "Offset % (Y)", 0, 4 )

		do
			local ui = { }
			self.ParamLoreCategory = ui

			local c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.LoreCategoryContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetResizeToFitDescendents( true )
			c:SetMouseEnabled( false )

			c = EHT.UI.Picklist:New( "EffectParamLoreCategory", ui.LoreCategoryContainer, LEFT, ui.LoreCategoryContainer, LEFT, 2, 0, 360, 26 )
			ui.LoreCategory = c
			c:SetDrawLevel( baseDrawLevel )
			c:AddHandler( "OnSelectionChanged", function( control, item, previousItem )
				local value = control:GetSelectedItemValue()
				if not value or 0 == value then
					EHT.UI.ShowAlertDialog( "", "Please select an option." )
					return
				end

				local e = CurrentEditorEffect
				e:SetMetaData( "Lore Category", value )
				e:UpdateRecord()
				e:Reset()
				EHT.Effect.RefreshParamLoreCollection()
			end )
		end

		do
			local ui = { }
			self.ParamLoreCollection = ui

			local c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.LoreCollectionContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetResizeToFitDescendents( true )
			c:SetMouseEnabled( false )

			c = EHT.UI.Picklist:New( "EffectParamLoreCollection", ui.LoreCollectionContainer, LEFT, ui.LoreCollectionContainer, LEFT, 2, 0, 360, 26 )
			ui.LoreCollection = c
			c:SetDrawLevel( baseDrawLevel )
			c:AddHandler( "OnSelectionChanged", function( control, item, previousItem )
				local value = control:GetSelectedItemValue()
				if not value or 0 == value then
					EHT.UI.ShowAlertDialog( "", "Please select an option." )
					return
				end

				local e = CurrentEditorEffect
				e:SetMetaData( "Lore Collection", value )
				e:UpdateRecord()
				e:Reset()
				EHT.Effect.RefreshParamLoreBook()
			end )
		end

		do
			local ui = { }
			self.ParamLoreBook = ui

			local c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.LoreBookContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetResizeToFitDescendents( true )
			c:SetMouseEnabled( false )

			c = EHT.UI.Picklist:New( "EffectParamLoreBook", ui.LoreBookContainer, LEFT, ui.LoreBookContainer, LEFT, 2, 0, 360, 26 )
			ui.LoreBook = c
			c:SetDrawLevel( baseDrawLevel )
			c:AddHandler( "OnSelectionChanged", function( control, item, previousItem )
				local value = control:GetSelectedItemValue()
				if not value or 0 == value then
					EHT.UI.ShowAlertDialog( "", "Please select an option." )
					return
				end

				local e = CurrentEditorEffect
				e:SetMetaData( "Lore Book", value )
				e:UpdateRecord()
				e:Reset()
			end )
		end

		do
			local ui = { }
			self.ParamTargetEffect = ui

			local c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.TargetEffectContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetResizeToFitDescendents( true )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControl( nil, ui.TargetEffectContainer, CT_LABEL )
			ui.TargetEffectLabel = c
			c:SetColor( 1, 1, 1, 1 )
			c:SetAnchor( LEFT, ui.TargetEffectContainer, LEFT, 0, 0 )
			c:SetFont( "$(BOLD_FONT)|$(KB_20)|soft-shadow-thin" )
			c:SetHorizontalAlignment( TEXT_ALIGN_LEFT )
			c:SetText( "Target Effect" )
			c:SetDrawLevel( baseDrawLevel )

			c = EHT.UI.Picklist:New( "EffectParamTargetEffect", ui.TargetEffectContainer, LEFT, ui.TargetEffectLabel, RIGHT, 10, 0, 400, 26 )
			ui.TargetEffect = c
			c:SetDrawLevel( baseDrawLevel )

			c = WINDOW_MANAGER:CreateControl( nil, ui.TargetEffectContainer, CT_TEXTURE )
			ui.SetButtonOutline = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( LEFT, ui.TargetEffect:GetControl(), RIGHT, 10, 0 )
			c:SetDimensions( 60, 30 )
			c:SetColor( 1, 1, 1, 1 )

			c = WINDOW_MANAGER:CreateControl( nil, ui.SetButtonOutline, CT_TEXTURE )
			ui.SetButton = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetDrawLayer(DL_CONTROLS)
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( CENTER, ui.SetButtonOutline, CENTER, 0, 0 )
			c:SetDimensions( 56, 26 )
			c:SetColor( 0.05, 0, 0.7, 1 )
			c:SetMouseEnabled( true )
			c:SetHandler( "OnMouseDown", function()
				local targetEffectId = tonumber( ui.TargetEffect:GetSelectedItemValue() )

				if not targetEffectId or 0 == targetEffectId then
					EHT.UI.ShowAlertDialog( "", "Please select the |cffff66target effect(s)|r." )
					return
				end

				local e = self.Effect
				local prevValue = e:GetMetaData( "Target Effect" )
				e:SetMetaData( "Target Effect", targetEffectId )

				local evt = e.EffectType.OnMetaDataChanged
				if evt then
					evt( e, "Target Effect", prevValue, targetEffectId )
				end

				e:UpdateRecord()
				e:Reset()
			end )

			c = WINDOW_MANAGER:CreateControl( nil, ui.SetButton, CT_LABEL )
			ui.SetButtonLabel = c
			c:SetDrawLevel( baseDrawLevel + 2 )
			c:SetFont( "$(BOLD_FONT)|$(KB_18)|soft-shadow-thin" )
			c:SetAnchor( CENTER, ui.SetButton, CENTER, 0, 0 )
			c:SetText( "Set" )
			c:SetColor( 1, 1, 1, 1 )

			ui.TargetEffect:AddHandler( "OnShowPicklist", function( control )
				local value = tonumber( self.Effect:GetMetaData( "Target Effect" ) )
				RefreshParamTargetEffect( self, value )
			end )
		end

		local function AddInteractiveFurnitureParam( uiName, paramName, label )
			local ui = { }
			self[uiName] = ui

			local c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.FurnitureContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetDimensions( 500, 55 )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControl( nil, ui.FurnitureContainer, CT_LABEL )
			ui.FurnitureLabel = c
			c:SetColor( 1, 1, 1, 1 )
			c:SetAnchor( TOPLEFT, ui.FurnitureContainer, TOPLEFT, 0, 0 )
			c:SetFont( "$(BOLD_FONT)|$(KB_20)|soft-shadow-thin" )
			c:SetHorizontalAlignment( TEXT_ALIGN_LEFT )
			c:SetText( label )
			c:SetWidth( 150 )
			c:SetDrawLevel( baseDrawLevel )

			c = WINDOW_MANAGER:CreateControl( nil, ui.FurnitureContainer, CT_LABEL )
			ui.FurnitureNameLabel = c
			c:SetColor( 1, 1, 0.5, 1 )
			c:SetAnchor( LEFT, ui.FurnitureLabel, RIGHT, 10, 0 )
			c:SetFont( "$(BOLD_FONT)|$(KB_18)|soft-shadow-thin" )
			c:SetHorizontalAlignment( TEXT_ALIGN_LEFT )
			c:SetText( "No item selected" )
			c:SetDrawLevel( baseDrawLevel )

			local function OnChooseFurnitureItem( furnitureId )
				local e = ui.LastEffect
				if not e then
					return
				end

				local editor = EFFECT_EDITOR
				editor:BindToEffect( e )
				editor:ShowEditor()

				local sFurnitureId = string.fromId64( furnitureId )
				local _, _, _, _, _, _, _, _, furnitureLink, furnitureName = EHT.Housing.GetFurnitureInfo( furnitureId )

				if not furnitureId or not furnitureName then
					EHT.UI.DisplayNotification( "No furniture item selected." )
					return
				end

				local numStates = EHT.Housing.GetFurnitureNumStates( furnitureId )
				if not numStates or 0 == numStates then
					EHT.UI.DisplayNotification( "Furniture item is not interactive." )
					return
				end

				local prevValue = e:GetMetaData( paramName )
				e:SetMetaData( paramName, sFurnitureId )
				ui.FurnitureNameLabel:SetText( furnitureName )

				local evt = e.EffectType.OnMetaDataChanged
				if evt then
					evt( e, paramName, prevValue, sFurnitureId )
				end

				e:UpdateRecord()
				e:Reset()
			end

			c = WINDOW_MANAGER:CreateControl( nil, ui.FurnitureContainer, CT_TEXTURE )
			ui.SetButtonOutline = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( TOPLEFT, ui.FurnitureNameLabel, BOTTOMLEFT, 0, 5 )
			c:SetDimensions( 134, 30 )
			EHT.UI.SetColor( c, EHT.UI.Colors.ButtonOutline )

			c = WINDOW_MANAGER:CreateControl( nil, ui.SetButtonOutline, CT_TEXTURE )
			ui.SetButton = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetDrawLayer(DL_CONTROLS)
			c:SetTexture( EHT.Textures.SOLID )
			c:SetAnchor( TOPLEFT, ui.SetButtonOutline, TOPLEFT, 1, 1 )
			c:SetAnchor( BOTTOMRIGHT, ui.SetButtonOutline, BOTTOMRIGHT, -1, -1 )
			EHT.UI.SetColor( c, EHT.UI.Colors.ButtonBackdrop )
			c:SetMouseEnabled( true )
			c:SetHandler( "OnMouseDown", function()
				ui.LastEffect = self.Effect
				EHT.UI.DisplayNotification( "Target a furniture item and left click" )
				EHT.UI.InitChooseAnItem()
				EHT.UI.ChooseAnItem( OnChooseFurnitureItem )
			end )
			
			c = WINDOW_MANAGER:CreateControl( nil, ui.SetButton, CT_LABEL )
			ui.SetButtonLabel = c
			c:SetAnchor( CENTER, ui.SetButton, CENTER, 0, 0 )
			c:SetDrawLevel( baseDrawLevel + 2 )
			c:SetFont( EHT.UI.Colors.ButtonLabelFont )
			c:SetText( "Choose An Item" )
			EHT.UI.SetColor( c, EHT.UI.Colors.ButtonLabelColor )
			
			return ui
		end

		AddInteractiveFurnitureParam( "ParamFurniture", "Furniture", "Furniture Item" )
		AddInteractiveFurnitureParam( "ParamSourceFurniture", "When Furniture", "When Furniture" )
		AddInteractiveFurnitureParam( "ParamTargetFurniture", "Then Furniture", "Then Furniture" )
		
		local function AddFurnitureGroupParam( uiName, paramName, furnitureParamName, label )
			local ui = { }
			self[uiName] = ui

			local c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.GroupContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetDimensions( 500, 42 )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControl( nil, ui.GroupContainer, CT_LABEL )
			ui.GroupLabel = c
			c:SetColor( 1, 1, 1, 1 )
			c:SetAnchor( TOPLEFT, ui.GroupContainer, TOPLEFT, 0, 0 )
			c:SetFont( "$(BOLD_FONT)|$(KB_20)|soft-shadow-thin" )
			c:SetHorizontalAlignment( TEXT_ALIGN_LEFT )
			c:SetText( label )
			c:SetWidth( 150 )
			c:SetDrawLevel( baseDrawLevel )

			local controlName = "EHT" .. uiName .. "List"
			c = EHT.UI.Picklist:New( controlName, ui.GroupContainer, LEFT, ui.GroupLabel, RIGHT, 10, 0, 150, 26 )
			ui.GroupList = c
			c:SetDrawLevel( baseDrawLevel )
			c:AddHandler( "OnSelectionChanged", function( control, item, previousItem )
				local value = control:GetSelectedItemValue()
				if not value or value == "" then
					EHT.UI.ShowAlertDialog( "", "Please select a Saved Selection." )
					return
				end

				local e = CurrentEditorEffect
				e:SetMetaData( paramName, value )

				local CURRENT_HOUSE = nil
				local furnitureIds = EHT.Data.GetGroupStatefulFurnitureIdList( value, CURRENT_HOUSE, MAX_META_STRING_LEN )
				e:SetMetaData( furnitureParamName, furnitureIds )

				e:UpdateRecord()
				e:Reset()
			end )
		end

		AddFurnitureGroupParam( "ParamTargetGroup", "Then Group", "Then Group Furniture", "Then Group" )

		local function AddFurnitureStateParam( uiName, paramName, label )
			local ui = { }
			self[uiName] = ui

			local c = WINDOW_MANAGER:CreateControl( nil, pCustom, CT_CONTROL )
			ui.StateContainer = c
			c:SetDrawLevel( baseDrawLevel )
			c:SetAnchor( TOP, pCustom, TOP, 0, 0 )
			c:SetDimensions( 500, 42 )
			c:SetMouseEnabled( false )

			c = WINDOW_MANAGER:CreateControl( nil, ui.StateContainer, CT_LABEL )
			ui.StateLabel = c
			c:SetColor( 1, 1, 1, 1 )
			c:SetAnchor( TOPLEFT, ui.StateContainer, TOPLEFT, 0, 0 )
			c:SetFont( "$(BOLD_FONT)|$(KB_20)|soft-shadow-thin" )
			c:SetHorizontalAlignment( TEXT_ALIGN_LEFT )
			c:SetText( label )
			c:SetWidth( 150 )
			c:SetDrawLevel( baseDrawLevel )

			local controlName = "EHT" .. uiName .. "List"
			c = EHT.UI.Picklist:New( controlName, ui.StateContainer, LEFT, ui.StateLabel, RIGHT, 10, 0, 150, 26 )
			ui.StateList = c
			c:SetDrawLevel( baseDrawLevel )
			c:AddHandler( "OnSelectionChanged", function( control, item, previousItem )
				local value = control:GetSelectedItemValue()
				if not value or value == "" then
					EHT.UI.ShowAlertDialog( "", "Please select an option." )
					return
				end

				local e = CurrentEditorEffect
				e:SetMetaData( paramName, value )
				e:UpdateRecord()
				e:Reset()
			end )

			local list = ui.StateList
			list:ClearItems()
			list:AddItem( "", nil, nil )
			for _, stateName in pairs( EHT.STATE ) do
				if stateName ~= EHT.STATE.RESTORE then
					list:AddItem( stateName, nil, stateName )
				end
			end
			list:SetSelectedItem( "" )
			list:SetSorted( true )
			list:Refresh()
		end

		AddFurnitureStateParam( "ParamSourceState", "Is", "Is" )
		AddFurnitureStateParam( "ParamTargetState", "Will Be", "Will Be" )
	end

	EHT.PopTS( "EHT.EffectEditor:Initialize" )
end

function EHT.EffectEditor:HasEditEffectPermission()
	if not EHT.EffectUI.ValidatePreviewMode( true ) then
		return false
	end

	return EHT.Housing.IsOwner() or EHT.IsDev
end

function EHT.EffectEditor:CheckEditEffectPermission()
	if not EHT.EffectUI.ValidatePreviewMode() then
		return false
	end

	if not self:HasEditEffectPermission() then
		EHT.UI.PlaySoundFailure()
		EHT.UI.DisplayNotification( "Essential Effects(TM) can only be edited while in your own home." )
		return false
	end
	
	return true
end

function EHT.EffectEditor:CanShowEditButtons()
	return self:HasEditEffectPermission() and EHT.Housing.IsSelectionMode() and nil == self.Effect
end

function EHT.EffectEditor:CanShowEditor()
	return self:HasEditEffectPermission() and nil ~= self.Effect and IsEditModeActive
end

function EHT.EffectEditor:IsEditing()
	return self.Effect and IsEditModeActive and not EffectEditorWindow:IsHidden()
end

function EHT.EffectEditor.AutoSizeGlobalEffects()
	local win = GlobalEffectsWindow
	local editor = EHT.GetEffectEditor()
	local numEffects = editor.ActiveGlobalEffects
	local x, y = win.Panel:GetDimensions()

	x, y = x + 10, y + 56
	win:SetHidden( not editor:HasEditEffectPermission() or 0 >= numEffects or not ( EHT.Housing.IsSelectionMode() or EHT.Housing.IsPlacementMode() ) )
	win:SetDimensions( x, y )
end

function EHT.EffectEditor.OnGlobalEffectMouseDown( self )
	if self.Effect then
		if not EHT.Housing.IsSelectionMode() and not EHT.Housing.IsPlacementMode() then
			HousingEditorRequestModeChange( HOUSING_EDITOR_MODE_SELECTION )
		end

		local editor = EHT.GetEffectEditor()
		editor:BindToEffect( self.Effect )
		editor:ShowEditor()
	end
end

function EHT.EffectEditor:RegisterGlobalEffect( effect )
	local win = GlobalEffectsWindow
	if not win then return false end

	local effects = self.GlobalEffects
	local button

	for index = 1, #effects do
		if not effects[index].Effect then
			button = effects[index]
			button:SetHidden( false )
			break
		end
	end

	if not button then
		local c

		button = WINDOW_MANAGER:CreateControl( nil, win.Panel, CT_CONTROL )
		button:SetDimensions( 72, 52 )
		button:SetResizeToFitDescendents( true )
		button:SetHidden( false )
		button:SetMouseEnabled( true )
		button:SetDrawLayer(DL_CONTROLS)
		button:SetHandler( "OnMouseDown", EHT.EffectEditor.OnGlobalEffectMouseDown )

		c = WINDOW_MANAGER:CreateControl( nil, button, CT_TEXTURE )
		button.Texture = c
		c:SetColor( 1, 1, 0.4, 1 )
		c:SetDimensions( 36, 36 )
		c:SetTexture( "esoui/art/dye/dyes_toolicon_fill_down.dds" )
		c:SetDrawLayer( DL_TEXT )
		c:SetAnchor( TOP, button, TOP, 0, 0 )

		c = WINDOW_MANAGER:CreateControl( nil, button, CT_LABEL )
		button.Label = c
		c:SetColor( 1, 1, 0.4, 1 )
		c:SetWidth( 72 )
		c:SetAnchor( TOP, button.Texture, BOTTOM, 0, 0 )
		c:SetFont( "$(MEDIUM_FONT)|$(KB_14)" )
		c:SetHorizontalAlignment( TEXT_ALIGN_CENTER )
		c:SetDrawLayer( DL_TEXT )
		c:SetMaxLineCount( 4 )

		table.insert( effects, button )
	end

	self.ActiveGlobalEffects = self.ActiveGlobalEffects + 1
	button.Label:SetText( effect.EffectType.Name )
	button.Effect = effect
	button:ClearAnchors()
	button:SetAnchor( TOP, win.Panel, TOP, 0, 20 )

	local anchorTo = button
	for index = 1, #effects do
		local b = effects[index]
		if b ~= button and b.Effect then
			b:ClearAnchors()
			b:SetAnchor( TOP, anchorTo, BOTTOM, 0, 5 )
			anchorTo = b
		end
	end

	win.Panel:SetResizeToFitDescendents( true )
	zo_callLater( EHT.EffectEditor.AutoSizeGlobalEffects, 500 )

	return true
end

function EHT.EffectEditor:UnregisterGlobalEffect( effect )
	local win = GlobalEffectsWindow
	if not win then return false end

	local effects = self.GlobalEffects
	local button

	for index = 1, #effects do
		button = effects[index]
		if effect == button.Effect then
			button:SetHidden( true )
			button.Effect = nil
			break
		end
		button = nil
	end

	if button then
		self.ActiveGlobalEffects = self.ActiveGlobalEffects - 1

		local anchorTo, b
		for index = 1, #effects do
			b = effects[index]
			if b.Effect then
				b:ClearAnchors()
				if anchorTo then
					b:SetAnchor( TOP, anchorTo, BOTTOM, 0, 5 )
				else
					b:SetAnchor( TOP, win.Panel, TOP, 0, 15 )
				end
				anchorTo = b
			end
		end
	end

	win.Panel:SetResizeToFitDescendents( true )
	zo_callLater( EHT.EffectEditor.AutoSizeGlobalEffects, 500 )

	return true
end

function EHT.EffectEditor:UpdateEditButtons()
	local buttons = self.EditButtons
	local effects = EHT.Effect:GetAll()
	local areButtonsHidden = EHT.EffectUI.AreEditButtonsHidden()
	local hideButtons = not self:CanShowEditButtons() or areButtonsHidden
	local playerX, playerY, playerZ = GetPlayerWorldPositionInHouse()
	local screenWidth, screenHeight = GuiRoot:GetDimensions()

	if not hideButtons then
		local interval = 3 * GetLinearInterval(12000)
		local r, g, b = interval, (interval + 1) % 3, (interval + 2) % 3
		local buttonAlpha = (tonumber(EHT.GetNumericSetting("EditEffectButtonAlpha")) or 100) / 100
		local globalAlpha = EHT.EffectUI.AreEditButtonsHidden() and 0 or buttonAlpha
		local buttonSize = (tonumber(EHT.GetNumericSetting("EditEffectButtonSize")) or 100) / 100
		local globalSize = zo_lerp(0.25, 0.5, buttonSize)
		local minAlpha = 0.4 * globalAlpha

		if 2 < r then r = 3 - r end
		if 2 < g then g = 3 - g end
		if 2 < b then b = 3 - b end

		local flashButton = FLASH_RETICLE_TARGET_EFFECT_BUTTON
		local camX, camY, camZ = CameraX, CameraY, CameraZ
		local rad90 = RAD90
		local buttonIndex = 1
		for index, effect in ipairs(effects) do
			if effect.Active and effect.Record and not effect.EffectType:UsesGlobalTray() then
				local button = self:GetEditEffectButton(buttonIndex)

				if button then
					local angle = math.atan2(camX - effect.X, camZ - effect.Z)
					local pitch = rad90 * (math.abs(effect.Y - playerY) / 10000)
					local depth = zo_distance3D(effect.X, effect.Y, effect.Z, camX, camY, camZ)
					local fx, fy = GetWorldDimensionsOfViewFrustumAtDepth(depth)
					local scaleX, scaleY = globalSize * (fx / screenWidth), globalSize * (fy / screenHeight)
					local x, y, z = EHT.World:Get3DPosition(effect.X, effect.Y, effect.Z)

					if button ~= flashButton then
						button:SetColor(r, g, b, minAlpha)
						button:SetTextureSampleProcessingWeight(TEX_SAMPLE_PROCESSING_RGB, 1)
						button:SetVertexUV(1, 0, 0)
						button:SetVertexUV(2, 1, 0)
						button:SetVertexUV(4, 0, 1)
						button:SetVertexUV(8, 1, 1)
					end

					button.Effect = effect
					button:Set3DLocalDimensions(scaleX, scaleY)
					button:Set3DRenderSpaceOrigin(x, y, z)
					button:Set3DRenderSpaceOrientation(pitch, angle, 0)
					button:SetHidden(false)
				end

				buttonIndex = buttonIndex + 1
			end
		end

		for index = buttonIndex, #buttons do
			local button = buttons[index]
			button:SetHidden(true)
		end

		if flashButton then
			local interval = 1 - EaseInOut2(GetLinearInterval(4000))

			local rotationRad = -0.25 * math.pi + (1 - interval) * 0.5 * math.pi
			RotateCoords(flashButton, rotationRad)

			flashButton:SetColor(r, g, b, 0.8)

			local sampling = 1 + 2 * interval
			flashButton:SetTextureSampleProcessingWeight(TEX_SAMPLE_PROCESSING_RGB, sampling)

			flashButton:SetHidden(areButtonsHidden)
		end

		GlobalEffectsWindow:SetHidden(0 >= self.ActiveGlobalEffects)
		self.areEditButtonsHidden = false
	else
		if not self.areEditButtonsHidden or self.isReticleEffectButtonHidden ~= areButtonsHidden or self.currentReticleEffectButton ~= ReticleEffectButton then
			for _, button in ipairs(buttons) do
				button:SetHidden(true)
			end

			self.areEditButtonsHidden = true
			self.isReticleEffectButtonHidden = areButtonsHidden

			local reticleButton = ReticleEffectButton
			self.currentReticleEffectButton = reticleButton
			if reticleButton then
				reticleButton:SetHidden(areButtonsHidden)
			end

			GlobalEffectsWindow:SetHidden(true)
		end
	end
end

function EHT.EffectEditor:UpdateEditor()
	if not self:CanShowEditor() then
		self:HideEditor()
		return
	end

	EHT.EffectEditor.RefreshEditorSelectButton()
	self:ShowEditor()
	return true
end

function EHT.EffectEditor:UpdateEditorColor()
	if nil == self.Effect or self.Effect.Deleted then return end

	local r, g, b, a = self.Effect:GetColor()
	self.Colors:SetColorAsRGB( r, g, b )
	self.CurrentColor:SetColor( r, g, b, 1 )

	local fr, fg, fb = self.Colors:GetFullValuedColorAsRGB()
	self.Saturation:SetVertexColors( 1 + 2, fr, fg, fb, 1 )
	self.Saturation:SetVertexColors( 4 + 8, 0, 0, 0, 1 )

	local contrast = 1 - ( self.Effect:GetContrast() / 4 )
	self.ContrastBase:SetColor( r, g, b, 1 )
	self.Contrast:SetVertexColors( 1 + 2, r, g, b, 1 )
	self.Contrast:SetVertexColors( 4 + 8, r, g, b, 0 )
	self.CurrentContrast:ClearAnchors()
	self.CurrentContrast:SetAnchor( TOPLEFT, self.ContrastBackdrop, TOPLEFT, -4, zo_lerp( 0, self.ContrastBackdrop:GetHeight() - 12, contrast ) )
	self.CurrentContrast:SetAnchor( BOTTOMRIGHT, self.ContrastBackdrop, TOPRIGHT, 4, zo_lerp( 12, self.ContrastBackdrop:GetHeight(), contrast ) )

	local transparency = 1 - self.Effect:GetTransparency()
	self.Transparency:SetVertexColors( 1 + 2, r, g, b, 0.8 )
	self.Transparency:SetVertexColors( 4 + 8, r, g, b, 0 )
	self.CurrentTransparency:ClearAnchors()
	self.CurrentTransparency:SetAnchor( TOPLEFT, self.TransparencyBackdrop, TOPLEFT, -4, zo_lerp( 0, self.TransparencyBackdrop:GetHeight() - 12, transparency ) )
	self.CurrentTransparency:SetAnchor( BOTTOMRIGHT, self.TransparencyBackdrop, TOPRIGHT, 4, zo_lerp( 12, self.TransparencyBackdrop:GetHeight(), transparency ) )
end

function EHT.EffectEditor:UpdateEditorMetaData()
	local effect = self.Effect
	if not effect then return end

	local p1, p2, v1, v2
	local previous = nil

	do
		if effect:IsActionable() then
			local groups = effect:GetEffectGroupBitmask()
			self.EffectGroupId:SetSelectedItem( groups )
			self.EffectGroupId:SetHidden( false )
			self.EffectGroupId:Refresh()
		else
			self.EffectGroupId:SetHidden( true )
		end
	end

	local function ClearParent( container )
		container:SetHidden( true )
		container:ClearAnchors()
	end

	local function SetParent( container )
		container:ClearAnchors()
		container:SetAnchor( BOTTOMLEFT, self.CustomPanel, BOTTOMLEFT, 0, 0 )

		if previous then
			previous:ClearAnchors()
			previous:SetAnchor( BOTTOMLEFT, container, TOPLEFT, 0, -10 )
		end

		container:SetHidden( false )
		previous = container
	end

	-- Target House
------ TRANSFER TO HUB
	p1 = effect.EffectType:GetMetaParamByName("HouseId")
	p2 = effect.EffectType:GetMetaParamByName("Owner")

	if not p1 or not p2 then
		ClearParent(self.ParamDestination.TargetContainer)
	else
		v1, v2 = tonumber(effect:GetMetaData("HouseId")), effect:GetMetaData("Owner")
		local house = EHT.Housing.GetHouseById(v1)
		if house then
			self.ParamDestination.TargetHouse:SetSelectedItem(tonumber(house.Id))
			self.ParamDestination.TargetHouse.HouseId = house.Id
		else
			self.ParamDestination.TargetHouse:SetSelectedItem(0)
			self.ParamDestination.TargetHouse.HouseId = 0
		end
		self.ParamDestination.TargetPlayer:SetText(v2 and tostring(v2) or DEFAULT_PARAM_TARGET_PLAYER_TEXT)
		SetParent(self.ParamDestination.TargetContainer)
	end
------ TRANSFER TO HUB
	-- Message

	p1 = effect.EffectType:GetMetaParamByName( "Message" )

	if not p1 then
		ClearParent( self.ParamMessage.MessageContainer )
	else
		v1 = effect:GetMetaData( "Message" )
		self.ParamMessage.Message:SetText( v1 and tostring( v1 ) or DEFAULT_PARAM_MESSAGE_TEXT )
		SetParent( self.ParamMessage.MessageContainer )
	end

	-- Name

	p1 = effect.EffectType:GetMetaParamByName( "Name" )

	if not p1 then
		ClearParent( self.ParamName.Container )
	else
		v1 = effect:GetMetaData( "Name" )
		self.ParamName.Message:SetText( v1 and tostring( v1 ) or DEFAULT_PARAM_NAME_TEXT )
		SetParent( self.ParamName.Container )
	end

	-- Title

	p1 = effect.EffectType:GetMetaParamByName( "Title" )

	if not p1 then
		ClearParent( self.ParamTitle.Container )
	else
		v1 = effect:GetMetaData( "Title" )
		self.ParamTitle.Message:SetText( v1 and tostring( v1 ) or DEFAULT_PARAM_TITLE_TEXT )
		SetParent( self.ParamTitle.Container )
	end

	-- Guild Id

	p1 = effect.EffectType:GetMetaParamByName( "GuildId" )

	if not p1 then
		ClearParent( self.ParamGuildId.GuildIdContainer )
	else
		v1 = tonumber( effect:GetMetaData( "GuildId" ) )

		local list = self.ParamGuildId.GuildId
		list:ClearItems()
		list:AddItem( "- select a guild -", nil, 0 )

		for index, guild in ipairs( EHT.Guilds:GetGuilds() ) do
			list:AddItem( guild.Name, nil, guild.Id )
		end

		if v1 then
			self.ParamGuildId.GuildId:SetSelectedItem( v1 )
		else
			self.ParamGuildId.GuildId:SetSelectedItem( 0 )
		end

		SetParent( self.ParamGuildId.GuildIdContainer )
	end

	-- Pattern Scale % (X)

	p1 = effect.EffectType:GetMetaParamByName( "Pattern Scale % (X)" )

	if not p1 then
		ClearParent( self.ParamPatternScaleX.Container )
	else
		v1 = effect:GetMetaData( "Pattern Scale % (X)" )
		if not self.ParamPatternScaleX.Text:HasFocus() then
			self.ParamPatternScaleX.Text:SetText( tostring( v1 or 100 ) )
		end
		SetParent( self.ParamPatternScaleX.Container )
	end

	-- Pattern Scale % (Y)

	p1 = effect.EffectType:GetMetaParamByName( "Pattern Scale % (Y)" )

	if not p1 then
		ClearParent( self.ParamPatternScaleY.Container )
	else
		v1 = effect:GetMetaData( "Pattern Scale % (Y)" )
		if not self.ParamPatternScaleY.Text:HasFocus() then
			self.ParamPatternScaleY.Text:SetText( tostring( v1 or 100 ) )
		end
		SetParent( self.ParamPatternScaleY.Container )
	end

	-- Scale % (X)

	p1 = effect.EffectType:GetMetaParamByName( "Scale % (X)" )

	if not p1 then
		ClearParent( self.ParamScaleX.Container )
	else
		v1 = effect:GetMetaData( "Scale % (X)" )
		if not self.ParamScaleX.Text:HasFocus() then
			self.ParamScaleX.Text:SetText( tostring( v1 or 100 ) )
		end
		SetParent( self.ParamScaleX.Container )
	end

	-- Scale % (Y)

	p1 = effect.EffectType:GetMetaParamByName( "Scale % (Y)" )

	if not p1 then
		ClearParent( self.ParamScaleY.Container )
	else
		v1 = effect:GetMetaData( "Scale % (Y)" )
		if not self.ParamScaleY.Text:HasFocus() then
			self.ParamScaleY.Text:SetText( tostring( v1 or 100 ) )
		end
		SetParent( self.ParamScaleY.Container )
	end

	-- Offset % (X)

	p1 = effect.EffectType:GetMetaParamByName( "Offset % (X)" )

	if not p1 then
		ClearParent( self.ParamOffsetX.Container )
	else
		v1 = effect:GetMetaData( "Offset % (X)" )
		if not self.ParamOffsetX.Text:HasFocus() then
			self.ParamOffsetX.Text:SetText( tostring( v1 or 0 ) )
		end
		SetParent( self.ParamOffsetX.Container )
	end

	-- Offset % (Y)

	p1 = effect.EffectType:GetMetaParamByName( "Offset % (Y)" )

	if not p1 then
		ClearParent( self.ParamOffsetY.Container )
	else
		v1 = effect:GetMetaData( "Offset % (Y)" )
		if not self.ParamOffsetY.Text:HasFocus() then
			self.ParamOffsetY.Text:SetText( tostring( v1 or 0 ) )
		end
		SetParent( self.ParamOffsetY.Container )
	end

	-- Lore Category Id

	p1 = effect.EffectType:GetMetaParamByName( "Lore Category" )

	if not p1 then
		ClearParent( self.ParamLoreCategory.LoreCategoryContainer )
	else
		function EHT.Effect.RefreshParamLoreCategory()
			local editor = EHT.GetEffectEditor()
			local effect, list = editor.Effect, editor.ParamLoreCategory.LoreCategory
			local category = tonumber( effect:GetMetaData( "Lore Category" ) )

			list:ClearItems()
			for index = 1, 500 do
				local name = GetLoreCategoryInfo( index )
				if "" ~= name then
					list:AddItem( name, nil, index )
				else
					break
				end
			end

			if category then
				list:SetSelectedItem( category )
			else
				list:SetSelectedItem( nil )
			end

			list:SetSorted( true )
			list:Refresh()
		end

		EHT.Effect.RefreshParamLoreCategory()
		SetParent( self.ParamLoreCategory.LoreCategoryContainer )
	end

	-- Lore Collection Id

	p1 = effect.EffectType:GetMetaParamByName( "Lore Collection" )

	if not p1 then
		ClearParent( self.ParamLoreCollection.LoreCollectionContainer )
	else
		function EHT.Effect.RefreshParamLoreCollection()
			local editor = EHT.GetEffectEditor()
			local effect, list = editor.Effect, editor.ParamLoreCollection.LoreCollection
			local category, collection = tonumber( effect:GetMetaData( "Lore Category" ) ), tonumber( effect:GetMetaData( "Lore Collection" ) )

			if list.CategoryIndex ~= category then
				list:ClearItems()
				list.CategoryIndex = category

				for index = 1, 500 do
					local name = GetLoreCollectionInfo( category, index )
					if "" ~= name then
						list:AddItem( name, nil, index )
					else
						break
					end
				end
			end

			if collection then
				list:SetSelectedItem( collection )
			else
				list:SetSelectedItem( nil )
			end

			list:SetSorted( true )
			list:Refresh()
		end

		EHT.Effect.RefreshParamLoreCollection()
		SetParent( self.ParamLoreCollection.LoreCollectionContainer )
	end

	-- Lore Book Id

	p1 = effect.EffectType:GetMetaParamByName( "Lore Book" )

	if not p1 then
		ClearParent( self.ParamLoreBook.LoreBookContainer )
	else
		function EHT.Effect.RefreshParamLoreBook()
			local editor = EHT.GetEffectEditor()
			local effect, list = editor.Effect, editor.ParamLoreBook.LoreBook
			local category, collection, book = tonumber( effect:GetMetaData( "Lore Category" ) ), tonumber( effect:GetMetaData( "Lore Collection" ) ), tonumber( effect:GetMetaData( "Lore Book" ) ) -- effect.EffectType.CategoryIndex, effect.EffectType.CollectionIndex

			if list.CategoryIndex ~= category or list.CollectionIndex ~= collection then
				list:ClearItems()
				list.CategoryIndex, list.CollectionIndex = category, collection

				for index = 1, 500 do
					local name = GetLoreBookInfo( category, collection, index )
					if "" ~= name then
						list:AddItem( name, nil, index )
					else
						break
					end
				end
			end

			if book then
				list:SetSelectedItem( book )
			else
				list:SetSelectedItem( nil )
			end

			list:SetSorted( true )
			list:Refresh()
		end

		EHT.Effect.RefreshParamLoreBook()
		SetParent( self.ParamLoreBook.LoreBookContainer )
	end

	-- Target Effect Id

	p1 = effect.EffectType:GetMetaParamByName( "Target Effect" )

	if not p1 then
		ClearParent( self.ParamTargetEffect.TargetEffectContainer )
	else
		local value = tonumber( effect:GetMetaData( "Target Effect" ) )
		RefreshParamTargetEffect( self, value )
		SetParent( self.ParamTargetEffect.TargetEffectContainer )
	end

	-- Furniture

	p1 = effect.EffectType:GetMetaParamByName( "Furniture" )

	if not p1 then
		ClearParent( self.ParamFurniture.FurnitureContainer )
	else
		local value = effect:GetMetaData( "Furniture" )
		RefreshParamFurniture( self.ParamFurniture, value )
		SetParent( self.ParamFurniture.FurnitureContainer )
	end

	-- Source Furniture

	p1 = effect.EffectType:GetMetaParamByName( "When Furniture" )

	if not p1 then
		ClearParent( self.ParamSourceFurniture.FurnitureContainer )
	else
		local value = effect:GetMetaData( "When Furniture" )
		RefreshParamFurniture( self.ParamSourceFurniture, value )
		SetParent( self.ParamSourceFurniture.FurnitureContainer )
	end

	-- Source State

	p1 = effect.EffectType:GetMetaParamByName( "Is" )

	if not p1 then
		ClearParent( self.ParamSourceState.StateContainer )
	else
		function EHT.Effect.RefreshParamSourceState()
			local editor = EHT.GetEffectEditor()
			local effect, list = editor.Effect, editor.ParamSourceState.StateList
			local currentState = effect:GetMetaData( "Is" )
			if currentState then
				list:SetSelectedItem( currentState )
			else
				list:SetSelectedItem( "" )
			end
			list:Refresh()
		end

		EHT.Effect.RefreshParamSourceState()
		SetParent( self.ParamSourceState.StateContainer )
	end

	-- Target Furniture

	p1 = effect.EffectType:GetMetaParamByName( "Then Furniture" )

	if not p1 then
		ClearParent( self.ParamTargetFurniture.FurnitureContainer )
	else
		local value = effect:GetMetaData( "Then Furniture" )
		RefreshParamFurniture( self.ParamTargetFurniture, value )
		SetParent( self.ParamTargetFurniture.FurnitureContainer )
	end

	-- Target Group

	p1 = effect.EffectType:GetMetaParamByName( "Then Group" )

	if not p1 then
		ClearParent( self.ParamTargetGroup.GroupContainer )
	else
		function EHT.Effect.RefreshParamTargetGroup()
			local editor = EHT.GetEffectEditor()
			local effect = editor.Effect
			local list = editor.ParamTargetGroup.GroupList
			list:ClearItems()
			list:AddItem( "", nil, nil )
			for _, groupName in ipairs( EHT.Data.GetGroupNames() ) do
				list:AddItem( groupName, nil, groupName )
			end
			list:SetSelectedItem( "" )
			list:SetSorted( true )

			local currentGroup = effect:GetMetaData( "Then Group" )
			if currentGroup then
				list:SetSelectedItem( currentGroup )
			else
				list:SetSelectedItem( "" )
			end
			list:Refresh()
		end

		EHT.Effect.RefreshParamTargetGroup()
		SetParent( self.ParamTargetGroup.GroupContainer )
	end

	-- Target State

	p1 = effect.EffectType:GetMetaParamByName( "Will Be" )

	if not p1 then
		ClearParent( self.ParamTargetState.StateContainer )
	else
		function EHT.Effect.RefreshParamTargetState()
			local editor = EHT.GetEffectEditor()
			local effect, list = editor.Effect, editor.ParamTargetState.StateList
			local currentState = effect:GetMetaData( "Will Be" )
			if currentState then
				list:SetSelectedItem( currentState )
			else
				list:SetSelectedItem( "" )
			end
			list:Refresh()
		end

		EHT.Effect.RefreshParamTargetState()
		SetParent( self.ParamTargetState.StateContainer )
	end

	-- Finalization

	if previous then
		self.CustomPanel:SetResizeToFitDescendents( true )
		self.CustomPanel:SetHidden( false )
	else
		self.CustomPanel:SetHidden( true )
	end
end

local lastEffectBoxUpdate
local editEffectCenter = { }

local function OnEffectBoxUpdate()
	local editor = EFFECT_EDITOR
	local effect, marker
	if editor then
		effect = editor.Effect
		marker = editor.EditingEffectMarker
	end

	if not editor or not effect or not marker or marker:IsHidden() then
		EVENT_MANAGER:UnregisterForUpdate("EHT.OnEffectBoxUpdate")
		return
	end

	local alpha = 0.15
	local interval = GetLinearInterval(6000)
	if interval <= 0.333 then
		alpha = 0.15 + EaseInOut2(3 * interval)
	end

	marker:SetAlpha(alpha)
	marker:SetTextureSampleProcessingWeight(TEX_SAMPLE_PROCESSING_ALPHA_AS_RGB, alpha)
end

function EHT.EffectEditor:UpdateEffectBox()
	local marker = self.EditingEffectMarker
	local outlines = self.EditingEffectOutline

	if nil == marker then return end

	local effect = self.Effect
	local hide = not ( effect and effect.Active and effect.EffectType and not effect.EffectType.Environmental )

	if hide then
		marker:SetHidden( true )

		for index = 1, #outlines do
			outlines[index]:SetHidden( true )
		end

		EVENT_MANAGER:UnregisterForUpdate( "EHT.OnEffectBoxUpdate" )
		return
	end

	local eX, eY, eZ = effect:GetPosition()
	local x, y, z = EHT.World:Get3DPosition( eX + 5, eY + 5, eZ + 5 )
	local sX, sY, sZ = effect:GetSize()
	local size = math.max( sX, sY, sZ ) * 0.01 + 0.1
	local p

	if not ReticleEffect then
		marker:Set3DRenderSpaceOrigin( x, y, z )
		marker:Set3DRenderSpaceOrientation( effect:GetOrientation() )
		marker:SetHidden( false )
	end

	local p
	local c = editEffectCenter
	local maxLen = math.max( effect:GetSize() ) / 100

	c.X, c.Y, c.Z = x, y, z
	c.MaxLen = maxLen

	EVENT_MANAGER:RegisterForUpdate( "EHT.OnEffectBoxUpdate", 10, OnEffectBoxUpdate )
end

function EHT.EffectEditor:ShowEditor()
	if not EHT.EffectUI.ValidatePreviewMode() then
		return nil
	end

	if EffectEditorWindow and self.Effect then
		local hidePitch = false == self.Effect.EffectType.CanPitch or ( not self.Effect.EffectType.CanPitch and nil ~= self.Effect.EffectType.Update )

		local effectName
		if self.Effect.EffectType.Submitter then
			effectName = string.format( "%s (|c55ffffSubmitted by %s|r)", self.Effect.EffectType.Name, self.Effect.EffectType.Submitter )
		else
			effectName = self.Effect.EffectType.Name
		end
		self.EffectName:SetText( effectName )

		self.MoveHere:SetHidden( false )

		for index, button in pairs( self.Arrows ) do
			if 9 <= index and hidePitch then
				button:SetHidden( true )
			else
				button:SetHidden( false )
			end
		end

		for _, button in pairs( self.Scales ) do
			button:SetHidden( false )
		end
		self.Colors:SetHidden( false )
		self.NextEffect:SetHidden( false )
		self.PreviousEffect:SetHidden( false )
		EffectEditorWindow:SetHidden( false )

		self:UpdateEditButtons()
		self:UpdateEffectBox()
		self:UpdateEditorColor()
		self:UpdateEditorMetaData()

		local id = self.Effect:GetRecordId()
		if id and EHT.Data.GetGroupFurniture( id ) then
			EHT.UI.QueueRefreshGroupedIndicators()
			EHT.UI.QueueRefreshGroupOutlineIndicators()
			EHT.UI.QueueRefreshLockedIndicators()
		end
	end
end

function EHT.EffectEditor:HideEditor()
	self:BindToEffect( nil )

	if EffectEditorWindow then EffectEditorWindow:SetHidden( true ) end
	self:UpdateEffectBox()
end

function EHT.EffectEditor:IsHidden()
	return EffectEditorWindow and EffectEditorWindow:IsHidden()
end

function EHT.EffectEditor:BindToEffect( effect, isCycling )
	self.Effect = effect
	CurrentEditorEffect = effect

	if effect then
		if not isCycling then
			-- Reset the Effect Cycle to force the list to center around the user's selected Effect.
			EHT.GetEffectEditor().EffectCycle = nil
		end

		self:UpdateEditor()
		self:UpdateEditButtons()
		EHT.UI.PlaySoundEffectStartEdit()
	end
end

function EHT.EffectEditor.OnTogglePositionSystemClick( control )
	local editor = EHT.GetEffectEditor()

	if "cardinal" ~= editor.PositionSystem then
		editor.PositionSystem = "cardinal"
		control:SetText( "Switch to Fwd/Back" )
	else
		editor.PositionSystem = "relative"
		control:SetText( "Switch to N-S-E-W" )
	end
end

function EHT.EffectEditor.OnDeleteButtonClick( control )
	if not EHT.EffectUI.ValidatePreviewMode() then
		return nil
	end

	local editor = EHT.GetEffectEditor()
	if editor.Effect then
		local rec = editor.Effect.Record

		if rec then
			if EHT.Biz.CheckItemLock( rec.Id ) then
				return false
			end

			if not EHT.Data.DeleteEffectRecord( rec ) then
				if editor.Effect then
					editor.Effect:Delete()
				end
			end
		elseif editor.Effect then
			editor.Effect:Delete()
		end

		editor:HideEditor()
		editor:UpdateEditButtons()

		-- EHT.Mapcast.BroadcastEffects()
		EHT.UI.PlaySoundEffectRemoved()
		EHT.UI.RefreshPlacedEffectsList()
	end
end

function EHT.EffectEditor.OnDoneButtonClick( control )
	local editor = EHT.GetEffectEditor()

	editor:HideEditor()
	editor:UpdateEditButtons()

	EHT.UI.PlaySoundEffectEndEdit()
	EHT.UI.RefreshPlacedEffectsList()
end

do
	local anchorEffect

	function EHT.EffectEditor.OnAnchorButtonClick( control )
		if not EHT.EffectUI.ValidatePreviewMode() then
			return nil
		end

		anchorEffect = nil

		local editor = EHT.GetEffectEditor()
		if not editor or not editor.Effect then
			return
		end

		anchorEffect = editor.Effect
		editor:HideEditor()

		EHT.UI.InitChooseAnItem()
		EHT.UI.ChooseAnItem( EHT.EffectEditor.OnAnchorEffectTarget )
	end

	function EHT.EffectEditor.OnAnchorEffectTarget( furnitureId )
		if anchorEffect and furnitureId and 0 ~= furnitureId then
			local success, message = anchorEffect:SetAnchorId( furnitureId )

			if not success then
				EHT.UI.DisplayNotification( message )
			else
				local editor = EHT.GetEffectEditor()
				editor:BindToEffect( anchorEffect )
				editor:ShowEditor()

				local _, _, _, _, _, _, _, _, _, furnitureName = EHT.Housing.GetFurnitureInfo( anchorEffect:GetAnchorId() )
				EHT.UI.DisplayNotification( string.format( "Effect has been anchored to %s.", tostring( furnitureName ) ) )
			end

			anchorEffect = nil
		end
	end
end

function EHT.EffectEditor.RefreshEditorSelectButton()
	local editor = EHT.GetEffectEditor()
	if editor and editor.SelectLabel and editor.Effect then
		local id = editor.Effect:GetRecordId()
		if id then
			local item = EHT.Data.GetGroupFurniture( id )
			if item then
				editor.SelectLabel:SetText( "Deselect" )
			else
				editor.SelectLabel:SetText( "Select" )
			end
		else
			editor.SelectLabel:SetText( "Select" )
		end
	end
end

function EHT.EffectEditor.OnSelectButtonClick( control )
	if not EHT.EffectUI.ValidatePreviewMode() then
		return nil
	end

	local editor = EHT.GetEffectEditor()
	if editor and editor.Effect then
		local id = editor.Effect:GetRecordId()
		if id then
			EHT.Biz.GroupUngroupFurnitureById( id )
		end
	end
end

function EHT.EffectEditor.OnCloneButtonClick( control )
	if not EHT.EffectUI.ValidatePreviewMode() then
		return nil
	end

	local editor = EHT.GetEffectEditor()
	if editor.Effect and editor.Effect.Record then editor.Effect:Clone() end
end

function EHT.EffectEditor.OnEditButtonClick( control )
	if not EHT.EffectUI.ValidatePreviewMode() then
		return nil
	end

	local effect = control.Effect
	if effect then
		local editor = EHT.GetEffectEditor()
		editor:BindToEffect( effect )
		editor:ShowEditor()
	end
end

function EHT.EffectEditor.OnCycleButtonClick( control )
	local direction = control.Index
	if nil == direction then return false end
	direction = ( 1 == direction ) and 1 or -1

	local editor = EHT.GetEffectEditor()
	local effect = editor.Effect
	if not effect or not effect.Active then return false end

	if EHT.Biz.CheckItemLock( effect:GetRecordId() ) then return false end

	local x, y, z = effect:GetPosition()
	local cycleIndex = editor.EffectCycleIndex
	local cycle = editor.EffectCycle

	if nil == cycle or nil == cycleIndex or 1 > cycleIndex or cycleIndex > #cycle then
		cycle = { }
		editor.EffectCycle = cycle

		local effects = EHT.Effect:GetAll()
		local eff, distance, eX, eY, eZ

		for index = 1, #effects do
			eff = effects[index]
			if eff.Active then
				eX, eY, eZ = eff:GetPosition()
				eff.CycleDistance = zo_distance3D( x, y, z, eX, eY, eZ )
				cycle[index] = eff
				if eff == effect then cycleIndex = index end
			end
		end
	end

	cycleIndex = cycleIndex + direction
	if 1 > cycleIndex then
		cycleIndex = #cycle
	elseif cycleIndex > #cycle then
		cycleIndex = 1
	end

	editor.EffectCycleIndex = cycleIndex
	effect = cycle[cycleIndex]

	if effect then
		editor:BindToEffect( effect, true )
		editor:ShowEditor()
	end

	return true
end

function EHT.EffectEditor.OnScaleButtonClick( control )
	if not EHT.EffectUI.ValidatePreviewMode() then
		return nil
	end

	local scaleIndex = control.Index
	if nil == scaleIndex then return false end

	local editor = EHT.GetEffectEditor()
	local effect = editor.Effect
	if not effect or not effect.Active then return false end

	if EHT.Biz.CheckItemLock( effect:GetRecordId() ) then return false end

	local x, y, z = effect:GetSize()
	local originalY = y
	local delta = IsAltKeyDown() and 2000 or IsShiftKeyDown() and 200 or IsControlKeyDown() and 1 or 20

	if effect.EffectType:UsesSetSizeV2() then
		if 4 == scaleIndex then
			x = x + delta
			z = z + delta
		elseif 3 == scaleIndex then
			x = x - delta
			z = z - delta
		elseif 2 == scaleIndex then
			y = y + delta
		elseif 1 == scaleIndex then
			y = y - delta
		end
	else
		if 4 == scaleIndex then
			x = x + delta
		elseif 3 == scaleIndex then
			x = x - delta
		elseif 2 == scaleIndex then
			z = z + delta
			y = z
		elseif 1 == scaleIndex then
			z = z - delta
			y = z
		end
	end

	x, y, z = zo_clamp( x, 2, 900000 ), zo_clamp( y, 2, 900000 ), zo_clamp( z, 2, 900000 )
	effect:SetSize( x, y, z )

	effect:Reset( RESET_SCALE )
	effect:UpdateRecord()
	EHT.UI.PlaySoundEffectChanged()

	return true
end

function EHT.EffectEditor.OnColorButtonClick( control, hsValue, r, g, b )
	if not EHT.EffectUI.ValidatePreviewMode() then return nil end
	local editor = EHT.GetEffectEditor()
	local effect = editor.Effect
	if not effect or not effect.Active or EHT.Biz.CheckItemLock( effect:GetRecordId() ) then return false end
	local _, _, _, a = effect:GetColor()

	if control then
		local thumbX, thumbY = control:GetThumbNormalizedPosition()
		r, g, b = control:GetFullValuedColorAsRGB()

		editor.CurrentColor:SetColor( r, g, b, 1 )
		effect:SetColor( r, g, b, a )
	else
		control = editor.Colors

		if hsValue then
			local hue, sat, val = control:GetColorAsHSV()
			control:SetColorAsHSV( hue, sat, hsValue )
			r, g, b = control:GetColorAsRGB()

			editor.CurrentColor:SetColor( r, g, b, 1 )
			effect:SetColor( r, g, b, a )
		else
			control:SetColorAsRGB( r, g, b )
			effect:SetColor( r, g, b, a )
			editor.CurrentColor:SetColor( r, g, b, 1 )
		end
	end

	effect:Reset( RESET_COLOR )
	effect:UpdateRecord()
	editor:UpdateEditorColor()
	EHT.UI.PlaySoundEffectChanged()

	return true
end

function EHT.EffectEditor.OnContrastButtonClick( control, value )
	if not EHT.EffectUI.ValidatePreviewMode() then return nil end
	local editor = EHT.GetEffectEditor()
	local effect = editor.Effect
	if not effect or not effect.Active or EHT.Biz.CheckItemLock( effect:GetRecordId() ) then return false end
	local contrast = effect:GetContrast()

	if value then
		effect:SetContrast( value )
	end

	effect:Reset( RESET_COLOR )
	effect:UpdateRecord()
	editor:UpdateEditorColor()
	EHT.UI.PlaySoundEffectChanged()

	return true
end

function EHT.EffectEditor.OnTransparencyButtonClick( control, value )
	if not EHT.EffectUI.ValidatePreviewMode() then return nil end
	local editor = EHT.GetEffectEditor()
	local effect = editor.Effect
	if not effect or not effect.Active or EHT.Biz.CheckItemLock( effect:GetRecordId() ) then return false end
	local contrast = effect:GetContrast()

	if value then
		effect:SetTransparency(value)
	end

	effect:Reset( RESET_COLOR )
	effect:UpdateRecord()
	editor:UpdateEditorColor()
	EHT.UI.PlaySoundEffectChanged()

	return true
end

function EHT.EffectEditor.OnMoveHereButtonClick( control )
	if not EHT.EffectUI.ValidatePreviewMode() then
		return nil
	end

	local editor = EHT.GetEffectEditor()
	local effect = editor.Effect
	if not effect or not effect.Active then return false end

	if EHT.Biz.CheckItemLock( effect:GetRecordId() ) then return false end

	local x, y, z = GetPlayerWorldPositionInHouse()
	local eX, eY, eZ = effect:GetPosition()
	local _, sizeY, _ = effect:GetSize()
	local _, minY, _, _, maxY, _ = effect:GetParticlePositionRange()

	effect:SetPosition( x, y + 10, z )
	effect:Reset( RESET_POSITION )
	effect:UpdateRecord()
	EHT.UI.PlaySoundEffectChanged()

	return true
end

function EHT.EffectEditor.OnArrowButtonClick( control )
	if not EHT.EffectUI.ValidatePreviewMode() then
		return nil
	end

	local arrowIndex = control.Index
	if nil == arrowIndex then return false end

	local editor = EHT.GetEffectEditor()
	local effect = editor.Effect
	if not effect or not effect.Active then return false end

	if EHT.Biz.CheckItemLock( effect:GetRecordId() ) then return false end
	local positionChanged = false

	if 1 <= arrowIndex and 6 >= arrowIndex then
		local x, y, z = effect:GetPosition()
		local delta = IsAltKeyDown() and 2000 or IsShiftKeyDown() and 200 or IsControlKeyDown() and 1 or 20
		local heading = EHT.Biz.GetEditorHeading()
		local relative = "cardinal" ~= editor.PositionSystem
		local gridYaw = EHT.Biz.GetGuidelinesYaw() or 0

		if 1 <= arrowIndex and 4 >= arrowIndex then
			if 1 == arrowIndex then
				if relative then
					heading = heading + math.rad( 180 )
				else
					heading = math.rad( 180 ) + gridYaw
				end
			elseif 2 == arrowIndex then
				if relative then
					heading = heading + math.rad( 0 )
				else
					heading = 0 + gridYaw
				end
			elseif 3 == arrowIndex then
				if relative then
					heading = heading + math.rad( 270 )
				else
					heading = math.rad( 270 ) + gridYaw
				end
			elseif 4 == arrowIndex then
				if relative then
					heading = heading + math.rad( 90 )
				else
					heading = math.rad( 90 ) + gridYaw
				end
			end

			x, z = x + delta * math.sin( heading ), z + delta * math.cos( heading )
		else
			if 5 == arrowIndex then
				y = y - delta
			elseif 6 == arrowIndex then
				y = y + delta
			end
		end

		positionChanged = true
		effect:SetPosition( x, y, z )
	else
		local pitch, yaw, roll = effect:GetOrientation()
		local delta = IsAltKeyDown() and math.rad( 90 ) or IsShiftKeyDown() and math.rad( 15 ) or IsControlKeyDown() and math.rad( 0.2 ) or math.rad( 5 ) 

		if 7 == arrowIndex then
			yaw = yaw - delta
		elseif 8 == arrowIndex then
			yaw = yaw + delta
		elseif 9 == arrowIndex then
			pitch = pitch + delta
		elseif 10 == arrowIndex then
			pitch = pitch - delta
		end

		pitch, yaw, roll = pitch % math.rad( 360 ), yaw % math.rad( 360 ), roll % math.rad( 360 )
		effect:SetOrientation( pitch, yaw, roll )
	end

	effect:Reset( positionChanged and RESET_POSITION or RESET_ORIENT )
	effect:UpdateRecord()
	EHT.UI.PlaySoundEffectChanged()

	return true
end

---[ Particle Generator ]---

EHT.ParticleEmitter.MAX_EMISSIONS_PER_FRAME = 20

EHT.ParticleEmitter.PATTERNS = {
	NONE = 0,
	RANDOM = 1,
	LINEAR = 2,
	RADIAL = 3,
	PERIMETER = 4,
	CYCLICAL = 5,
	CAMERA_DEPTH = 6,
	SPIRAL = 7,
	SPHERICAL = 8,
	PLANAR = 9,
}

EHT.ParticleEmitter.ORIENTATIONS = {
	NONE = 0,
	CAMERA = 1,
	VECTOR = 2,
	MANUAL = 3,
}

function EHT.ParticleEmitter:New( effect, options )
	local obj = ZO_Object.New( self )
	obj.Effect = effect
	obj.Effect:DeleteParticles()
	obj.ActiveParticles = { }
	obj.InactiveParticles = { }

	return obj:Initialize( options )
end

do
	local function GetEmitterOption( options, key )
		local value = options[key]
		options[key] = nil
		return value
	end

	function EHT.ParticleEmitter:Initialize( options )
		if "table" ~= type( options ) then return end

		if not self.Effect then
			error( "ParticleEmitter: Effect is required." )
			return nil
		end

		local invalidKeys = { }

		self.Texture = GetEmitterOption( options, "Texture" )
		self.OnEmission = GetEmitterOption( options, "OnEmission")			or nil

		self.AutoOrientation = GetEmitterOption( options, "AutoOrientation" ) or EHT.ParticleEmitter.ORIENTATIONS.CAMERA
		self.Pitch = GetEmitterOption( options, "Pitch" )			 		or 0
		self.Yaw = GetEmitterOption( options, "Yaw" )			 			or 0
		self.Roll = GetEmitterOption( options, "Roll" )			 			or 0

		self.WindFactor = GetEmitterOption( options, "WindFactor" ) 		or 0.5

		self.MaxOffsetX = GetEmitterOption( options, "MaxOffsetX" )
		self.MaxOffsetY = GetEmitterOption( options, "MaxOffsetY" )
		self.MaxOffsetZ = GetEmitterOption( options, "MaxOffsetZ" )
		self.MaxOffset = GetEmitterOption( options, "MaxOffset" )

		self.MinSize = GetEmitterOption( options, "MinSize" )				or 5
		self.MaxSize = GetEmitterOption( options, "MaxSize" )				or 10

		self.MinSizeY = GetEmitterOption( options, "MinSizeY" )				or self.MinSize
		self.MaxSizeY = GetEmitterOption( options, "MaxSizeY" )				or self.MaxSize

		self.MinGrowth = GetEmitterOption( options, "MinGrowth" )			or 0
		self.MaxGrowth = GetEmitterOption( options, "MaxGrowth" )			or 0

		self.MinGrowthY = GetEmitterOption( options, "MinGrowthY" )			or self.MinGrowth
		self.MaxGrowthY = GetEmitterOption( options, "MaxGrowthY" )			or self.MaxGrowth

		self.MinTTL = GetEmitterOption( options, "MinTTL" )
		self.MaxTTL = GetEmitterOption( options, "MaxTTL" )

		self.AdditiveBlending = true == GetEmitterOption( options, "AdditiveBlending" )
		self.ColorDodgeBlending = true == GetEmitterOption( options, "ColorDodgeBlending" )
		self.SampleRGB = GetEmitterOption( options, "SampleRGB" )
		self.MinSampleRGB = GetEmitterOption( options, "MinSampleRGB" )		or self.SampleRGB
		self.MaxSampleRGB = GetEmitterOption( options, "MaxSampleRGB" )
		self.SampleAlpha = GetEmitterOption( options, "SampleAlpha" )
		self.MinSampleAlpha = GetEmitterOption( options, "MinSampleAlpha" )	or self.SampleAlpha
		self.MaxSampleAlpha = GetEmitterOption( options, "MaxSampleAlpha" )

		self.MinColorR = GetEmitterOption( options, "MinColorR" )
		self.MaxColorR = GetEmitterOption( options, "MaxColorR" )
		self.MinColorG = GetEmitterOption( options, "MinColorG" )
		self.MaxColorG = GetEmitterOption( options, "MaxColorG" )
		self.MinColorB = GetEmitterOption( options, "MinColorB" )
		self.MaxColorB = GetEmitterOption( options, "MaxColorB" )
		self.MinColorA = GetEmitterOption( options, "MinColorA" )
		self.MaxColorA = GetEmitterOption( options, "MaxColorA" )

		self.AlphaFunction = GetEmitterOption( options, "AlphaFunction" ) or nil
		self.GrowthFunction = GetEmitterOption( options, "GrowthFunction" ) or nil
		self.RotationFunction = GetEmitterOption( options, "RotationFunction" )	or nil
		self.SampleFunction = GetEmitterOption( options, "SampleFunction" )	or nil
		self.SphericalOffsetFunction = GetEmitterOption( options, "SphericalOffsetFunction" ) or nil
		self.UVFunction = GetEmitterOption( options, "UVFunction" ) or nil
		self.UVCoordsFunction = GetEmitterOption( options, "UVCoordsFunction" ) or nil
		self.VertexColorFunction = GetEmitterOption( options, "VertexColorFunction" ) or nil
		self.VectorAngleFunction = GetEmitterOption( options, "VectorAngleFunction" ) or nil
		self.VectorRadiusFunction = GetEmitterOption( options, "VectorRadiusFunction" )
		self.VelocityFunction = GetEmitterOption( options, "VelocityFunction" ) or nil

		self.AlphaShift = GetEmitterOption( options, "AlphaShift" ) or 0
		self.ColorShift = GetEmitterOption( options, "ColorShift" ) or 0
		self.InferGradient = true == GetEmitterOption( options, "InferGradient" )

		self.Desaturation = GetEmitterOption( options, "Desaturation" ) or 0

		self.MinRotation = GetEmitterOption( options, "MinRotation" ) or 0
		self.MaxRotation = GetEmitterOption( options, "MaxRotation" ) or self.MinRotation

		self.MinAngularVelocity = GetEmitterOption( options, "MinAngularVelocity" ) or 0
		self.MaxAngularVelocity = GetEmitterOption( options, "MaxAngularVelocity" ) or 0

		self.VectorPattern = GetEmitterOption( options, "VectorPattern" )
		self.MinVectorX = GetEmitterOption( options, "MinVectorX" )
		self.MaxVectorX = GetEmitterOption( options, "MaxVectorX" )
		self.MinVectorY = GetEmitterOption( options, "MinVectorY" )
		self.MaxVectorY = GetEmitterOption( options, "MaxVectorY" )
		self.MinVectorZ = GetEmitterOption( options, "MinVectorZ" )
		self.MaxVectorZ = GetEmitterOption( options, "MaxVectorZ" )
		self.BezierAxisY = true == GetEmitterOption( options, "BezierAxisY" )
		self.GravityCoefficient = GetEmitterOption( options, "GravityCoefficient" ) or 0

		self.EmissionX = GetEmitterOption( options, "EmissionX" )
		self.EmissionY = GetEmitterOption( options, "EmissionY" )
		self.EmissionZ = GetEmitterOption( options, "EmissionZ" )
		self.Localized = true == GetEmitterOption( options, "Localized" )	-- Default: false

		self.MaxEmissionRadiusX = GetEmitterOption( options, "MaxEmissionRadiusX" )
		self.MaxEmissionRadiusY = GetEmitterOption( options, "MaxEmissionRadiusY" )
		self.MaxEmissionRadiusZ = GetEmitterOption( options, "MaxEmissionRadiusZ" )

		self.EmissionFrequency = GetEmitterOption( options, "EmissionFrequency" )
		self.MinActiveEmissions = GetEmitterOption( options, "MinActiveEmissions" ) or 0
		self.MaxActiveEmissions = GetEmitterOption( options, "MaxActiveEmissions" )
		self.MaxEmissionSegments = GetEmitterOption( options, "MaxEmissionSegments" )
		self.ReuseActiveEmissions = GetEmitterOption( options, "ReuseActiveEmissions" )	or false

		self.EmissionPattern = GetEmitterOption( options, "EmissionPattern" )
		self.EmissionMinRadius = GetEmitterOption( options, "EmissionMinRadius" ) or 0.05
		self.EmissionMaxRadius = GetEmitterOption( options, "EmissionMaxRadius" ) or 0.15
		self.EmissionInterval = GetEmitterOption( options, "EmissionInterval" )
		self.EmissionIntervalOffset = GetEmitterOption( options, "EmissionIntervalOffset" )
		self.PerEmissionLinearOffset = GetEmitterOption( options, "PerEmissionLinearOffset" )

		self.DrawLevelOffset = GetEmitterOption( options, "DrawLevelOffset" ) or 0

		self.InvertVectorX = GetEmitterOption( options, "InvertVectorX" )
		self.InvertVectorY = GetEmitterOption( options, "InvertVectorY" )
		self.InvertVectorZ = GetEmitterOption( options, "InvertVectorZ" )
		self.UniformVectors = GetEmitterOption( options, "UniformVectors" )

		self.UseCellAnimation = true == GetEmitterOption( options, "UseCellAnimation" )	-- Default: false
		self.RandomizeCellAnimation = true == GetEmitterOption( options, "RandomizeCellAnimation" ) -- Default: false
		self.CellsStatic = true == GetEmitterOption( options, "CellsStatic" )			-- Default: false
		self.CellsFPS = tonumber( GetEmitterOption( options, "CellsFPS" ) or 0 )
		self.CellsX = tonumber( GetEmitterOption( options, "CellsX" ) or 0 )
		self.CellsY = tonumber( GetEmitterOption( options, "CellsY" ) or 0 )

		self.PreserveTextureCoords = true == GetEmitterOption( options, "PreserveTextureCoords" )
		self.TextureCoords = GetEmitterOption( options, "TextureCoords" )
		self.UseTextureUVAnimation = true == GetEmitterOption( options, "UseTextureUVAnimation" )
		self.UseAutoDrawLevel = false ~= GetEmitterOption( options, "UseAutoDrawLevel" )

		self.LockAtRange = true == GetEmitterOption( options, "LockAtRange" )			-- Default: false
		self.RecycleAtRange = false ~= GetEmitterOption( options, "RecycleAtRange" )	-- Default: true

		self.MaxLocalRadius = GetEmitterOption( options, "MaxLocalRadius" )
		self.LocalOffsetY = tonumber( GetEmitterOption( options, "LocalOffsetY" ) or 0 )-- Default: 0

		if not self.Texture then table.insert( invalidKeys, "Texture is required." ) end
		if not self.EmissionFrequency then table.insert( invalidKeys, "EmissionFrequency is required." ) end
		if not self.MaxActiveEmissions then table.insert( invalidKeys, "MaxActiveEmissions is required." ) end
		if not self.MinTTL then table.insert( invalidKeys, "MinTTL is required." ) end
		if not EHT.Util.IsListValue( EHT.ParticleEmitter.PATTERNS, self.VectorPattern ) then table.insert( invalidKeys, string.format( "'%s' is not a valid Vector Pattern.", self.VectorPattern or "nil" ) ) end
		if not EHT.Util.IsListValue( EHT.ParticleEmitter.PATTERNS, self.EmissionPattern ) then table.insert( invalidKeys, string.format( "'%s' is not a valid Emission Pattern.", self.EmissionPattern or "nil" ) ) end

		for key, _ in pairs( options ) do
			table.insert( invalidKeys, string.format( "'%s' is not an option", key ) )
		end

		if 0 < #invalidKeys then
			error( string.format( "ParticleEmitter: Invalid option(s) specified:\n%s", table.concat( invalidKeys, "\n" ) ) )
			return nil
		end

		self:Reset()

		return self
	end
end

function EHT.ParticleEmitter:Reset()
	self.Effect.EffectType.ResetOnPosition, self.Effect.EffectType.ResetOnOrient, self.Effect.EffectType.ResetOnScale, self.Effect.EffectType.ResetOnColor = true, true, true, true
	self.Effect:SetAutoDrawLevelEnabled( true )
	self.Effect:SetAutoColorEnabled( false )
	self.Effect:SetAutoPositionEnabled( false )
	self.Effect:SetAutoOrientationEnabled( false )
	self.Effect:SetAutoSizeEnabled( false )
	self.Effect:SetCameraFacing( self.AutoOrientation == self.ORIENTATIONS.CAMERA )

	self.Suspended = false
	self.NextEmission = self.NextEmission or 0
	self.PerEmissionDelay = self.EmissionFrequency

	if self.MinGrowth and self.MaxGrowth and ( 0 ~= self.MinGrowth or 0 ~= self.MaxGrowth ) then
		self.MinGrowth, self.MaxGrowth = math.min( self.MinGrowth, self.MaxGrowth ), math.max( self.MinGrowth, self.MaxGrowth )
	else
		self.MinGrowth, self.MaxGrowth = nil, nil
	end

	if self.MinGrowthY and self.MaxGrowthY and ( 0 ~= self.MinGrowthY or 0 ~= self.MaxGrowthY ) then
		self.MinGrowthY, self.MaxGrowthY = math.min( self.MinGrowthY, self.MaxGrowthY ), math.max( self.MinGrowthY, self.MaxGrowthY )
	else
		self.MinGrowthY, self.MaxGrowthY = nil, nil
	end

	if ( self.MinTTL and self.MaxTTL ) then self.RangeTTL = ( self.MaxTTL - self.MinTTL ) else self.RangeTTL = nil end

	self.RangeColorR = ( self.MinColorR and self.MaxColorR ) and ( self.MaxColorR - self.MinColorR ) or 0
	self.RangeColorG = ( self.MinColorG and self.MaxColorG ) and ( self.MaxColorG - self.MinColorG ) or 0
	self.RangeColorB = ( self.MinColorB and self.MaxColorB ) and ( self.MaxColorB - self.MinColorB ) or 0
	self.RangeColorA = ( self.MinColorA and self.MaxColorA ) and ( self.MaxColorA - self.MinColorA ) or 0

	self.RangeRGB = ( self.MinSampleRGB and self.MaxSampleRGB ) and ( self.MaxSampleRGB - self.MinSampleRGB ) or nil
	self.RangeAlpha = ( self.MinSampleAlpha and self.MaxSampleAlpha ) and ( self.MaxSampleAlpha - self.MinSampleAlpha ) or nil

	self.RangeSize = ( self.MinSize and self.MaxSize ) and ( self.MaxSize - self.MinSize ) or 0
	self.RangeSizeY = ( self.MinSizeY and self.MaxSizeY ) and ( self.MaxSizeY - self.MinSizeY ) or 0
	if self.RangeSizeY == self.RangeSize then self.RangeSizeY = nil end

	self.RangeRotation = ( self.MinRotation and self.MaxRotation ) and ( self.MaxRotation - self.MinRotation ) or 0

	if ( self.MinAngularVelocity and self.MaxAngularVelocity ) then self.RangeAngularVelocity = ( self.MaxAngularVelocity - self.MinAngularVelocity ) else self.RangeAngularVelocity = nil end

	self.RangeVectorX = ( self.MinVectorX and self.MaxVectorX ) and ( self.MaxVectorX - self.MinVectorX ) or 0
	self.RangeVectorY = ( self.MinVectorY and self.MaxVectorY ) and ( self.MaxVectorY - self.MinVectorY ) or 0
	self.RangeVectorZ = ( self.MinVectorZ and self.MaxVectorZ ) and ( self.MaxVectorZ - self.MinVectorZ ) or 0

	self.MaxOffsetX = self.MaxOffsetX or self.MaxOffset
	self.MaxOffsetY = self.MaxOffsetY or self.MaxOffset
	self.MaxOffsetZ = self.MaxOffsetZ or self.MaxOffset

	self.PerEmissionLinearOffset = self.PerEmissionLinearOffset or 4

	if self.EmissionPattern == EHT.ParticleEmitter.PATTERNS.SPHERICAL then
		local maxSegments = self.MaxEmissionSegments or self.MaxActiveEmissions or 1
		self.VerticalEmissionSegments = math.ceil( math.sqrt( maxSegments ) )
		self.VerticalEmissionSegmentAngle = math.pi / self.VerticalEmissionSegments
		self.HorizontalEmissionSegmentAngle = ( 2 * math.pi ) / self.VerticalEmissionSegments

		local verticalSegmentAngle = self.VerticalEmissionSegmentAngle
		local segments = { }
		for verticalIndex = 1, self.VerticalEmissionSegments + 1 do
			local verticalAngle = verticalSegmentAngle * ( verticalIndex - 0.5 )
			local horizontalOffset = verticalIndex % 2 == 0 and 0 or -0.5
			local numHorizontalSegments = math.ceil( math.sin( ( -0.5 + verticalIndex ) / self.VerticalEmissionSegments * math.pi ) * self.VerticalEmissionSegments )
			local horizontalSegmentAngle = 2 * math.pi / numHorizontalSegments

			for horizontalIndex = 1, numHorizontalSegments do
				local horizontalAngle = horizontalSegmentAngle * ( horizontalIndex + horizontalOffset )
				local segment =
				{
					angleH = horizontalAngle,
					angleV = verticalAngle,
					segmentH = horizontalSegmentAngle,
					segmentV = verticalSegmentAngle,
				}

				table.insert( segments, segment )
			end
		end
		self.EmissionSegments = segments
	end

	if self.UseCellAnimation then
		self.CellsCount = self.CellsX * self.CellsY
		if self.CellsFPS and 0 < self.CellsFPS then
			self.CellsInterval = 1000 * ( self.CellsCount / self.CellsFPS )
		else
			self.CellsInterval = 0
		end
	end

	if self.Localized then
		if not self.MaxLocalRadius then
			self.MaxLocalRadius = math.min( MAX_LOCALIZED_DISTANCE, math.max( self.MaxOffsetX or 0, self.MaxOffsetY or 0, self.MaxOffsetZ or 0 ) )
			if 0 == self.MaxLocalRadius then
				self.MaxLocalRadius = MAX_LOCALIZED_DISTANCE
			end
		end

		self.RecycleAtRange = true
	else
		self.MaxLocalRadius = nil
	end

	self.LocalOffsetY = self.LocalOffsetY or 0

	for _, p in ipairs( self.Effect.Particles ) do
		self:SetupParticle( p )
	end
end

function EHT.ParticleEmitter:Suspend()
	self.Suspended = true
end

function EHT.ParticleEmitter:Resume()
	self.Suspended = false
end

function EHT.ParticleEmitter:Update()
	local ft = FrameTime
	local ftPrev = self.PreviousFrametime or ft
	local fDelta = ( ft - ftPrev ) / 1000
	local ap = self.ActiveParticles
	local interval, p, x, y, z, r, g, b, a
	local eX, eY, eZ = self.Effect:GetPosition()
	local angle = self.Yaw
	local manualOrientation = self.AutoOrientation == self.ORIENTATIONS.MANUAL
	local vectorAngle = self.AutoOrientation == self.ORIENTATIONS.VECTOR
	local cameraFacing = self.AutoOrientation == self.ORIENTATIONS.CAMERA
	local maxOffsetX, maxOffsetY, maxOffsetZ = self.MaxOffsetX, self.MaxOffsetY, self.MaxOffsetZ
	local distance, duration

	self.PreviousFrametime = ft

	if self.DrawLevelTime ~= ft or not self.DrawLevels then
		self.DrawLevelTime = ft
		self.DrawLevels = { }
	end

	local drawLevels = self.DrawLevels
	local index = #ap
	local deactivated = false
	local windX, windZ = EHT.ParticleEmitter.WindX, EHT.ParticleEmitter.WindZ
	--local localX, localY, localZ = self:GetLocalizedOrigin()
	local localX, localY, localZ, maxRadiusX, maxRadiusY, maxRadiusZ
	if self.Localized then
		localX, localY, localZ = self:GetLocalizedOrigin()
		maxRadiusX, maxRadiusY, maxRadiusZ = self.MaxLocalRadius, self.MaxLocalRadius, self.MaxLocalRadius
	else
		localX, localY, localZ = eX, eY, eZ
		maxRadiusX, maxRadiusY, maxRadiusZ = maxOffsetX, maxOffsetY, maxOffsetZ
	end

	while 0 < index do
		p = ap[index]
		if p then
			if not p.TTLDuration or ( p.TTLExpiration and p.TTLExpiration ~= 0 and p.TTLExpiration <= ft ) then
				self:DeactivateParticle( index )
			else
				local alphaCoeff = 1
				local ttlDelta = ft - p.BaseTime
				duration = ttlDelta / 1000
				interval = p.TTLExpiration == 0 and ( ( ttlDelta / p.TTLDuration ) % 1 ) or ( ttlDelta / p.TTLDuration )
				deactivated = false

				if not self.UseTextureUVAnimation then
					x, y, z = p:GetPosition()

					if self.VectorPattern == EHT.ParticleEmitter.PATTERNS.SPHERICAL then
						local radius = maxRadiusX * p.SphericalRadius
						x, y, z = EHT.World.RotateAxisY( 0, 0, radius, ( p.SphericalOffset + duration / p.SphericalInterval ) * RAD360 )
						x, y, z = EHT.World.RotateAxisZ( x, y, z, p.SphericalAngle )
						x, y, z = x + localX, y + localY, z + localZ
					end

					if self.RecycleAtRange then
						local distX = maxRadiusX and ( ( x - localX ) / maxRadiusX ) or 0
						local distY = maxRadiusY and ( ( y - localY ) / maxRadiusY ) or 0
						local distZ = maxRadiusZ and ( ( z - localZ ) / maxRadiusZ ) or 0
						local distanceCoeff = math.max( math.abs( distX ), math.abs( distY ), math.abs( distZ ) )

						if distanceCoeff > 1 then
							if distX > 1 then
								x = localX - ( x - localX )
							elseif distX < 1 then
								x = localX + ( x - localX )
							end

							if distY > 1 then
								y = localY - ( y - localY )
							elseif distY < 1 then
								y = localY + ( y - localY )
							end

							if distZ > 1 then
								z = localZ - ( z - localZ )
							elseif distZ < 1 then
								z = localZ + ( z - localZ )
							end

							alphaCoeff = 0
						else
							alphaCoeff = 1 - EaseIn3( zo_clamp( distanceCoeff, 0, 1 ) )
						end
					end

					local wX, wZ, windFactor = 0, 0, self.WindFactor
					if windFactor then
						wX, wZ = windX * windFactor, windZ * windFactor
					end

					local spiralInterval = p.SpiralInterval
					if spiralInterval then
						local spiralOffset = p.SpiralIntervalOffset or 0
						local currentInterval = GetLinearInterval( spiralInterval, self.EmissionIntervalOffset + spiralOffset )
						local coefficient = 1 - 0.75 * interval
						local spiralAngle = 2 * math.pi * currentInterval

						if wX ~= 0 then
							p.EmissionX = p.EmissionX + fDelta * wX
							p.EmissionZ = p.EmissionZ + fDelta * wZ
						end

						x = p.EmissionX + coefficient * p.VecX * math.sin( spiralAngle )
						z = p.EmissionZ + coefficient * p.VecZ * math.cos( spiralAngle )
						y = y + fDelta * p.VecY
					elseif not self.BezierAxisY then
						x, y, z = x + fDelta * ( p.VecX + wX + ( duration * p.GravityX ) ), y + fDelta * ( p.VecY + ( duration * p.GravityY ) ), z + fDelta * ( p.VecZ + wZ + ( duration * p.GravityZ ) )
					else
						local bez = 1 - ZO_BezierInEase( 1 - interval )
						x, y, z = x + fDelta * ( p.VecX + wX ), p.EmissionY + bez * p.VecY, z + fDelta * ( p.VecZ + wZ )
					end

					if self.UVFunction then
						p:RotateCoords( self.UVFunction( p, interval, duration, p.BaseRotation ) )
					elseif self.UVCoordsFunction then
						p:SetTextureCoords( self.UVCoordsFunction( p, interval, duration ) )
					end

					if cameraFacing then
						p:SetPosition( x, y, z )
						if self.RotationFunction then
							p:SetTextureRotation( self.RotationFunction( p, interval, duration, p.BaseRotation ) )
						elseif not self.PreserveTextureCoords then
							p:SetTextureRotation( p.BaseRotation + ( ttlDelta / 1000 ) * p.AngularVelocity )
						end
					else
						if vectorAngle then
							angle = math.atan2( p.VecX + wX, p.VecZ + wZ )
						end

						if manualOrientation then
							p:SetPositionAndOrientation( x, y, z, p.Pitch, p.Yaw, p.Roll )
						elseif not self.UseCellAnimation then
							p:SetPositionAndOrientation( x, y, z, self.Pitch, angle, self.Roll )
							if self.RotationFunction then
								p:SetTextureRotation( self.RotationFunction( p, interval, duration, p.BaseRotation ) )
							elseif not self.PreserveTextureCoords then
								p:SetTextureRotation( p.BaseRotation + ( ttlDelta / 1000 ) * p.AngularVelocity )
							end
						else
							p:SetPositionAndOrientation( x, y, z, self.Pitch, angle, p.Roll + fDelta * p.AngularVelocity )
						end
					end
					
					if self.SampleFunction then
						p:SetSampleProcessing( self.SampleFunction( p, interval, duration, p.sRGB ) )
					end

					if self.GrowthFunction then
						p:SetSize( self.GrowthFunction( p, interval, duration, p.BaseSize, p.BaseSizeY ) )
					else
						local growth, growthY = p.Growth, p.GrowthY
						if growth or growthY then
							p:SetSize( p.BaseSize + ( growth or 0 ) * interval, p.BaseSizeY + ( growthY or 0 ) * interval )
						end
					end

					if not self.PreserveTextureCoords and self.UseCellAnimation and not self.CellsStatic then
						p:SetTextureCoords( GetIntervalSurface( self.CellsX, self.CellsY, p.CellsInterval or self.CellsInterval, p.CellOffset ) )
					end
				elseif not self.PreserveTextureCoords then
					local x1, x2, y1, y2 = 0, 1, 0, 1
					local oX, oY = self.VecOffX or 0, self.VecOffY or 0

					if 0 < p.VecX then
						x1, x2 = -oX - p.VecX * interval, 1 + oX + p.VecX * ( 1 - interval )
					else
						x1, x2 = -oX + p.VecX * ( 1 - interval ), 1 + oX - p.VecX * interval
					end 

					if 0 < p.VecY then
						y1, y2 = -oY - p.VecY * interval, 1 + oY + p.VecY * ( 1 - interval )
					else
						y1, y2 = -oY + p.VecY * ( 1 - interval ), 1 + oY - p.VecY * interval
					end

					p:SetTextureCoords( x1, x2, y1, y2 )
				end

				if not deactivated then
					if self.VertexColorFunction then
						local r1, g1, b1, a1, r2, g2, b2, a2, r3, g3, b3, a3, r4, g4, b4, a4 = self.VertexColorFunction( p, interval, duration )
						p:SetVertexColors( 1, r1, g1, b1, a1 )
						p:SetVertexColors( 2, r2, g2, b2, a2 )
						p:SetVertexColors( 4, r3, g3, b3, a3 )
						p:SetVertexColors( 8, r4, g4, b4, a4 )
					elseif self.AlphaFunction then
						local colorShift = ( self.ColorShift or 0 ) * interval
						a = alphaCoeff * self.AlphaFunction( p, interval, duration, p.BaseA )
						p:SetColor( p.BaseR + colorShift, p.BaseG + colorShift, p.BaseB + colorShift, a )
					else
						local alphaShift, colorShift = self.AlphaShift, self.ColorShift * interval
						if 0 < alphaShift then
							if 0.5 > interval then
								a = p.BaseA + 2 * alphaShift * interval
							else
								a = p.BaseA + 2 * alphaShift * ( 1 - interval )
							end
						elseif 0 > alphaShift then
							a = p.BaseA + alphaShift * interval
						else
							a = p.BaseA
						end

						p:SetColor( p.BaseR + colorShift, p.BaseG + colorShift, p.BaseB + colorShift, alphaCoeff * a ) -- ( fade and ( a * fade ) or a ) )
					end

					if p:GetHidden() then
						p:AutoUpdateDrawLevel( true )
						p:SetHidden( false )
					end
				end
			end
		end

		index = index - 1
	end

	local emitParticle = true

	if self.Localized then
		local halfSizeX, halfSizeY, halfSizeZ = self.Effect:GetSize()
		halfSizeX, halfSizeY, halfSizeZ = 0.5 * halfSizeX, 0.5 * halfSizeY, 0.5 * halfSizeZ
		if math.abs( PlayerX - eX ) > halfSizeX or math.abs( PlayerY - eY ) > halfSizeY or math.abs( PlayerZ - eZ ) > halfSizeZ then
			emitParticle = false
		end
	end

	if emitParticle and not self.Suspended and ft >= self.NextEmission then
		if 0 < self:EmitParticle() then
			self.NextEmission = ft + self.PerEmissionDelay * ( 1 - ( 0.2 * math.random() ) )
		end
	end
end

function EHT.ParticleEmitter:DeactivateParticle( index )
	local p = table.remove( self.ActiveParticles, index )
	if not p then return nil end

	table.insert( self.InactiveParticles, p )

	p:SetHidden( true )
	return p
end

function EHT.ParticleEmitter:RecycleParticle( index )
	local p = table.remove( self.ActiveParticles, index )
	if not p then return nil end

	p:SetHidden( true )
	return p
end

function EHT.ParticleEmitter:GetNextEmissionSegment( segmentIndex )
	local segments = self.EmissionSegments
	local numSegments = #segments

	if segmentIndex < numSegments then
		local swapIndex = math.random( segmentIndex, numSegments )
		local segment

		if segmentIndex ~= swapIndex then
			segment = segments[swapIndex]
			segments[swapIndex] = segments[segmentIndex]
			segments[segmentIndex] = segment
		else
			segment = segments[segmentIndex]
		end

		segmentIndex = segmentIndex + 1
		return segmentIndex, segment
	else
		return 1, segments[numSegments]
	end
end

function EHT.ParticleEmitter:SetupParticle( p )
	if self.AdditiveBlending then
		p:SetAdditive( true )
	elseif self.ColorDodgeBlending then
		p:SetDodge( true )
	else
		p:SetAdditive( false )
	end

	if not self.RangeColorR then
		p.BaseR, p.BaseG, p.BaseB, p.BaseA = self.MinColorR, self.MinColorG, self.MinColorB, self.MinColorA
	else
		p.BaseR = self.MinColorR + self.RangeColorR * math.random()
		p.BaseG = self.MinColorG + self.RangeColorG * math.random()
		p.BaseB = self.MinColorB + self.RangeColorB * math.random()
		p.BaseA = self.MinColorA + self.RangeColorA * math.random()
	end

	local sRGB = self.RangeRGB and ( self.MinSampleRGB + rand( 0, self.RangeRGB ) ) or self.SampleRGB or 1
	local sAlpha = self.RangeAlpha and ( self.MinSampleAlpha + rand( 0, self.RangeAlpha ) ) or self.SampleAlpha or 0
	p.sRGB = sRGB

	if self.RangeSize then
		p.BaseSize = self.MinSize + self.RangeSize * math.random()
		if self.RangeSizeY then
			p.BaseSizeY = self.MinSizeY + self.RangeSizeY * math.random()
		else
			p.BaseSizeY = p.BaseSize
		end
	else
		p.BaseSize = self.MinSize
		p.BaseSizeY = self.MinSizeY
	end

	if self.MinGrowth and self.MaxGrowth then
		p.Growth = rand( self.MinGrowth, self.MaxGrowth )
	end

	if self.MinGrowthY and self.MaxGrowthY then
		p.GrowthY = rand( self.MinGrowthY, self.MaxGrowthY )
	end
end

function EHT.ParticleEmitter:EmitParticle()
	local textureTable = "table" == type( self.Texture ) and self.Texture or nil
	local maxParticles = #self.ActiveParticles >= self.MaxActiveEmissions

	if maxParticles and not self.ReuseActiveEmissions then
		return 0
	end

	local eX, eY, eZ = self.Effect:GetPosition()
	local emissions, maxEmissions = 0, 0

	if 0 < self.MinActiveEmissions and #self.ActiveParticles < self.MinActiveEmissions then
		maxEmissions = self.MinActiveEmissions - #self.ActiveParticles
	end

	if self.EmissionFrequency < UPDATE_EFFECTS_INTERVAL then
		maxEmissions = math.max( maxEmissions, math.ceil( UPDATE_EFFECTS_INTERVAL / self.EmissionFrequency ) )
	end

	maxEmissions = math.min( maxEmissions, EHT.ParticleEmitter.MAX_EMISSIONS_PER_FRAME )

	local maxEmissionRadiusX, maxEmissionRadiusY, maxEmissionRadiusZ = self.MaxEmissionRadiusX, self.MaxEmissionRadiusY, self.MaxEmissionRadiusZ
	local minX, minY, minZ, maxX, maxY, maxZ
	local perEmissionIntervalShift = 0

	if self.Localized then
		local radius = PARTIAL_LOCALIZED_DISTANCE
		local ox, oy, oz = self:GetLocalizedOrigin()
		minX, minY, minZ, maxX, maxY, maxZ = ox - radius, oy, oz - radius, ox + radius, oy + 0.5 * radius, oz + radius
	else
		minX, minY, minZ = self.EmissionX - maxEmissionRadiusX, self.EmissionY - maxEmissionRadiusY, self.EmissionZ - maxEmissionRadiusZ
		maxX, maxY, maxZ = self.EmissionX + maxEmissionRadiusX, self.EmissionY + maxEmissionRadiusY, self.EmissionZ + maxEmissionRadiusZ
	end

	repeat
		local p = table.remove( self.InactiveParticles, 1 )

		if self.Texture then
			if not p and not maxParticles then
				if textureTable then
					local textureIndex = ( #self.Effect.Particles % #textureTable ) + 1
					p = self.Effect:AddParticle( textureTable[textureIndex],		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
				else
					p = self.Effect:AddParticle( self.Texture,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
				end
			else
				if not p then
					p = self:RecycleParticle( math.random( 1, #self.ActiveParticles ) )
				end

				if p and textureTable then
					local textureIndex = math.random( 1, #textureTable )
					p:SetTextureFile( textureTable[textureIndex] )
				end
			end
		end

		if not p then
			p = self:RecycleParticle( 1 )
		end

		if not p then
			return emissions
		end

		p:SetHidden( true )

		local ft = FrameTime
		local interval

		table.insert( self.ActiveParticles, p )

		p.BaseTime = ft

		if self.TextureCoords and not self.PreserveTextureCoords then
			p:SetTextureCoords( self.TextureCoords[1], self.TextureCoords[2], self.TextureCoords[3], self.TextureCoords[4] )
		end

		-- Apply the basic particle properties of this emitter.
		self:SetupParticle( p )

		p:SetColor( p.BaseR, p.BaseG, p.BaseB, p.BaseA )
		p:SetDesaturation( self.Desaturation )
		p:SetSampleProcessing( sRGB, sAlpha )

		if self.EmissionPattern == EHT.ParticleEmitter.PATTERNS.RANDOM then
			p.EmissionX, p.EmissionY, p.EmissionZ = rand( minX, maxX ), rand( minY, maxY ), rand( minZ, maxZ )
		elseif self.EmissionPattern == EHT.ParticleEmitter.PATTERNS.LINEAR then
			if not interval then interval = GetLinearInterval( self.EmissionInterval, self.EmissionIntervalOffset + perEmissionIntervalShift ) end
			local offset = ( ( self.LinearEmissionOffset or 0 ) + 1 ) % 2
			self.LinearEmissionOffset = offset
			interval = ( interval + offset * 0.5 ) % 1
			p.EmissionX, p.EmissionY, p.EmissionZ = 
				self.EmissionX + maxEmissionRadiusX * interval,
				self.EmissionY + maxEmissionRadiusY * interval,
				self.EmissionZ + maxEmissionRadiusZ * interval
		elseif self.EmissionPattern == EHT.ParticleEmitter.PATTERNS.RADIAL then
			if not interval then interval = GetLinearInterval( self.EmissionInterval, self.EmissionIntervalOffset + perEmissionIntervalShift ) end
			p.EmissionX, p.EmissionY, p.EmissionZ = 
				self.EmissionX + maxEmissionRadiusX * math.sin( 2 * math.pi * ( interval + 0.35 ) ) * ( 0.1 + 0.9 * math.random() ),
				self.EmissionY + maxEmissionRadiusY * interval * ( -1 + rand( 0, 2 ) ),
				self.EmissionZ + maxEmissionRadiusZ * math.cos( 2 * math.pi * ( interval + 0.35 ) ) * ( 0.1 + 0.9 * math.random() )
		elseif self.EmissionPattern == EHT.ParticleEmitter.PATTERNS.PERIMETER then
			local interval = 2 * math.pi * math.random()
			p.EmissionX, p.EmissionY, p.EmissionZ = 
				self.EmissionX + maxEmissionRadiusX * math.sin( interval ),
				self.EmissionY + maxEmissionRadiusY * math.random(),
				self.EmissionZ + maxEmissionRadiusZ * math.cos( interval )
		elseif self.EmissionPattern == EHT.ParticleEmitter.PATTERNS.CAMERA_DEPTH then
			p.EmissionX, p.EmissionY, p.EmissionZ = 
				self.EmissionX + maxEmissionRadiusX * math.sin( CameraHeading ),
				self.EmissionY + maxEmissionRadiusY,
				self.EmissionZ + maxEmissionRadiusZ * math.cos( CameraHeading )
		elseif self.EmissionPattern == EHT.ParticleEmitter.PATTERNS.CYCLICAL then
			self.LinearCameraInterval = ( ( self.LinearCameraInterval or 0 ) + ( 1 / ( self.MaxActiveEmissions + 2 ) ) )
			if 1 < self.LinearCameraInterval then
				self.LinearCameraInterval = self.LinearCameraInterval % 1
				self.LinearCameraOffset = ( ( self.LinearCameraOffset or 0 ) + 1 ) % 2
			end

			local interval = -1 + 2 * self.LinearCameraInterval
			local offset = self.PerEmissionLinearOffset * ( self.MaxActiveEmissions + 2 )
			p.EmissionX, p.EmissionY, p.EmissionZ = self.EmissionX, self.EmissionY, self.EmissionZ

			local camAngle = self.AutoOrientation == EHT.ParticleEmitter.ORIENTATIONS.NONE and self.Yaw or CameraHeading
			local sinAngle, cosAngle = math.sin( camAngle ), math.cos( camAngle )
			p.EmissionX = p.EmissionX + 5 * ( self.LinearCameraOffset or 0 ) + sinAngle * offset * interval
			p.EmissionZ = p.EmissionZ + 5 * ( self.LinearCameraOffset or 0 ) + cosAngle * offset * interval
		elseif self.EmissionPattern == EHT.ParticleEmitter.PATTERNS.SPHERICAL then
			local nextSegmentIndex, segment = self:GetNextEmissionSegment( self.SegmentIndex or 1 )
			self.SegmentIndex = nextSegmentIndex

			local angleH = segment.angleH
			local angleV = segment.angleV + math.random() * segment.segmentV
			local radiusH = math.abs( math.sin( angleV ) ) * maxEmissionRadiusX
			angleH = angleH + math.random() * segment.segmentH

			p.EmissionX, p.EmissionY, p.EmissionZ = 
				self.EmissionX + radiusH * math.sin( angleH ),
				self.EmissionY + maxEmissionRadiusY * math.cos( angleV ),
				self.EmissionZ + radiusH * math.cos( angleH )
		elseif self.EmissionPattern == EHT.ParticleEmitter.PATTERNS.PLANAR then
			local offsetX = maxEmissionRadiusX * ( -1 + 2 * math.random() )
			local offsetY = maxEmissionRadiusY * ( -1 + 2 * math.random() )
			local offsetZ = 0
			local pitch, yaw, roll = self.Effect:GetOrientation()
			offsetX, offsetY, offsetZ = EHT.World.Rotate( offsetX, offsetY, offsetZ, pitch, yaw, roll )
			p.EmissionX, p.EmissionY, p.EmissionZ = self.EmissionX + offsetX, self.EmissionY + offsetY, self.EmissionZ + offsetZ
		else
			p.EmissionX, p.EmissionY, p.EmissionZ = self.EmissionX, self.EmissionY, self.EmissionZ
		end

		if self.AutoOrientation == self.ORIENTATIONS.CAMERA then
			p:SetCameraFacing( true )
		end

		p:SetPositionAndOrientation( p.EmissionX, p.EmissionY, p.EmissionZ, 0, CameraHeading, 0 )

		if self.VelocityFunction then
			p.VecX, p.VecY, p.VecZ = self.VelocityFunction( p )
		elseif self.VectorPattern == EHT.ParticleEmitter.PATTERNS.RANDOM then
			p.VecX = self.MinVectorX + self.RangeVectorX * math.random()

			if not self.UniformVectors then
				p.VecY = self.MinVectorY + self.RangeVectorY * math.random()
				p.VecZ = self.MinVectorZ + self.RangeVectorZ * math.random()
			else
				if self.RangeVectorY then p.VecY = p.VecX end
				if self.RangeVectorZ then p.VecZ = p.VecX end
			end
		elseif self.VectorPattern == EHT.ParticleEmitter.PATTERNS.LINEAR then
			if not interval then interval = GetLinearInterval( self.EmissionInterval, self.EmissionIntervalOffset + perEmissionIntervalShift ) end

			p.VecX = self.MinVectorX + self.RangeVectorX * interval

			if not self.UniformVectors then
				p.VecY = self.MinVectorY + self.RangeVectorY * interval
				p.VecZ = self.MinVectorZ + self.RangeVectorZ * interval
			else
				if self.RangeVectorY then p.VecY = p.VecX end
				if self.RangeVectorZ then p.VecZ = p.VecX end
			end
		elseif self.VectorPattern == EHT.ParticleEmitter.PATTERNS.RADIAL then
			if not interval then interval = GetLinearInterval( self.EmissionInterval, self.EmissionIntervalOffset + perEmissionIntervalShift ) end
			local sinX, cosZ = math.sin( 2 * math.pi * interval ), math.cos( 2 * math.pi * interval )

			p.VecX = self.MinVectorX * sinX + self.RangeVectorX * sinX

			if not self.UniformVectors then
				p.VecY = self.MinVectorY + self.RangeVectorY * math.random()
				p.VecZ = self.MinVectorZ * cosZ + self.RangeVectorZ * cosZ
			else
				if self.RangeVectorY then p.VecY = p.VecX end
				if self.RangeVectorZ then p.VecZ = p.VecX end
			end
		elseif self.VectorPattern == EHT.ParticleEmitter.PATTERNS.PERIMETER then
			local angle = math.atan2( p.EmissionX - self.EmissionX, p.EmissionZ - self.EmissionZ )

			p.VecX = ( self.MinVectorX + self.RangeVectorX ) * math.sin( angle )
			p.VecY = self.MinVectorY + self.RangeVectorY * math.random()
			p.VecZ = ( self.MinVectorZ + self.RangeVectorZ ) * math.cos( angle )
		elseif self.VectorPattern == EHT.ParticleEmitter.PATTERNS.CAMERA_DEPTH then
			p.VecX = self.MinVectorX + self.RangeVectorX * math.sin( CameraHeading )

			if not self.UniformVectors then
				p.VecY = self.MinVectorY + self.RangeVectorY
				p.VecZ = self.MinVectorZ + self.RangeVectorZ * math.cos( CameraHeading )
			else
				if self.RangeVectorY then p.VecY = p.VecX end
				if self.RangeVectorZ then p.VecZ = p.VecX end
			end
		elseif self.VectorPattern == EHT.ParticleEmitter.PATTERNS.CYCLICAL then
			if not interval then interval = GetLinearInterval( self.EmissionInterval, self.EmissionIntervalOffset + perEmissionIntervalShift ) end

			p.VecX = self.MinVectorX + self.RangeVectorX * interval * math.sin( CameraHeading )

			if not self.UniformVectors then
				p.VecY = self.MinVectorY + self.RangeVectorY * interval
				p.VecZ = self.MinVectorZ + self.RangeVectorZ * interval * math.cos( CameraHeading )
			else
				if self.RangeVectorY then p.VecY = p.VecX end
				if self.RangeVectorZ then p.VecZ = p.VecX end
			end
		elseif self.VectorPattern == EHT.ParticleEmitter.PATTERNS.SPIRAL then
			local radiusCoeff = math.random()
			local radius = zo_lerp( self.EmissionMinRadius, self.EmissionMaxRadius, radiusCoeff )
			p.SpiralInterval = ( 0.5 + 0.5 * radiusCoeff ) * self.EmissionInterval
			p.SpiralIntervalOffset = math.random( 0, self.EmissionInterval + perEmissionIntervalShift )

			local sizeX = self.MaxOffsetX or self.Effect.SizeX
			local sizeZ = self.MaxOffsetZ or self.Effect.SizeZ
			local maxOffsetX = sizeX - math.abs( self.EmissionX - p.EmissionX )
			local maxOffsetZ = sizeZ - math.abs( self.EmissionZ - p.EmissionZ )
			p.VecX, p.VecZ = radius * maxOffsetX, radius * maxOffsetZ
			p.VecY = self.MinVectorY + self.RangeVectorY * math.random()
		elseif self.VectorPattern == EHT.ParticleEmitter.PATTERNS.SPHERICAL then
			p.SphericalRadius = self.VectorRadiusFunction and self.VectorRadiusFunction( p ) or ( 0.25 + 0.75 * math.random() )
			p.SphericalAngle = self.VectorAngleFunction and self.VectorAngleFunction( p ) or 0
			p.SphericalInterval = self.EmissionInterval / 1000 * p.SphericalRadius
			p.SphericalOffset = self.SphericalOffsetFunction and self.SphericalOffsetFunction( p ) or math.random()
			p.VecX, p.VecY, p.VecZ = 0, 0, 0
		else
			p.VecX, p.VecY, p.VecZ = self.MinVectorX, self.MinVectorY, self.MinVectorZ
		end

		if self.InvertVectorX and 1 == math.random( 0, 1 ) then p.VecX = -p.VecX end
		if self.InvertVectorY and 1 == math.random( 0, 1 ) then p.VecY = -p.VecY end
		if self.InvertVectorZ and 1 == math.random( 0, 1 ) then p.VecZ = -p.VecZ end

		if self.UseTextureUVAnimation then
			local maxVec = math.max( math.abs( p.VecX or 0 ), math.abs( p.VecY or 0 ) )
			self.VecOffX, self.VecOffY = maxVec - math.abs( p.VecX or 0 ), maxVec - math.abs( p.VecY or 0 )
		end

		if not self.UseTextureUVAnimation then
			p:SetSize( p.BaseSize, p.BaseSizeY )
		else
			p:SetSize( p.BaseSize + ( p.Growth or 0 ), p.BaseSizeY + ( p.GrowthY or 0 ) )
		end

		p.BaseRotation = 0

		if not self.UseCellAnimation then
			if not self.PreserveTextureCoords then
				p.BaseRotation = self.MinRotation + self.RangeRotation * math.random()
				p:SetTextureRotation( p.BaseRotation )
			end
		else
			p.Roll = self.MinRotation + self.RangeRotation * math.random()

			if self.CellsStatic then
				p.CellOffset = rand( 0, p.CellsInterval or self.CellsInterval )
				p:SetTextureCoords( GetSurface( p.CellOffset, self.CellsX, self.CellsY ) )
			else
				p.CellOffset = rand( 0, p.CellsInterval or self.CellsInterval )
			end
		end

		if self.RangeAngularVelocity then
			p.AngularVelocity = self.MinAngularVelocity + self.RangeAngularVelocity * math.random()
		else
			p.AngularVelocity = self.MinAngularVelocity
		end

		p:AutoUpdateDrawLevel( true )

		if self.MinTTL == 0 then
			p.TTLExpiration = 0
		elseif self.RangeTTL then
			p.TTLExpiration = ft + self.MinTTL + self.RangeTTL * math.random()
		else
			p.TTLExpiration = ft + self.MinTTL
		end

		if self.RecycleAtRange and p.TTLExpiration ~= 0 then
			if self.MaxOffsetY and 0 < self.MaxOffsetY and 0 ~= p.VecY then
				p.TTLExpiration = math.min( p.TTLExpiration, ft + 1000 * ( ( 0 > p.VecY and ( p.EmissionY - ( eY - self.MaxOffsetY ) ) or ( ( eY + self.MaxOffsetY ) - p.EmissionY ) ) / math.abs( p.VecY ) ) )
			end
		end

		if p.TTLExpiration == 0 then
			p.TTLDuration = self.EmissionInterval or 1000
		else
			p.TTLDuration = p.TTLExpiration - ft
		end

		if self.UseCellAnimation and not self.CellsStatic and 0 == ( self.CellsInterval or 0 ) then
			p.CellsInterval = p.TTLDuration
		end

		p.GravityX, p.GravityY, p.GravityZ = ( -1 / p.TTLDuration / 1000 ) * p.VecX * self.GravityCoefficient, -45 * self.GravityCoefficient, ( -1 / p.TTLDuration / 1000 ) * p.VecZ * self.GravityCoefficient

		if self.OnEmission then
			self:OnEmission( p )
		end

		local numParticles = #self.ActiveParticles
		emissions = emissions + 1

		perEmissionIntervalShift = perEmissionIntervalShift + ( self.EmissionInterval or 0 ) * 0.1
		maxParticles = #self.ActiveParticles >= self.MaxActiveEmissions
	until emissions >= maxEmissions or maxParticles

	return emissions
end

do
	local pe = EHT.ParticleEmitter
	local prevFT, windAngle, windShiftVelocity, nextWindShift, windVelocity = 0, 0, 0, 0, 0

	pe.WindX, pe.WindY, pe.WindZ = 0, 0, 0
	pe.LocalX, pe.LocalY, pe.LocalZ = 0, 0, 0

	function EHT.ParticleEmitter:UpdateStatistics()
		local ft = FrameTime
		local fDelta = prevFT and ( ( ft - prevFT ) / 1000 ) or 1

		if ft > nextWindShift then
			local duration = rand()
			local maxVelocity = ( 1 - duration ) + 0.1
			windShiftVelocity = math.rad( rand( -20 * maxVelocity, 20 * maxVelocity ) )
			nextWindShift = ft + 20000 * ( duration + 0.1 )
			local shiftOffset = 0.5 > windVelocity and 0 or 3.5 < windVelocity and -1 or -0.5
			windVelocity = zo_clamp( windVelocity + ( shiftOffset + rand() ), 0, 4 )
		else
			windAngle = ( windAngle + fDelta * windShiftVelocity ) % RAD360
		end

		pe.WindX, pe.WindZ = windVelocity * math.sin( windAngle ), windVelocity * math.cos( windAngle )
		pe.LocalX, pe.LocalY, pe.LocalZ = PlayerX - 300 * pe.WindX - 200 * math.sin( CameraHeading ), PlayerY + PARTIAL_LOCALIZED_DISTANCE, PlayerZ - 300 * pe.WindZ - 200 * math.cos( CameraHeading )

		prevFT = ft
	end

	function EHT.ParticleEmitter:GetLocalizedOrigin()
		return pe.LocalX, pe.LocalY + self.LocalOffsetY, pe.LocalZ
	end

	function EHT.ParticleEmitter:GetLocalizedCoefficient( x, y, z )
		local originX, originY, originZ = self:GetLocalizedOrigin()
		return 1 - ( zo_distance3D( x, y, z, originX, originY, originZ ) / self.MaxLocalRadius )
	end
end

---[ Effect Animations ]---

function EHT.EffectAnimation:New( animateFunction )
	local obj = ZO_Object.New( self )
	obj.AnimateFunction = animateFunction
	return obj
end

function EHT.EffectAnimation:Animate( effect )
	self.AnimateFunction( self, effect )
end

local function ParticleAnimation( self, effect )
	local p, x, y, z, modv
	local width, height = effect:GetSize()
	local xOffset, zOffset = -0.5 * width, -0.5 * width
	local minX, minZ, maxX, maxZ = xOffset, xOffset, -xOffset, -xOffset
	local minY, maxY = -0.5 * height, 0.5 * height
	local ft = FrameTime
	local numP = #effect.Particles

	for index = 1, numP do
		p = effect.Particles[index]
		x, y, z = p:GetPositionOffsets()

		if nil ~= p.VelocityY and ( ( nil ~= p.Expires and ft < p.Expires ) or ( nil == p.Expires and ( x >= minX and x <= maxX and y >= minY and y <= maxY and z >= minZ and z <= maxZ ) ) ) then
			x, y, z = x + p.DriftX, y + p.VelocityY, z + p.DriftZ
			p:SetPositionOffsets( x, y, z )
			p:SetOrientationOffsets( 0, CameraHeading, 0 )
		elseif nil == p.Expires or self.RecycleExpired then
			p.VelocityY = -self.MinSpeed - ( self.MaxSpeedOffset * math.random() )
			if 1 > p.VelocityY and -1 < p.VelocityY then p.VelocityY = ( 0 < self.MinSpeed ) and 1 or -1 end

			if 0 == self.Direction then
				x, y, z = 0, 0.5 * ( minY + maxY ), 0
			else
				x, y, z = xOffset + math.random() * width, ( 1 == self.Direction ) and maxY or minY, zOffset + math.random() * width
			end

			p:SetPositionOffsets( x, y, z )
			p.DriftX, p.DriftZ = self.MinDriftX + self.MaxDriftOffsetX * math.random(), self.MinDriftZ + self.MaxDriftOffsetZ * math.random()

			if 0 < self.MinTTL then
				p.Expires = ft + self.MinTTL + self.MaxTTLOffset * math.random()
			else
				p.Expires = nil
			end
		elseif -1 ~= p.Expires then
			p.Expires = -1
			p:SetAlpha( 0 )
		end
	end
end

function EHT.EffectAnimation:CreateParticleGenerator( minSpeed, maxSpeed, minDriftX, maxDriftX, minDriftZ, maxDriftZ, randomizeDriftDirection, minTTL, maxTTL, recycleExpired, minRotationInterval, maxRotationInterval )
	local animation = EHT.EffectAnimation:New( ParticleAnimation )
	local maxSpeedOffset = maxSpeed - minSpeed
	local maxDriftOffsetX = maxDriftX - minDriftX
	local maxDriftOffsetZ = maxDriftZ - minDriftZ

	if nil == randomizeDriftDirection then randomizeDriftDirection = true end

	minRotationInterval, maxRotationInterval = minRotationInterval or 2000, maxRotationInterval or 3000
	local maxRotationIntervalOffset = maxRotationInterval - minRotationInterval

	minTTL, maxTTL = minTTL or 0, maxTTL or 0
	local maxTTLOffset = maxTTL - minTTL

	if nil == recycleExpired then recycleExpired = true end

	animation.MinSpeed = minSpeed
	animation.MaxSpeedOffset = maxSpeedOffset
	animation.MinDriftX = minDriftX
	animation.MaxDriftOffsetX = maxDriftOffsetX
	animation.MinDriftZ = minDriftZ
	animation.MaxDriftOffsetZ = maxDriftOffsetZ
	animation.MinRotationInterval = minRotationInterval
	animation.MaxRotationIntervalOffset = maxRotationIntervalOffset
	animation.RandomizeDriftDirection = randomizeDriftDirection
	animation.MinTTL = minTTL
	animation.MaxTTLOffset = maxTTLOffset
	animation.RecycleExpired = recycleExpired

	if 0 > minSpeed and 0 < maxSpeed then
		animation.Direction = 0		-- Omnidirectional
	elseif 0 < minSpeed then
		animation.Direction = 1		-- Downward
	else
		animation.Direction = 2		-- Upward
	end

	return animation
end

---[ Effect Type ]---

EHT.EffectType.MAX_NEW_AGE_HOURS = 24 * 30

do
	local ops = { }
	EHT.EffectType.COMPARISON = ops

	ops.NOT_EQUAL = function( v1, v2 ) return v1 ~= v2 end
	ops.EQUAL = function( v1, v2 ) return v1 == v2 end
	ops.LESS = function( v1, v2 ) return v1 < v2 end
	ops.GREATER = function( v1, v2 ) return v1 > v2 end
	ops.EQUAL_OR_LESS = function( v1, v2 ) return v1 <= v2 end
	ops.EQUAL_OR_GREATER = function( v1, v2 ) return v1 >= v2 end
end

function EHT.EffectType:GetFilteredList( attribute, value, comparison )
	local list = { }
	local et
	if nil == comparison then comparison = self.COMPARISON.EQUAL end

	for index, et in pairs( EffectTypeList ) do
		if et and comparison( value, et[ attribute ] ) then
			table.insert( list, et )
		end
	end

	return list
end

function EHT.EffectType:GetFilteredEnabledList( ... )
	local list = self:GetFilteredList( ... )

	for index = #list, 1, -1 do
		if not list[ index ].Enabled then
			table.remove( list, index )
		end
	end

	return list
end

function EHT.EffectType:GetAll()
	return EffectTypeList
end

function EHT.EffectType:GetEnabled()
	if not self.EnabledEffectTypeList then
		self.EnabledEffectTypeList = self:GetFilteredList( "Enabled", false, self.COMPARISON.NOT_EQUAL )
	end

	return self.EnabledEffectTypeList
end

function EHT.EffectType:GetByIndex( index )
	return EffectTypeList[index]
end

function EHT.EffectType:GetByName( name )
	return EffectTypeByNameList[ string.lower( name ) ]
end

function EHT.EffectType:New( ... )
	local obj = ZO_Object.New( self )
	obj:Initialize( ... )
	return obj
end

local function EffectTypeFailure( name, msg )
	return string.format( "Effect Type \"%s\" failed to initialize: %s", name or "(nil)", msg or "" )
end

function EHT.EffectType:Initialize( index, name, ... )
	if not Assert( "number" == type( index ), EffectTypeFailure( name, "Index must be numeric." ) ) then return end
	if not Assert( nil ~= name and "" ~= name, EffectTypeFailure( name, "Name is required." ) ) then return end
	if not Assert( nil == EffectTypeList[ index ], EffectTypeFailure( name, string.format( "Index %s already exists.", tostring( index or "(nil)" ) ) ) ) then return end

	self.Index = index
	self.Name = name

	for key, value in pairs( ... ) do
		self[ key ] = value
	end

	if nil == self.Active then self.Active = true end
	if nil == self.CanPitch then self.CanPitch = nil == self.Update end
	if nil == self.Enabled then self.Enabled = true ~= self.Temporary end
	if nil == self.Environmental then self.Environmental = false end
	if nil == self.Global then self.Global = false end
	if nil == self.Overlay then self.Overlay = false end
	if nil == self.ResetOnPosition then self.ResetOnPosition = false end
	if nil == self.ResetOnOrient then self.ResetOnOrient = false end
	if nil == self.ResetOnScale then self.ResetOnScale = false end
	if nil == self.ResetOnColor then self.ResetOnColor = false end
	if nil == self.DateAdded then self.DateAdded = EHT.EffectType.DefaultDateAdded end
	if "table" ~= type( self.MinSize ) then self.MinSize = { 1, 1, 1 } end

	if self.MetaParams then
		if not Assert( "table" == type( self.MetaParams ), EffectTypeFailure( name, "Meta Parameter list is not of type 'table'." ) ) then return end
		for index, p in ipairs( self.MetaParams ) do
			if not Assert( "string" == type( p.Name ) and "" ~= p.Name, EffectTypeFailure( name, string.format( "Invalid or missing Name for Meta Parameter #%d", index ) ) ) then return end
			if not Assert( "function" == type( p.Deserializer ), EffectTypeFailure( name, string.format( "Invalid or missing Deserializer function for Meta Parameter #%d", index ) ) ) then return end
			if not Assert( "function" == type( p.Serializer ), EffectTypeFailure( name, string.format( "Invalid or missing Serializer function for Meta Parameter #%d", index ) ) ) then return end
		end
	end

	EffectTypeList[ index ] = self
	EffectTypeByNameList[ string.lower( self.Name ) ] = self
end

function EHT.EffectType:GetIndex()
	return self.Index
end

function EHT.EffectType:GetName()
	return self.Name
end

function EHT.EffectType:AdjustRequestedSize( x, y, z )
	if self.MinSize then
		x, y, z = math.max( x, self.MinSize[1] ), math.max( y, self.MinSize[2] ), math.max( z, self.MinSize[3] )
	end

	if self.MaxSize then
		x, y, z = math.min( x, self.MaxSize[1] ), math.min( y, self.MaxSize[2] ), math.min( z, self.MaxSize[3] )
	end

	return x, y, z
end

function EHT.EffectType:SetDefaultDateAdded( timestamp )
	EHT.EffectType.DefaultDateAdded = timestamp
end

function EHT.EffectType:UsesGlobalTray()
	return self.Global
end

function EHT.EffectType:IsReserved()
	return true == self.Reserved
end

function EHT.EffectType:IsActionable()
	return self.Category ~= CAT.ACTION
end

function EHT.EffectType:UsesPreview()
	return false ~= self.AutoPreview
end

function EHT.EffectType:UsesSetSizeV2()
	return self.Index >= V2_SET_SIZE_MIN_INDEX and self.Index <= V2_SET_SIZE_MAX_INDEX
end

function EHT.EffectType:NewAge() -- teehee
	if not self.DateAdded then return 0 end

	local used = EHT.SavedVars.UsedEffectTypes
	if not used then
		used = { }
		EHT.SavedVars.UsedEffectTypes = used
	end
	if used[self.Index] then return 0 end

	local ageHours = ( GetTimeStamp() - self.DateAdded ) / 3600
	return ( EHT.EffectType.MAX_NEW_AGE_HOURS - ageHours ) / EHT.EffectType.MAX_NEW_AGE_HOURS
end

function EHT.EffectType:GetMetaParams()
	return self.MetaParams
end

function EHT.EffectType:GetMetaParamByName( paramName )
	local params = self:GetMetaParams()
	if not params then return nil end

	paramName = string.lower( paramName )

	for index, p in ipairs( params ) do
		if string.lower( p.Name ) == paramName then
			return p, index
		end
	end

	return nil
end

local function AddFurnitureIndicatorsToActionEffect( effectType, metaParamNames )
	local function OnUpdate( self )
		if self == CurrentEditorEffect then
			if not self.IndicatorsVisible then
				self.IndicatorsVisible = true
				EHT.Pointers.ClearIndicators()

				for _, paramName in ipairs( metaParamNames ) do
					local furnitureId = self:GetMetaData( paramName )
					if furnitureId then
						local x, y, z = EHT.Housing.GetFurnitureCenter( furnitureId )
						if x and 0 ~= x then
							EHT.Pointers.SetIndicator( x, y, z )
						end
					end
				end
			end
		else
			if self.IndicatorsVisible then
				self.IndicatorsVisible = false
				EHT.Pointers.ClearIndicators()
			end
		end
	end

	local oldUpdate = effectType.Update
	effectType.Update = function( self )
		if oldUpdate then oldUpdate( self ) end
		OnUpdate( self )
	end

	local oldReset = effectType.Reset
	effectType.Reset = function( self )
		if oldReset then oldReset( self ) end
		if self.IndicatorsVisible then
			self.IndicatorsVisible = false
			EHT.Pointers.ClearIndicators()
		end
		OnUpdate( self )
	end
	
	local oldDestroy = effectType.Destroy
	effectType.Destroy = function( self )
		if self.IndicatorsVisible then
			self.IndicatorsVisible = false
			EHT.Pointers.ClearIndicators()
		end
		if oldDestroy then oldDestroy( self ) end
	end
end

local function AddModifierInit( effectType, func )
	local init = effectType.Init
	effectType.Init = function( self )
		local result
		if init then result = init( self ) end
		func( self )
		return result
	end
	return effectType
end

local function AddModifierFaded( effectType, strength )
	strength = ( strength or 1 )
	local cSample = zo_clamp( 1 - 0.2 * strength, 0.1, 1 )
	local cDesat = zo_clamp( 0.5 * strength, 0, 0.9 )

	return AddModifierInit( effectType, function( self )
		for _, p in ipairs( self.Particles ) do
			local rgb, alpha = p:GetSampleProcessing()
			p:SetSampleProcessing( rgb * cSample, alpha * cSample )
			local desat = p:GetDesaturation()
			p:SetDesaturation( desat + cDesat )
		end
	end )
end

local function AddModifierBright( effectType, strength )
	strength = ( strength or 1 )
	local cSample = zo_clamp( 1 + 0.15 * strength, 0.1, 20 )

	return AddModifierInit( effectType, function( self )
		for _, p in ipairs( self.Particles ) do
			local rgb, alpha = p:GetSampleProcessing()
			p:SetSampleProcessing( rgb * cSample, alpha * cSample )
		end
	end )
end

local function AddModifierFlipVertical( effectType )
	return AddModifierInit( effectType, function( self )
		local pitch = self:GetOrientation()
		self:SetOrientation( ( pitch or 0 ) + math.pi )
	end )
end

local function AddParticleGeneratorEffect( effectIndex, effectName, textureFile, initHandler, updateHandler, effectArea, effectHeight, colorR, colorG, colorB, alpha, density, size, minSpeed, maxSpeed, minDriftX, maxDriftX, minDriftZ, maxDriftZ, minTTL, maxTTL, recycleExpired, randomizeDriftDirection, minRotationInterval, maxRotationInterval )
	if nil == textureFile then textureFile = TEXTURES.CIRCLE_SOFT end

	local effectType = EHT.EffectType:New( effectIndex, effectName, {
		Category = CAT.ANIM,

		Init = function( self )
			local width, height = effectArea, effectHeight
			self:SetColor( colorR, colorG, colorB, alpha )
			self:SetSize( width, height, width )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 0.5 * effectHeight )
			self:SetAutoSizeEnabled( false )
			self.Animation = EHT.EffectAnimation:CreateParticleGenerator( minSpeed, maxSpeed, minDriftX, maxDriftX, minDriftZ, maxDriftZ, randomizeDriftDirection, minTTL, maxTTL, recycleExpired, minRotationInterval, maxRotationInterval )
		end,

		Update = function( self )
			if updateHandler then
				if not updateHandler( self ) then
					self.Animation:Animate( self )
					self:Update()
				end
			else
				self.Animation:Animate( self )
				self:Update()
			end
		end,

		Reset = function( self )
			local width, height = self:GetSize()
			local maxParticles = round( zo_clamp( width / density, 5, 1000 ) )
			local p

			self:DeleteParticles()

			for index = 1, maxParticles do
				p = self:AddParticle(
					textureFile,
					0, 0, 0,
					0, 0, 0,
					1, 1, 1, 0.5 + 0.5 * ( ( 1 + ( index % 10 ) ) / 10 ),
					1, 1,
					true, true )
				-- p:SetSampleProcessing( 1, 0.2 * math.random() )
				p:SetSize( size, size )
			end

			self:RandomlyDistributeParticles()
			if initHandler then initHandler( self ) end

			self:Update()
		end,

	} )

	return effectType

end


local function AddWaterRipplesToEffect( effectType, maxAlpha, rippleR, rippleG, rippleB )
	--local SPLASH_TEXTURES = { TEXTURES.SPLASH_2, TEXTURES.SPLASH_3, TEXTURES.SPLASH_4, }
	local MAX_RIPPLE_ALPHA = 1 -- maxAlpha or 0.5
	local MAX_RIPPLES = 5
	local MIN_RIPPLE_INTERVAL = 250
	local MIN_RIPPLE_DISTANCE = 100
	local RIPPLE_DURATION = 2000
	local RIPPLE_SIZE = 750
	local MIN_RIPPLE_LEN = MIN_RIPPLE_DISTANCE + RIPPLE_SIZE
	local originalReset, originalUpdate = effectType.Reset, effectType.Update
	local rgbSampling = 2 -- nil == string.find( "coldharbour", string.lower( effectType.Name ) ) and 1.5 or 1
	rippleR, rippleG, rippleB = rippleR or 1, rippleG or 1, rippleB or 1

	effectType.Reset = function( self )
		if originalReset then originalReset( self ) end
		self.OrderDrawLevelByIndex = true
		self.LenX, self.LenY, self.LenZ, self.MaxLen = nil, nil, nil, nil
		self.LastInX, self.LastInY, self.LastInZ, self.LastInTS = 0, 0, 0, 0
		self.RippleParticles = self.RippleParticles or { }
		self.RipplesEnabled = false

		local lenX, lenY, lenZ = self:GetSize()
		if not lenX then return end
		lenX, lenY, lenZ = 0.5 * lenX, 0.5 * lenY, 0.5 * lenZ

		local maxWidth = math.max( lenX, lenY, lenZ )
		local maxLength = math.max( maxWidth ~= lenX and lenX or 0, maxWidth ~= lenY and lenY or 0, maxWidth ~= lenZ and lenZ or 0 )
		if 0 == maxLength then maxLength = maxWidth end
		local maxDistance = zo_distance3D( 0, 0, 0, maxWidth, 0, maxLength )
		if maxDistance < MIN_RIPPLE_LEN then return end

		--local numSplashParticles = #SPLASH_TEXTURES
		self.LenX, self.LenY, self.LenZ, self.MaxDistance = lenX, lenY, lenZ, maxDistance
		if #self.RippleParticles < MAX_RIPPLES then
			self.NextRippleIndex = 1
		end
		while #self.RippleParticles < MAX_RIPPLES do
			--local textureFile = SPLASH_TEXTURES[ 1 + ( #self.RippleParticles % numSplashParticles ) ]
			local ripple = self:AddParticle( TEXTURES.SPLASH_3,		0, 0, 0,	0, 0, 0,	1, 1, 1, 0,		0, 0,	true, false, false )
			ripple:SetHidden( true )
			table.insert( self.RippleParticles, ripple )
			ripple.RippleIndex = #self.RippleParticles
			ripple.Expires = 0
			ripple:SetAutoSizeEnabled( false )
			ripple:SetColorOffsets( rippleR, rippleG, rippleB, 0 )
			ripple:SetOrientationOffsets( 0.5 * math.pi, 0, 0 )
			ripple:SetPositionOffsets( nil, 3 * ripple.RippleIndex, nil )
			ripple:SetSampleProcessing( rgbSampling )
			ripple:SetSize( RIPPLE_SIZE, RIPPLE_SIZE )
		end
		self.RipplesEnabled = true
	end

	effectType.Update = function( self )
		if originalUpdate then originalUpdate( self ) end
		if not self.RipplesEnabled then return end

		local lenX, lenY, lenZ, maxDistance = self.LenX, self.LenY, self.LenZ, self.MaxDistance
		local x, y, z, pitch, yaw, roll = self:GetPositionAndOrientation()
		local ft = FrameTime

		for index = #self.RippleParticles, 1, -1 do
			local ripple = self.RippleParticles[index]
			if ripple then
				if ft < ripple.Expires then
					local progress = EaseIn4((ripple.Expires - ft) / RIPPLE_DURATION)
					local scale = zo_lerp(ripple.EndScale, ripple.StartScale, progress)
					ripple:SetColorOffsets(nil, nil, nil, progress)
					ZO_ScaleAndRotateTextureCoords(ripple.Texture, ripple.SplashAngle, 0.5, 0.5, scale, scale)
					ripple:SetHidden( false )
				elseif ripple.Expires ~= 0 then
					ripple:SetHidden( true )
					ripple.Expires = 0
				end
			end
		end

		local effectDistance = zo_distance3D( x, y, z, PlayerX, PlayerY, PlayerZ )

		if effectDistance <= maxDistance then
			local rippleDistance = zo_distance3D( self.LastInX, self.LastInY, self.LastInZ, PlayerX, PlayerY, PlayerZ )

			if MIN_RIPPLE_DISTANCE <= rippleDistance then
				if ( ft - self.LastInTS ) >= MIN_RIPPLE_INTERVAL then
					local playerDistance = zo_distance3D( PlayerX, PlayerY, PlayerZ, x, y, z )
					local inX, inY, inZ
					local addRipple

					if playerDistance <= maxDistance then
						inX, inY, inZ = EHT.World.Rotate( PlayerX - x, PlayerY - y, PlayerZ - z, -pitch, -yaw, -roll )
						addRipple = inX >= -lenX and inX <= lenX and inZ >= -lenZ and inZ <= lenZ and inY > -100 and inY <= 100
					end

					if addRipple then
						local ripple = self.RippleParticles[self.NextRippleIndex]
						self.NextRippleIndex = 1 + ( self.NextRippleIndex % #self.RippleParticles )

						ripple:SetHidden(true)
						ripple:SetDodge(true)
						ripple:SetColorOffsets(nil, nil, nil, 0)
						ripple:SetPositionOffsets(inX, nil, inZ)
						ripple.StartScale, ripple.EndScale = 0.1, 1
						_, _, _, ripple.SplashAngle = GetPlayerWorldPositionInHouse()
						ZO_ScaleAndRotateTextureCoords(ripple.Texture, ripple.SplashAngle, 0.5, 0.5, ripple.StartScale, ripple.StartScale)
						ripple.Expires = ft + RIPPLE_DURATION

						self.LastInX, self.LastInY, self.LastInZ, self.LastInTS = PlayerX, PlayerY, PlayerZ, ft
					end
				end
			end
		else
			self.LastInX, self.LastInY, self.LastInZ = 0, 0, 0
		end

		self:Update()
	end

	return effectType
end

local function GetValueOrPercentage( value, relatedValue )
	if 1 >= value and -1 <= value then
		return value * relatedValue
	else
		return value
	end
end

local function AddRandomizedParticleEffect(
	id, name, category, textureFile,
	defaultX, defaultY, defaultZ,
	defaultR, defaultG, defaultB, defaultA,
	emissionOffsetX, emissionOffsetY, emissionOffsetZ,
	emissionRadiusX, emissionRadiusY, emissionRadiusZ,
	maxOffsetX, maxOffsetY, maxOffsetZ,
	particlesPerMeterSq, minParticles, maxParticles,
	localized,
	minTTL, maxTTL,
	minSize, maxSize, minGrowth, maxGrowth,
	minRGB, maxRGB,
	minR, minG, minB, minA,
	maxR, maxG, maxB, maxA,
	colorShift, alphaShift,
	minRotation, maxRotation, minAngVelocity, maxAngVelocity,
	minVecX, minVecY, minVecZ,
	maxVecX, maxVecY, maxVecZ,
	windFactor, autoOrientation, useTextureUV,
	emissionPattern, vectorPattern, emissionInterval,
	useCellAnimation, cellsStatic, cellsFPS, cellsX, cellsY,
	invertVectorX, invertVectorY, invertVectorZ, uniformVectors,
	bezierAxisY, inferGradient,
	onInit, onUpdate, onReset
)
	defaultX, defaultY, defaultZ = defaultX or 1200, defaultY or 1200, defaultZ or 1200
	defaultR, defaultG, defaultB, defaultA = defaultR or 1, defaultG or 1, defaultB or 1, defaultA or 1
	minTTL, maxTTL = minTTL or 10000, maxTTL or 10000
	emissionOffsetX, emissionOffsetY, emissionOffsetZ = emissionOffsetX or 0, emissionOffsetY or 0, emissionOffsetZ or 0
	emissionRadiusX, emissionRadiusY, emissionRadiusZ = emissionRadiusX or 0, emissionRadiusY or 0, emissionRadiusZ or 0
	particlesPerMeterSq, minParticles, maxParticles = particlesPerMeterSq or 0.1, minParticles or 10, maxParticles or 100
	minSize, maxSize, minGrowth, maxGrowth = minSize or 5, maxSize or 10, minGrowth or 0, maxGrowth or 0
	minRGB, maxRGB = minRGB or 1, maxRGB or 1
	minR, minG, minB, minA = minR or 1, minG or 1, minB or 1, minA or 1
	maxR, maxG, maxB, maxA = maxR or 1, maxG or 1, maxB or 1, maxA or 1
	colorShift, alphaShift = colorShift or 0, alphaShift or 0
	minRotation, maxRotation, minAngVelocity, maxAngVelocity = minRotation or 0, maxRotation or 0, minAngVelocity, maxAngVelocity
	minVecX, minVecY, minVecZ = minVecX or 0, minVecY or 0, minVecZ or 0
	maxVecX, maxVecY, maxVecZ = maxVecX or 0, maxVecY or 0, maxVecZ or 0
	windFactor = windFactor or 0
	autoOrientation = autoOrientation or EHT.ParticleEmitter.ORIENTATIONS.CAMERA
	useTextureUV = true == useTextureUV
	emissionPattern, vectorPattern = emissionPattern or EHT.ParticleEmitter.PATTERNS.RANDOM, vectorPattern or EHT.ParticleEmitter.PATTERNS.RANDOM

	return EHT.EffectType:New( id, name, {
		Category = category,
		Init = function( self )
			self:SetSize( defaultX, defaultY, defaultZ )
			self:SetColor( defaultR, defaultG, defaultB, defaultA )
			self:SpawnAtPlayer( 0.5 * defaultY )

			if onInit then onInit( self ) end
		end,
		Update = function( self )
			if not onUpdate or not onUpdate( self, self.Emitter ) then
				if self.Emitter then self.Emitter:Update() end
			end
		end,
		Reset = function( self )
			local x, y, z = self:GetPosition()
			local pitch, yaw, roll = self:GetOrientation()
			local r1, g1, b1, a1 = self:GetColor()
			local r2, g2, b2, a2 = self:GetColor()
			local sx, sy, sz = self:GetSize()
			local ttl = maxTTL

			if inferGradient then
				if r1 > g1 and r1 > b1 then
					g1, b1 = 0, 0
				elseif g1 > r1 and g1 > b1 then
					r1, b1 = 0, 0
				else
					r1, g1 = 0, 0
				end
			end

			local o = { }
			o.Texture = textureFile
			o.AutoOrientation, o.Yaw = autoOrientation, yaw
			o.EmissionX, o.EmissionY, o.EmissionZ = x + emissionOffsetX * sx, y + emissionOffsetY * sy, z + emissionOffsetZ * sz
			o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = emissionRadiusX * sx, emissionRadiusY * sy, emissionRadiusZ * sz
			o.ReuseActiveEmissions, o.MaxActiveEmissions = false, zo_clamp( particlesPerMeterSq * math.sqrt( sx * sy ), minParticles, maxParticles )
			o.MinActiveEmissions = 0.75 * o.MaxActiveEmissions
			o.Localized = localized
			o.EmissionFrequency = maxTTL / o.MaxActiveEmissions
			o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = emissionPattern, emissionInterval or 0, FrameTime
			if maxOffsetX then o.MaxOffsetX = maxOffsetX * sx end
			if maxOffsetY then o.MaxOffsetY = maxOffsetY * sy end
			if maxOffsetZ then o.MaxOffsetZ = maxOffsetZ * sz end
			o.WindFactor = windFactor
			o.MinSize = GetValueOrPercentage( minSize, sx )
			o.MaxSize = GetValueOrPercentage( maxSize, sx )
			o.MinGrowth = GetValueOrPercentage( minGrowth, sx )
			o.MaxGrowth = GetValueOrPercentage( maxGrowth, sx )
			o.MinTTL, o.MaxTTL = minTTL, maxTTL
			o.MinSampleRGB, o.MaxSampleRGB = minRGB, maxRGB
			o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = minR * r1, minG * g1, minB * b1, minA * a1
			o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = maxR * r2, maxG * g2, maxB * b2, maxA * a2
			o.ColorShift, o.AlphaShift = colorShift, alphaShift
			o.MinRotation, o.MaxRotation, o.MinAngularVelocity, o.MaxAngularVelocity = minRotation, maxRotation, minAngVelocity, maxAngVelocity
			o.VectorPattern = vectorPattern
			o.MinVectorX = GetValueOrPercentage( minVecX, sx )
			o.MinVectorY = GetValueOrPercentage( minVecY, sy )
			o.MinVectorZ = GetValueOrPercentage( minVecZ, sx )
			o.MaxVectorX = GetValueOrPercentage( maxVecX, sx )
			o.MaxVectorY = GetValueOrPercentage( maxVecY, sy )
			o.MaxVectorZ = GetValueOrPercentage( maxVecZ, sx )
			o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = invertVectorX, invertVectorY, invertVectorZ, uniformVectors
			o.UseCellAnimation, o.CellsStatic, o.CellsFPS, o.CellsX, o.CellsY = false, false, nil, 0, 0
			o.LockAtRange, o.RecycleAtRange = false, true
			o.UseTextureUVAnimation = useTextureUV
			o.UseCellAnimation = useCellAnimation
			o.CellsStatic = cellsStatic
			o.CellsFPS = cellsFPS
			o.CellsX = cellsX
			o.CellsY = cellsY
			o.BezierAxisY = bezierAxisY

			if 0 == o.MinVectorZ and 0 == o.MaxVectorZ then
				local angle = yaw + 0.5 * math.pi
				o.MinVectorZ, o.MaxVectorZ = o.MinVectorX * math.cos( angle ), o.MaxVectorX * math.cos( angle )
				o.MinVectorX, o.MaxVectorX = o.MinVectorX * math.sin( angle ), o.MaxVectorX * math.sin( angle )
			end

			if not self.Emitter then
				self.Emitter = EHT.ParticleEmitter:New( self, o )
			else
				self.Emitter:Initialize( o )
			end

			self.Emitter:Update()
			if onReset then onReset( self, self.Emitter ) end
		end,
	} )
end

local function CreateParticleEmitter( id, name, options )
	options.minAbsoluteVelocityY = math.min( math.abs( options.minVelocityY ), math.abs( options.maxVelocityY ) )
	options.minEmissions = options.minEmissions or 1
	options.maxEmissions = options.maxEmissions or 8

	return EHT.EffectType:New( id, name, {
		Category = options.category or CAT.ANIM,
		MinSize = { 50, 50, 50 },
		ResetOnColor = true,
		ResetOnScale = true,
		OrderDrawLevelByIndex = options.orderDrawLevelByIndex ~= false,

		Init = function( self )
			self.options = options
			self:SetSize( options.sizeX, options.sizeY, options.sizeY )
			self:SetColor( unpack( options.defaultColor or { 0.5, 0.7, 1, 1 } ) )
			self:SpawnAtPlayer( options.spawnY or ( 50 + options.sizeY * 0.5 ) )
		end,

		Update = function( self )
			if self.Emitter then
				if options.updateFunction then
					options.updateFunction( self, self.Emitter )
				end
				self.Emitter:Update()
			end
		end,

		Reset = function( self )
			self:Update()

			local x, y, z = self:GetPosition()
			local pitch, yaw, roll = self:GetOrientation()
			local r, g, b, a = self:GetColor()
			local originalSizeX, originalSizeY, originalSizeZ = self:GetSize()
			local sx, sy, sz = originalSizeX, originalSizeY, originalSizeZ
			local maxDim = math.max( sx, sy, sz )
			local emissionInterval = options.emissionInterval
			local ttl

			if options.spherical then
				sy, sz = sx, sx
				self:SetSize( sx, sy, sz )
				emissionInterval = math.max( 2000, options.minAbsoluteVelocityY * EHT.World:GetCircumference( sx, sx, RAD360 ) )

				if not options.maxTtl then
					ttl = emissionInterval
				end
			end

			local o = { }
			o.Texture = options.texture or TEXTURES.CIRCLE_DEPTH
			o.AutoOrientation = false ~= options.cameraFacing and EHT.ParticleEmitter.ORIENTATIONS.CAMERA or EHT.ParticleEmitter.ORIENTATIONS.MANUAL
			o.Yaw = yaw

			o.MaxOffsetX, o.MaxOffsetY, o.MaxOffsetZ = sx, sy, sx
			o.EmissionX, o.EmissionZ = x, z
			o.EmissionY = y + ( options.emissionRadiusY and 0 or ( 0.49 * sy * ( options.maxVelocityY < 0 and 1 or -1 ) ) )
			if not options.emissionRadiusX or options.emissionRadiusX <= 1 then
				o.MaxEmissionRadiusX, o.MaxEmissionRadiusZ = ( options.emissionRadiusX or 0.4 ) * sx, ( options.emissionRadiusX or 0.4 ) * sx
			else
				o.MaxEmissionRadiusX, o.MaxEmissionRadiusZ = options.emissionRadiusX, options.emissionRadiusX
			end
			o.MaxEmissionRadiusY = ( options.emissionRadiusY or 0 ) * sy
			o.ReuseActiveEmissions = false
			o.MinActiveEmissions = options.minEmissions
			o.MaxActiveEmissions = options.maxEmissions

			o.EmissionPattern = options.emissionPattern or EHT.ParticleEmitter.PATTERNS.RANDOM
			o.EmissionInterval = emissionInterval
			o.EmissionIntervalOffset = options.emissionOffset or 0

			if options.sizeByAreaPercentage then
				local standardSize = options.sizeByAreaPercentage * 0.5 * ( sx + sy )
				local variance = options.sizeByAreaVariance or 0.1
				o.MinSize = math.max( options.minSizeX or 5, standardSize - ( standardSize * variance ) )
				o.MaxSize = math.min( options.maxSizeX or 100, standardSize + ( standardSize * variance ) )
			elseif options.maxSizeX or options.minSizeX then
				o.MaxSize = options.maxSizeX
				o.MinSize = options.minSizeX
			else
				o.MaxSize = zo_clamp( math.sqrt( math.sqrt( math.max( sx, sy ) ) ), options.minSize or 5, options.maxSize or 100 )
				o.MinSize = ( options.minSizePercent or 0.5 ) * o.MaxSize
			end
			if options.maxSizeY or options.minSizeY then
				o.MaxSizeY = options.maxSizeY
				o.MinSizeY = options.minSizeY
			end
			o.MinGrowth = ( options.minGrowth or 0 ) * o.MaxSize
			o.MaxGrowth = ( options.maxGrowth or 0 ) * o.MaxSize

			local colorOffset = options.colorOffset or 0.08
			o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r - colorOffset, g - colorOffset, b - colorOffset, 0
			o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r + colorOffset, g + colorOffset, b + colorOffset, 0
			o.AlphaShift = 0
			o.ColorShift = -0.2
			o.MinSampleRGB = 0.8
			o.MaxSampleRGB = 1.2

			o.VectorPattern = options.vectorPattern
			o.VectorAngleFunction = options.vectorAngleFunction
			o.VectorRadiusFunction = options.VectorRadiusFunction
			if options.velocityFunction then
				o.VelocityFunction = options.velocityFunction
			else
				local minVelocityY = options.minVelocityY or 0
				local maxVelocityY = options.maxVelocityY or 0
				if minVelocityY >= -1 and minVelocityY <= 1 then
					minVelocityY = self.SizeY * minVelocityY
				end
				if maxVelocityY >= -1 and maxVelocityY <= 1 then
					maxVelocityY = self.SizeY * maxVelocityY
				end
				minVelocityY = zo_clamp( minVelocityY, -2000, 2000 )
				maxVelocityY = zo_clamp( maxVelocityY, -2000, 2000 )
				
				o.MinVectorX, o.MinVectorY, o.MinVectorZ = 0, minVelocityY, 0
				o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 0, maxVelocityY, 0
				o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = false, false, false, false
			end

			local emissionFrequency = options.emissionFrequency
			if not ttl then
				if false == options.autoAdjustTtl or o.VelocityFunction then
					if options.maxTtl then
						ttl = math.random( options.minTtl or ( options.maxTtl - 1 ), options.maxTtl )
					else
						ttl = 1000 * sy / options.minAbsoluteVelocityY
					end
				else
					ttl = ( self.SizeY / math.abs( o.MaxVectorY ) ) * 1000
					if options.minTtl then
						ttl = math.max( options.minTtl, ttl )
					end
					if options.maxTtl and emissionFrequency then
						local ratio = ttl / options.maxTtl
						emissionFrequency = emissionFrequency * ratio
					end
				end
			end
			o.MinTTL = ttl
			o.MaxTTL = ttl

			o.EmissionFrequency = emissionFrequency or math.min( 1000, ttl / options.maxEmissions )
			o.WindFactor = 0
			o.UseCellAnimation, o.CellsStatic, o.CellsFPS, o.CellsX, o.CellsY = false, false, nil, nil, nil
			o.LockAtRange, o.RecycleAtRange = false, options.recycleAtRange or options.recycleAtRange == nil

			o.AlphaFunction = options.alphaFunction or CreateEasingFunction( 1, 0, 1 )
			o.GrowthFunction = options.growthFunction or CreateRandomizedEasingMultiplierFunction( options.pulseInterval, options.minGrowth or 0.75, options.maxGrowth or 1 )
			o.SampleFunction = options.sampleFunction or CreateRandomizedEasingMultiplierFunction( options.pulseInterval, 2, 8 )
			o.SphericalInterval = options.sphericalInterval
			o.SphericalOffsetFunction = options.sphericalOffsetFunction
			o.UVFunction = options.uvFunction
			o.UVCoordsFunction = options.uvCoordsFunction
			o.VertexColorFunction = options.vertexColorFunction

			if not self.Emitter then
				self.Emitter = EHT.ParticleEmitter:New( self, o )
			else
				self.Emitter:Initialize( o )
			end
			
			if options.resetFunction then
				options.resetFunction( self, self.Emitter )
			end

			if false ~= options.respawnOnResize then
				local forceExpiration = originalSizeX ~= self.SizeX or originalSizeY ~= self.SizeY or originalSizeZ ~= self.SizeZ
				if forceExpiration then
					local baseMaxExpiration = FrameTime + 3000
					local numP = #self.Particles
					for index, p in ipairs( self.Particles ) do
						local maxExpiration = baseMaxExpiration + ( index / numP ) * 6000
						if p.TTLExpiration then
							p.TTLExpiration = math.min( p.TTLExpiration, maxExpiration )
						end
						if p.BaseTime and p.TTLDuration then
							p.TTLDuration = math.min( p.TTLDuration, maxExpiration - p.BaseTime )
						end
					end
				end
			end
		end,
	} )
end

local function ProjectCylinderTextureFaces( faces, radius, x1, x2, y1, y2, xOverscan, translateX )
	x1, x2, y1, y2 = x1 or 0, x2 or 1, y1 or 0, y2 or 1

	local numFaces = #faces
	local rangeX, rangeY = x2 - x1, y2 - y1
	local o = 0.5 * ( xOverscan or 0 )

	if translateX then
		translateX = rangeX * translateX
	end

	for faceIndex = 0, numFaces - 1 do
		local p = faces[ faceIndex + 1 ]
		local deltaX1 = rangeX * ( faceIndex / numFaces )
		local deltaX2 = rangeX * ( ( faceIndex + 1 ) / numFaces )

		if translateX then
			deltaX1, deltaX2 = ( deltaX1 + translateX ) % rangeX, ( deltaX2 + translateX ) % rangeX
		end

		local pX1, pX2 = deltaX1, deltaX2

		if translateX then
			if pX2 < pX1 then
				pX2 = rangeX + pX2
				--p:SetTextureWrapping( true )
			else
				--p:SetTextureWrapping( false )
			end
		end

		pX1, pX2 = -o + x1 + pX1, o + x1 + pX2
		p.ProjectionX1, p.ProjectionX2 = pX1, pX2
		p:SetTextureCoords( pX1, pX2, y1, y1 + rangeY )
	end
end

local function ApplySkyboxPresets( self, skipIfEditable )
	if skipIfEditable then
		return
	end

	local houseId = EHT.Housing.GetHouseId()
	local data = SKY_BOX_PRESETS[ string.format( "%d@%d", houseId, self.EffectType.Index ) ]
	if not data then
		data = SKY_BOX_PRESETS[ string.format( "%d", houseId ) ]
	end

	if data then
		self:SetPosition( data.X, data.Y, data.Z )
		self:SetOrientation( data.Pitch, data.Yaw, data.Roll )
		self:SetSize( data.SizeX, data.SizeY, data.SizeZ )
	else
		self:SpawnAtPlayer( -8000, false )
	end
end

local function AddSkyEffect( index, name, options, sideTextures, topTexture, resetHandler, updateHandler )
	local NUM_STRETCH_FACES = 64

	return EHT.EffectType:New( index, name, {
		Category = CAT.SKY,
		Environmental = true,
		Global = true,
		UniqueClass = "Sky Overlay",
		ResetOnScale = true,
		Init = function( self )
			local tfaces = { }
			self.TextureFaces = tfaces

			local p, tC, faces, angle, drawLevel, ps, r, g, b, a, x1, x2, y1, y2, radiusOffset, addColor, dodgeColor, wrap
			local height, width, radius = 150000, 150000, 150000 * 0.5
			local pIndex = 1

			self:SetSize( width, height, width )
			ApplySkyboxPresets( self )

			self:SetAutoDrawLevelEnabled( false )
			self:SetAutoColorEnabled( false )
			self:SetAutoOrientationEnabled( false )
			self:SetAutoPositionEnabled( false )
			self:SetAutoSizeEnabled( false )

			self:SetColor( options.R or 1, options.G or 1, options.B or 1, options.A or 1 )
			self:SetContrast( options.Contrast or 1 )
			self:SetOrientation( 0, 0, 0 )

			local eX, eY, eZ = self:GetPosition()

			self.SideTextures = sideTextures
			self.SideTextureFades = { }

			if topTexture then
				p = self:AddParticle( topTexture,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1.1, 1.1,	true, false, false )
				self.TopTexture = p
				p:SetPosition( eX, eY + height, eZ )
				p:SetOrientation( 0.5 * math.pi, 0, 0 )
				p:SetSize( width * 1.1, width * 1.1 )
				p:SetColor( 1, 1, 1, 1 )
				p:SetDrawLevel( 1 )
				p.BaseR, p.BaseG, p.BaseB, p.BaseA = 1, 1, 1, 1
				p:SetCanModifyColor( false ~= options.CanModifyTopColor )
			else
				p = self:AddParticle( TEXTURES.SOLID,	0, 0, 0,	0, 0, 0,	0, 0, 0, 1,		1.1, 1.1,	true, false, false )
				self.TopTexture = p
				p:SetPosition( eX, eY + height, eZ )
				p:SetOrientation( 0.5 * math.pi, 0, 0 )
				p:SetSize( width * 1.1, width * 1.1 )
				p:SetColor( 0, 0, 0, 1 )
				p:SetDrawLevel( 1 )
				p.BaseR, p.BaseG, p.BaseB, p.BaseA = 0, 0, 0, 1
				p:SetCanModifyColor( false ~= options.CanModifyTopColor )
			end

			table.insert( tfaces, { p } )

			for index, textureOptions in ipairs( sideTextures ) do

				faces = { }
				table.insert( tfaces, faces )

				r, g, b, a = textureOptions.R or 1, textureOptions.G or 1, textureOptions.B or 1, textureOptions.A or 1
				drawLevel = 100 - 10 * index
				radiusOffset = textureOptions.RadiusOffset or 1
				wrap = true == textureOptions.Wrap
				addColor, dodgeColor = true == textureOptions.AddColor, true == textureOptions.DodgeColor
				local offset = 100
				ps = { }

				if false == textureOptions.Stretch then
					x1, x2, y1, y2 = textureOptions.X1, textureOptions.X2, textureOptions.Y1, textureOptions.Y2

					p = self:AddParticle( textureOptions.Texture,	0, 0, 0,		0, 0, 0,		1, 1, 1, 1,		1, 1,	true, false, wrap )
					table.insert( ps, p )
					table.insert( faces, p )
					p:SetPosition( eX - radius * radiusOffset - offset, eY + 0.5 * height, eZ )
					p:SetOrientation( 0, 0.5 * math.pi, 0 )
					p:SetSize( width, height )
					p:SetDrawLevel( drawLevel )
					p:SetColorOffsets( r, g, b, a )
					p.BaseR, p.BaseG, p.BaseB, p.BaseA = r, g, b, a
					if dodgeColor then p:SetDodge( true ) end
					if addColor then p:SetAdditive( true ) end
					if not x1 then
						p:SetTextureCoords( 0, 0.24999, 0, 1 )
					else
						p:SetTextureCoords( x1, x2, y1, y2 )
					end

					p = self:AddParticle( textureOptions.Texture,	0, 0, 0,		0, 0, 0,		1, 1, 1, 1,		1, 1,	true, false, wrap )
					table.insert( ps, p )
					table.insert( faces, p )
					p:SetPosition( eX, eY + 0.5 * height, eZ - radius * radiusOffset - offset )
					p:SetDrawLevel( drawLevel )
					p:SetSize( width, height )
					p:SetColorOffsets( r, g, b, a )
					p.BaseR, p.BaseG, p.BaseB, p.BaseA = r, g, b, a
					if dodgeColor then p:SetDodge( true ) end
					if addColor then p:SetAdditive( true ) end
					if not x1 then
						p:SetTextureCoords( 0.25, 0.49999, 0, 1 )
					else
						p:SetTextureCoords( x1, x2, y1, y2 )
					end

					p = self:AddParticle( textureOptions.Texture,	0, 0, 0,		0, 0, 0,		1, 1, 1, 1,		1, 1,	true, false, wrap )
					table.insert( ps, p )
					table.insert( faces, p )
					p:SetPosition( eX + radius * radiusOffset + offset, eY + 0.5 * height, eZ )
					p:SetOrientation( 0, 1.5 * math.pi, 0 )
					p:SetSize( width, height )
					p:SetDrawLevel( drawLevel )
					p:SetColorOffsets( r, g, b, a )
					p.BaseR, p.BaseG, p.BaseB, p.BaseA = r, g, b, a
					if dodgeColor then p:SetDodge( true ) end
					if addColor then p:SetAdditive( true ) end
					if not x1 then
						p:SetTextureCoords( 0.5, 0.74999, 0, 1 )
					else
						p:SetTextureCoords( x1, x2, y1, y2 )
					end

					p = self:AddParticle( textureOptions.Texture,	0, 0, 0,		0, 0, 0,		1, 1, 1, 1,		1, 1,	true, false, wrap )
					table.insert( ps, p )
					table.insert( faces, p )
					p:SetPosition( eX, eY + 0.5 * height, eZ + radius * radiusOffset + offset )
					p:SetOrientation( 0, 1 * math.pi, 0 )
					p:SetSize( width, height )
					p:SetDrawLevel( drawLevel )
					p:SetColorOffsets( r, g, b, a )
					p.BaseR, p.BaseG, p.BaseB, p.BaseA = r, g, b, a
					if dodgeColor then p:SetDodge( true ) end
					if addColor then p:SetAdditive( true ) end
					if not x1 then
						p:SetTextureCoords( 0.75, 1, 0, 1 )
					else
						p:SetTextureCoords( x1, x2, y1, y2 )
					end
				else
					for faceIndex = 1, NUM_STRETCH_FACES do
						p = self:AddParticle( textureOptions.Texture,	0, 0, 0,		0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, wrap )

						table.insert( ps, p )
						table.insert( faces, p )

						p:SetDrawLevel( drawLevel + ( faceIndex % 2 ) )
						pIndex = pIndex + 1

						if addColor or textureOptions.Additive then
							p:SetAdditive( true )
						elseif dodgeColor then
							p:SetDodge( true )
						end
					end
				end

				if textureOptions.EasedFadeMinInterval then
					table.insert( self.SideTextureFades, {
						Particles = ps,
						MinInterval = textureOptions.EasedFadeMinInterval,
						MaxInterval = textureOptions.EasedFadeMaxInterval or textureOptions.EasedFadeMinInterval,
						Offset = textureOptions.EasedFadeOffset or 0,
						Delay = textureOptions.EasedFadeDelay or 0,
						MaxVertexAlphas = textureOptions.MaxVertexAlphas, } )
				end
			end

			p = self:AddParticle( TEXTURES.SOLID,	0, 0, 0,	0, 0, 0,	0, 0, 0, 1,		1.1, 1.1,	true, false, false )
			p:SetPosition( eX, eY, eZ )
			p:SetColor( 0, 0, 0, 1 )
			p:SetOrientation( 0.5 * math.pi, 0, 0 )
			p:SetSize( width * 1.1, width * 1.1 )
			p:SetDrawLevel( 1 )

			table.insert( tfaces, { p } )

			self:Update()
		end,

		Update = function( self )
			local fades = self.SideTextureFades

			if fades then
				local ft = FrameTime
				local interval, offset, vertexAlphas, r, g, b

				for fadeIndex, fade in ipairs( fades ) do
					vertexAlphas = fade.MaxVertexAlphas

					if not fade.IntervalEnd or ft >= fade.IntervalEnd then
						fade.Interval = fade.MinInterval + ( fade.MaxInterval - fade.MinInterval ) * math.random()
						fade.IntervalStart = fade.IntervalEnd or ( ft + fade.Offset )
						fade.IntervalEnd = fade.IntervalStart + fade.Interval + fade.Delay
					end

					if ft > fade.IntervalStart and ft < fade.IntervalStart + fade.Interval then
						interval = GetEasedInterval( fade.Interval, fade.IntervalStart )
					else
						interval = 0
					end

					if not vertexAlphas then
						for index, particle in ipairs( fade.Particles ) do
							particle:SetAlpha( 0 < interval and zo_clamp( interval * particle.BaseA, 0, particle.BaseA ) or 0 )
						end
					else
						for index, particle in ipairs( fade.Particles ) do
							r, g, b = particle:GetColor()
							particle:SetVertexColors( 1, r, g, b, 0 < interval and math.min( zo_clamp( interval * particle.BaseA, 0, particle.BaseA ), vertexAlphas[1] ) or 0 )
							particle:SetVertexColors( 2, r, g, b, 0 < interval and math.min( zo_clamp( interval * particle.BaseA, 0, particle.BaseA ), vertexAlphas[2] ) or 0 )
							particle:SetVertexColors( 4, r, g, b, 0 < interval and math.min( zo_clamp( interval * particle.BaseA, 0, particle.BaseA ), vertexAlphas[3] ) or 0 )
							particle:SetVertexColors( 8, r, g, b, 0 < interval and math.min( zo_clamp( interval * particle.BaseA, 0, particle.BaseA ), vertexAlphas[4] ) or 0 )
						end
					end
				end
			end

			if updateHandler then updateHandler( self ) end
		end,

		Reset = function( self )
			ApplySkyboxPresets( self, true )

			local p, pIndex, tC, angle, r, g, b, x1, x2, y1, y2, desat, radiusOffset, sampleRGB, sampleAlpha
			local eR, eG, eB, eA = self:GetColor()
			local eX, eY, eZ = self:GetPosition()
			local _, yaw, _ = self:GetOrientation()
			local width, height = self:GetSize()

			local iterations = 0
			while iterations < 1000 do
				local circumference = EHT.World:GetCircumferenceSegmentSize( NUM_STRETCH_FACES, width, width, 1 )
				if math.floor( circumference ) == circumference then
					break
				else
					width = width - 1
					iterations = iterations + 1
				end
			end
			local radius = 0.5 * width
			yaw = yaw or 0

			p = self.Particles[1]
			-- p:SetPosition( eX, eY + height + math.min( 1000, height * 0.1 ), eZ )
			p:SetPosition( eX, eY + height + 1, eZ )
			p:SetOrientation( 0.5 * math.pi, 0, 0 )
			p:SetSize( width * 1.2, width * 1.2 )
			p:SetColor( p.BaseR * eR, p.BaseG * eG, p.BaseB * eB, p.BaseA * eA )

			pIndex = 2

			for index, textureOptions in ipairs( sideTextures ) do
				r, g, b, a = textureOptions.R or 1, textureOptions.G or 1, textureOptions.B or 1, textureOptions.A or 1
				x1, x2, y1, y2 = textureOptions.X1 or 0, textureOptions.X2 or 1, textureOptions.Y1 or 0, textureOptions.Y2 or 1
				radiusOffset = textureOptions.RadiusOffset or 1
				sampleRGB = textureOptions.SampleRGB or 1
				sampleAlpha = textureOptions.SampleAlpha or 0
				desat = textureOptions.Desaturation or 0
				local modifiableColor = false ~= textureOptions.CanModifyColor

				r, g, b, a = r * eR, g * eG, b * eB, a * eA

				if false == textureOptions.Stretch then
					local adjX, adjY, adjZ = 1.1 * radius * radiusOffset, 0.5 * height, 1.1 * radius * radiusOffset
					angle = ( yaw or 0 ) + math.rad( 0.25 )

					for faceIndex = 1, 4 do
						p = self.Particles[pIndex] pIndex = pIndex + 1
						p:SetPosition( eX + adjX * math.sin( angle ), eY + adjY, eZ + adjZ * math.cos( angle ) )
						p:SetOrientation( 0, angle + 0 * math.pi, 0 )
						--p:SetOrientation( 0, angle + 0.25 * math.pi, 0 )
						p:SetSize( 4 * width, height )
						p:SetColor( r, g, b, a )
						p:SetSampleProcessing( sampleRGB, sampleAlpha )
						p:SetDesaturation( desat )
						p.BaseR, p.BaseG, p.BaseB, p.BaseA = r, g, b, a
						if textureOptions.MaxVertexAlphas then
							p:SetCanModifyColor( true )
							local alphas = textureOptions.MaxVertexAlphas
							p:SetVertexColors( 1, r, g, b, alphas[1] )
							p:SetVertexColors( 2, r, g, b, alphas[2] )
							p:SetVertexColors( 4, r, g, b, alphas[3] )
							p:SetVertexColors( 8, r, g, b, alphas[4] )
						end
						p:SetCanModifyColor( modifiableColor )
						angle = angle + 0.5 * math.pi
					end
				else
					local minX, minY = x1, y1
					local rangeX, rangeY = x2 - x1, y2 - y1
					local numFaces = NUM_STRETCH_FACES
					local a1, a2, px1, pz1, px2, pz2
					local r2 = radius * radiusOffset

					for faceIndex = 1, numFaces do
						angle, a1, a2 = yaw + 2 * math.pi * ( ( faceIndex - 0.5 ) / numFaces ), yaw + 2 * math.pi * ( ( faceIndex - 1 ) / numFaces ), yaw + 2 * math.pi * ( faceIndex / numFaces )
						px1, pz1 = r2 * math.sin( a1 ), r2 * math.cos( a1 )
						px2, pz2 = r2 * math.sin( a2 ), r2 * math.cos( a2 )

						p = self.Particles[pIndex]
						pIndex = pIndex + 1

						local faceWidth = math.floor( math.sqrt( ( px2 - px1 ) * ( px2 - px1 ) + ( pz2 - pz1 ) * ( pz2 - pz1 ) ) ) + 3 * ( faceIndex % 2 )
						p:SetSize( faceWidth, height )

						p:SetPosition( eX + ( ( px1 + px2 ) * 0.5 ), eY + 0.5 * height, eZ + ( ( pz1 + pz2 ) * 0.5 ) )

						p:SetOrientation( 0, angle, 0 )

						p:SetColor( r, g, b, a )
						p.BaseR, p.BaseG, p.BaseB, p.BaseA = r, g, b, a

						p:SetSampleProcessing( sampleRGB, sampleAlpha )

						p:SetDesaturation( desat )

						if textureOptions.MaxVertexAlphas then
							p:SetCanModifyColor( true )
							local alphas = textureOptions.MaxVertexAlphas
							p:SetVertexColors( 1, r, g, b, alphas[1] )
							p:SetVertexColors( 2, r, g, b, alphas[2] )
							p:SetVertexColors( 4, r, g, b, alphas[3] )
							p:SetVertexColors( 8, r, g, b, alphas[4] )
						end

						px1, px2 = minX + rangeX * ( ( faceIndex - 1 ) / numFaces ), minX + rangeX * ( faceIndex / numFaces )
						p:SetTextureCoords( px1, px2, minY, minY + rangeY )

						p:SetCanModifyColor( modifiableColor )
					end
				end
			end

			p = self.Particles[ #self.Particles ]
			p:SetPosition( eX, eY, eZ )
			p:SetOrientation( 0.5 * math.pi, 0, 0 )
			p:SetSize( width * 1.1, width * 1.1 )

			self:Update()

			if resetHandler then resetHandler( self ) end
		end,
	} )

end

local function AddSceneryEffect( index, name, maxDepthPercent, numSegments, tex1, tex1minY, tex1maxY, tex2, tex2minY, tex2maxY, r, g, b, a )

	return EHT.EffectType:New( index, name, {

		Category = CAT.SCENE,

		CanPitch = false,

		OrderDrawLevelByIndex = true,

		Environmental = true,

		Global = true,

		Init = function( self )

			self.NumSegments = self.NumSegments or numSegments
			if not self.NumSegments then self.NumSegments = 24 end

			local p, tx1, tx2
			local maxP = 0.5 * self.NumSegments

			maxDepthPercent = maxDepthPercent or 0.5

			for index = 1, maxP do
				if 0 == ( index % 5 ) % 2 then tx1, tx2 = 0, 1 else tx1, tx2 = 1, 0 end

				p = self:AddParticle( tex1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
				p:SetTextureCoords( tx1, tx2, tex1minY or 0, tex1maxY or 1 )

				p = self:AddParticle( tex2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
				p:SetTextureCoords( tx1, tx2, tex2minY or 0, tex2maxY or 1 )
			end

			self.Panels = 6
			self:SetSize( 120000, 120000, 120000 )
			self:SetColor( r or 1, g or 1, b or 1, a or 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 15 )

			local houseId = EHT.Housing.GetHouseId()
			local data = SKY_BOX_PRESETS[ string.format( "%d@%d", houseId, self.EffectType.Index ) ]
			if not data then data = SKY_BOX_PRESETS[ string.format( "%d", houseId ) ] end

			if data then
				self:SetPosition( data.X, data.Y, data.Z )
				self:SetOrientation( data.Pitch, data.Yaw, data.Roll )
				self:SetSize( maxDepthPercent * data.SizeX, maxDepthPercent * data.SizeY, maxDepthPercent * data.SizeY )
			end

		end,

		Reset = function( self )

			local x, y, z = self:GetPosition()
			local sx, sy, sz = self:GetSize()
			local _, baseYaw, _ = self:GetOrientation()
			local cr, cg, cb, ca = self:GetColor()
			local ps = self.Particles
			local panels = self.Panels
			local rotations = self.NumSegments / panels
			local angle, color, depth, p, pOffset, xzOffset, sizeX, sizeY, baseSizeX, baseSizeY

			self:Update()

			if EHT.DEBUG_MODE then df( "DEBUG: AddSceneryEffect\n%d x %d (%.1f base yaw)\n(%d panels, %d/rotation, %d rotations)", sx, sy, math.deg( baseYaw ), maxP, panels, rotations ) end

			for index = 1, self.NumSegments do
				p = ps[index]

				xzOffset = ( index % panels ) / panels
				pOffset = math.floor( ( index - 1 ) / panels ) / rotations
				depth = maxDepthPercent * ( 1 - 0.2 * pOffset )
				color = 0.2 + 0.8 * pOffset
				angle = ( baseYaw + ( 0.5 * pOffset + xzOffset ) * 2 * math.pi ) % ( 2 * math.pi )

				sizeX = EHT.World:GetCircumferenceSegmentSize( panels, ( 2 - 0.5 * pOffset ) * sx, ( 2 - 0.5 * pOffset ) * sx )
				sizeY = ( sizeX / sx ) * sy

				if EHT.DEBUG_MODE then
					df( "[%d] %.2f +%.2f: %.1f, %.2f: %d x %d", index, xzOffset, pOffset, math.deg( angle ), depth, sizeX, sizeY )
				end

				p:SetPositionAndOrientation(
					x + depth * sx * math.sin( angle ),
					y + 0.5 * sizeY,
					z + depth * sx * math.cos( angle ),
					0, angle, 0 )
				p:SetColor( color * cr, color * cg, color * cb )
				p:SetSize( sizeX, sizeY )
			end
			

		end,

	} )

end

local function AddShrubberyEffect( index, name, textureFile, targetWidth, targetHeight, simulateDepth, r, g, b )

	return EHT.EffectType:New( index, name, {

		Category = CAT.LAND,

		CanPitch = true,

		OrderDrawLevelByIndex = true,

		Init = function( self )

			self.TargetWidth, self.TargetHeight = targetWidth or 128, targetHeight or 128

			if false ~= simulateDepth then
				self:AddParticle( textureFile,  0, 0, 6,  0, 0, 0,  0.3 * ( r or 1 ), 0.3 * ( g or 1 ), 0.3 * ( b or 1 ), 1,  0.5, 1,  true, false, false )
				self:AddParticle( textureFile,  0, 0, 3,  0, 0, 0,  0.6 * ( r or 1 ), 0.6 * ( g or 1 ), 0.6 * ( b or 1 ), 1,  0.75, 1,  true, false, false )
			end

			self:AddParticle( textureFile,  0, 0, 0,  0, 0, 0,  r or 1, g or 1, b or 1, 1,  1, 1,  true, false, false )

			self:SetColor( 1, 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SetSize( self.TargetWidth, self.TargetHeight, self.TargetHeight )
			self:SpawnAtPlayer( 0.5 * self.TargetHeight, false )

		end,

		Reset = function( self )

			local sx, sy, sz = self:GetSize()
			local _, yaw = self:GetOrientation()
			local unitWidth
			sy = math.max( sy, sz )

			self:SetSize( sx, sy, sy )
			self:Update()

			unitWidth = self.TargetWidth

			while unitWidth <= ( 2 * self.TargetWidth ) do
				if ( sx / unitWidth ) % 1 <= 0.005 then break end
				unitWidth = unitWidth + 1
			end

			if false ~= simulateDepth then
				self.Particles[3]:Tile( unitWidth, sy )
				self.Particles[2]:Tile( 0.5 * unitWidth, sy )
				self.Particles[1]:Tile( 0.75 * unitWidth, sy )
			else
				self.Particles[1]:Tile( unitWidth, sy )
			end

		end,

	} )

end

local function AddTiledEffect( index, category, name, textureFile, targetWidth, targetHeight, r, g, b, a, colorTexture, pitch, yaw, roll )
	return EHT.EffectType:New( index, name, {
		Category = category,
		CanPitch = true,

		Init = function( self )
			self.TargetWidth, self.TargetHeight = targetWidth, targetHeight
			self:AddParticle( textureFile, 			0, 0, 0,	pitch or 0, yaw or 0, roll or 0,	1, 1, 1, 1,		1, 1,	true, false, true )
			if colorTexture then
				self:AddParticle( colorTexture,		0, 0, 0,	pitch or 0, yaw or 0, roll or 0,	1, 1, 1, 1,		1, 1,	true, false, true )
			end
			self:SetColor( r or 1, g or 1, b or 1, a or 1 )
			self:SetSize( self.TargetWidth, self.TargetHeight, self.TargetHeight )
			self:SpawnAtPlayer( 0.5 * self.TargetHeight, true )
		end,

		Reset = function( self )
			self:Update()

			local sx, sy, sz = self:GetSize()
			sy = math.max( sy, sz )

			local scaleX = tonumber( self:GetMetaData( "Pattern Scale % (X)" ) )
			local scaleY = tonumber( self:GetMetaData( "Pattern Scale % (Y)" ) )

			if scaleX then
				scaleX = scaleX / 100
			else
				scaleX = 1
			end

			if scaleY then
				scaleY = scaleY / 100
			else
				scaleY = 1
			end

			local scaledX, scaledY = scaleX * targetWidth, scaleY * targetHeight
			local x1, x2, y1, y2

			if 0 > scaleX then
				x1, x2 = 0, sx / -scaledX
			else
				x1, x2 = sx / scaledX, 0
			end

			if 0 > scaleY then
				y1, y2 = 0, sy / -scaledY
			else
				y1, y2 = sy / scaledY, 0
			end

			self.Particles[1]:SetTextureCoords( x1, x2, y1, y2 )
			if colorTexture then
				self.Particles[2]:SetTextureCoords( x1, x2, y1, y2 )
				self.Particles[1]:SetColor( 1, 1, 1, 1 )
			end
		end,
	} )
end

local function AddTiledScaledEffect( index, category, name, textureFile, targetWidth, targetHeight, minPercentX, maxPercentX, minPercentY, maxPercentY, fixedX, fixedY, r, g, b, a )
	minPercentX, minPercentY = minPercentX or 1, minPercentY or 1
	maxPercentX, maxPercentY = maxPercentX or 2, maxPercentY or 2

	return EHT.EffectType:New( index, name, {
		Category = category,
		CanPitch = true,
		Init = function( self )
			self.TargetWidth, self.TargetHeight = targetWidth, targetHeight
			self:AddParticle( textureFile,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )
			self:SetColor( r or 1, g or 1, b or 1, a or 1 )
			self:SetSize( self.TargetWidth, self.TargetHeight, self.TargetHeight )
			self:SpawnAtPlayer( 0.5 * self.TargetHeight, true )
		end,
		Reset = function( self )
			local sx, sy, sz = self:GetSize()
			local unitWidth, unitHeight = minPercentX * self.TargetWidth, minPercentY * self.TargetHeight
			sy = math.max( sy, sz )

			if fixedX then
				unitWidth = ( 1 / ( maxPercentX or 1 ) ) * sx
			elseif unitWidth >= sx then
				unitWidth = sx
			else
				while unitWidth <= ( maxPercentX * self.TargetWidth ) do
					if ( sx / unitWidth ) % 1 <= 0.01 then break end
					unitWidth = unitWidth + 1
				end
			end

			if fixedY then
				unitHeight = ( 1 / ( maxPercentY or 1 ) ) * sy
			elseif unitHeight >= sy then
				unitHeight = sy
			else
				while unitHeight <= ( maxPercentY * self.TargetHeight ) do
					if ( sy / unitHeight ) % 1 <= 0.01 then break end
					unitHeight = unitHeight + 1
				end
			end

			self:SetSize( sx, sy, sy )
			self:Update()
			self.Particles[1]:Tile( unitWidth, unitHeight )
		end,
	} )
end

local function AddCappedHorizontallyTiledEffect( index, category, name, r, g, b, a, width, bottomTex, bottomHeight, centerTex, centerHeight, topTex, topHeight )

	return EHT.EffectType:New( index, name, {

		Category = category,
		CanPitch = true,
		OrderDrawLevelByIndex = true,
		ResetOnOrient = true,
		ResetOnScale = true,

		Init = function( self )

			local height = bottomHeight + centerHeight + topHeight
			self:SetAutoPositionEnabled( false )
			self:SetAutoOrientationEnabled( false )
			self:AddParticle( centerTex,	0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, true )
			self:AddParticle( bottomTex,	0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, true )
			self:AddParticle( topTex,		0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, true )
			self:SetColor( r or 1, g or 1, b or 1, a or 1 )
			self:SetSize( width, height )
			self:SpawnAtPlayer( 500, true )

		end,

		Reset = function( self )

			local pitch, yaw, roll = self:GetOrientation()
			local cx, cy, cz = self:GetPosition()
			local sx, sy, sz = self:GetSize()
			local height = math.max( sy, sz )
			local hHeight, bHeight, tHeight = math.floor( 0.5 * height ), math.floor( 0.5 * bottomHeight ), math.floor( 0.5 * topHeight )
			local p, x, y, z

			self:SetSize( sx, height, height )

			x, y, z = EHT.World.Rotate( 0, -tHeight + bHeight, 0, pitch, yaw, roll )
			p = self.Particles[1]
			p:SetOrientation( pitch, yaw, roll )
			p:SetPosition( x + cx, y + cy, z + cz )
			p:SetSize( sx, 2 + height - ( topHeight + bottomHeight ) )
			p:Tile( width, centerHeight )

			x, y, z = EHT.World.Rotate( 0, ( -hHeight + bHeight ), 0, pitch, yaw, roll )
			p = self.Particles[2]
			p:SetOrientation( pitch, yaw, roll )
			p:SetPosition( x + cx, y + cy, z + cz )
			p:SetSize( sx, bottomHeight )
			p:Tile( width, bottomHeight )

			x, y, z = EHT.World.Rotate( 0, ( hHeight - tHeight ), 0, pitch, yaw, roll )
			p = self.Particles[3]
			p:SetOrientation( pitch, yaw, roll )
			p:SetPosition( x + cx, y + cy, z + cz )
			p:SetSize( sx, topHeight )
			p:Tile( width, topHeight )

		end,

	} )

end

local function AddMultilayeredEffect( index, category, name, textureFile, width, height, r, g, b, a, layers )

	return EHT.EffectType:New( index, name, {

		Category = category,
		CanPitch = true,
		OrderDrawLevelByIndex = true,

		Init = function( self )

			local p

			for index, layer in ipairs( layers ) do
				p = self:AddParticle( textureFile, 	0, 0, 0,	0, 0, 0,	layer.R or 1, layer.G or 1, layer.B or 1, layer.A or 1,		1, 1,		true, false, false )
				if layer.Additive then
					p:SetAdditive( true )
				elseif layer.Dodge then
					p:SetDodge( true )
				end
				p:SetSampleProcessing( layer.SampleRGB or 1, layer.SampleAlpha or 0 )
				p:SetTextureCoords( layer.X1 or 0, layer.X2 or 1, layer.Y1 or 0, layer.Y2 or 1 )
				p:SetAutoColorEnabled( false ~= layer.Colored )
			end

			self:SetColor( r or 1, g or 1, b or 1, a or 1 )
			self:SetSize( width, height, height )
			self:SpawnAtPlayer( 0.5 * height, true )

		end,

	} )

end

local function AddCroppedEffect( index, category, name, textureFile, width, height, x1, x2, y1, y2, offsetX, offsetY, offsetZ, pitch, yaw, roll, colorTextureFile, r, g, b, a, sampleRGB, sampleAlpha, sampleRGB2, sampleAlpha2, textureColorDistribution, colorAlpha, colorAdditive, colorDodge, baseTextureColorDistribution, cx1, cx2, cy1, cy2 )
	return EHT.EffectType:New( index, name, {
		Category = category,
		CanPitch = true,
		Init = function( self )
			local p = self:AddParticle( textureFile, 		offsetX or 0, offsetY or 0, offsetZ or 0,	pitch or 0, yaw or 0, roll or 0,	1, 1, 1, 1,						1, 1,		true, false, false )
			p:SetTextureCoords( x1 or 0, x2 or 1, y1 or 0, y2 or 1 )
			p:SetSampleProcessing( sampleRGB or 1, sampleAlpha or 0 )

			if colorTextureFile then
				p:SetAutoColorEnabled( false )
				p = self:AddParticle( colorTextureFile, 	offsetX or 0, offsetY or 0, offsetZ or 0,	pitch or 0, yaw or 0, roll or 0,	1, 1, 1, colorAlpha or 1,		1, 1,		true, true == colorAdditive, false )
				if colorDodge then p:SetDodge( true ) end
				p:SetTextureCoords( cx1 or x1 or 0, cx2 or x2 or 1, cy1 or y1 or 0, cy2 or y2 or 1 )
				p:SetSampleProcessing( sampleRGB2 or 1, sampleAlpha2 or 0 )
			end

			self:SetColor( r or 1, g or 1, b or 1, a or 1 )
			self:SetSize( width, height, height )
			self:SpawnAtPlayer( 0.5 * height, true )
		end,
		Reset = function( self )
			self:Update()
			local r, g, b, a = self:GetColor()

			if baseTextureColorDistribution and 0 < baseTextureColorDistribution then
				local dB, dC = 1 - baseTextureColorDistribution, baseTextureColorDistribution
				self.Particles[2]:SetColor( dB + dC * r, dB + dC * g, dB + dC * b, dB + dC * a )
			end

			if textureColorDistribution and 0 < textureColorDistribution then
				local dB, dC = 1 - textureColorDistribution, textureColorDistribution
				self.Particles[1]:SetColor( dB + dC * r, dB + dC * g, dB + dC * b, dB + dC * a )
			end
		end,
	} )
end

local function Add3DCroppedEffect( index, category, name, textureFile, width, height, depth, x1, x2, y1, y2, offsetX, offsetY, offsetZ, pitch, yaw, roll, colorTextureFile, r, g, b, a, sampleRGB, sampleAlpha, sampleRGB2, sampleAlpha2, textureColorDistribution, colorAlpha, colorAdditive, colorDodge )
	local et = AddCroppedEffect( index, category, name, textureFile, width, height, x1, x2, y1, y2, offsetX, offsetY, offsetZ, pitch, yaw, roll, colorTextureFile, r, g, b, a, sampleRGB, sampleAlpha, sampleRGB2, sampleAlpha2, textureColorDistribution, colorAlpha, colorAdditive, colorDodge )
	local originalInit = et.Init
	et.Init = function( self )
		originalInit( self )
		self.OrderDrawLevelByIndex = true

		local p1, p2 = self.Particles[1], self.Particles[2]

		for index = math.floor( -0.5 * depth ), math.ceil( 0.5 * depth ), 2 do
			local p = self:CloneParticle( p1 )
			p:SetPositionOffsets( 0, 0, index )
		end

		p1:Delete()

		if p2 then
			local p = self:CloneParticle( p2 )
			p:SetPositionOffsets( 0, 0, -2 + math.floor( -0.5 * depth ) )

			p = self:CloneParticle( p2 )
			p:SetPositionOffsets( 0, 0, 2 + math.ceil( 0.5 * depth ) )

			p2:Delete()
		end
	end
	et.Reset = function( self )
		self:Update()

		local r, g, b, a = self:GetColor()
		if textureColorDistribution and 0 < textureColorDistribution then
			local dB, dC = 1 - textureColorDistribution, textureColorDistribution
			local maxP = #self.Particles

			for index = 1, maxP - 2 do
				self.Particles[ index ]:SetColor( dB + dC * r, dB + dC * g, dB + dC * b, dB + dC * a )
			end
		end
	end
	et.Update = function( self )
		local x, y, z, pitch, yaw, roll = self:GetPositionAndOrientation()
		local angle = math.atan2( CameraX - x, CameraZ - z )
		local delta = ( yaw + 0.5 * math.pi ) - angle
		local newYaw

		if math.rad( 10 ) > ( delta % math.pi ) then
			newYaw = yaw + math.rad( 10 )
		elseif math.rad( 170 ) < ( delta % math.pi ) then
			newYaw = yaw - math.rad( 10 )
		else
			newYaw = yaw
		end

		if not self.TempYaw or self.TempYaw ~= newYaw then
			self.TempYaw = newYaw

			for index = 1, #self.Particles do
				self.Particles[index]:SetOrientation( pitch, newYaw, roll )
			end
		end
	end

	return et
end

local function AddCroppedShadowedEffect( index, category, name, textureFile, width, height, x1, x2, y1, y2, offsetX, offsetY, offsetZ )
	local effectType = AddCroppedEffect( index, category, name, textureFile, width, height, x1, x2, y1, y2, offsetX, offsetY, offsetZ )
	local baseInit = effectType.Init

	effectType.OFFSET_X1, effectType.OFFSET_X2 = 0.508, 0.491
	effectType.OFFSET_Y1, effectType.OFFSET_Y2 = -0.1, 0.3
	effectType.RELATIVE_OFFSET_Y1, effectType.RELATIVE_OFFSET_Y2 = 0.02, 0.035
	effectType.OrderDrawLevelByIndex = true
	effectType.Init = function( self )
		baseInit( self )

		local p = self:AddParticle( textureFile, 	offsetX or 0, offsetY or 0, offsetZ or 0,	pitch or 0, yaw or 0, roll or 0,	1, 1, 1, 1,		1, 1,		true, false, false )
		p:SetTextureCoords( 0.5 + x1, 0.5 + x2, y1, y2 )
		p:SetColor( 1, 1, 1, 0.35 )
	end

	effectType.Update = function( self )
		local x, y, z = self:GetPosition()
		local angle = math.atan2( CameraX - x, CameraZ - z )
		local offset = effectType.RELATIVE_OFFSET_Y1 - ( effectType.RELATIVE_OFFSET_Y2 * ( ( angle % RAD180 ) / RAD180 ) )

		local p = self.Particles[2]
		p:SetTextureCoords( effectType.OFFSET_X1 + ( x1 or 0 ), effectType.OFFSET_X2 + ( x2 or 0.5 ), effectType.OFFSET_Y1 + ( y1 or 0 ) + offset, effectType.OFFSET_Y2 + ( y2 or 1 ) + offset )
	end

	return effectType
end

local function AddPattern( id, cat, name, texture, pitch, ratioX, ratioY, submitter, r, g, b, a, tintRatio, colorTexture )
	local et = AddTiledEffect( id, cat, name, texture, ratioX, ratioY, r or 0.8, g or 0.8, b or 0.8, a or 1, colorTexture )
	et.Submitter = submitter
	et.MetaParams = { GetMetaParamByName( "Pattern Scale % (X)" ), GetMetaParamByName( "Pattern Scale % (Y)" ) }

	local init = et.Init
	et.Init = function( self )
		init( self )
		self:SetOrientation( pitch, 0, 0 )
		self:SetTintRatio( tintRatio or 0.8 )
	end

	return et
end

local function AddTile( id, cat, name, texture, ratioX, ratioY, submitter, r, g, b, a, tintRatio, colorTexture )
	return AddPattern( id, cat, name, texture, 0.5 * math.pi, ratioX, ratioY, submitter, r, g, b, a, tintRatio, colorTexture )
end

local function AddWall( id, cat, name, texture, ratioX, ratioY, submitter, r, g, b, a, tintRatio, colorTexture )
	return AddPattern( id, cat, name, texture, 0, ratioX, ratioY, submitter, r, g, b, a, tintRatio, colorTexture )
end

local function AddWallReversed( id, cat, name, texture, ratioX, ratioY, submitter, r, g, b, a, tintRatio, colorTexture )
	return AddPattern( id, cat, name, texture, math.pi, ratioX, ratioY, submitter, r, g, b, a, tintRatio, colorTexture )
end

local function AddTimeRiftEffect( index, name, unstable )
	EHT.EffectType:New( index, name, {
		Category = CAT.ANIM,
		CanPitch = true,
		OrderDrawLevelByIndex = true,
		Init = function( self )
			self.Interval, self.IntervalUnit, self.SoundInterval, self.NextSound, self.NextSoundIndex = 2300, 210, 350, 0, 0

			for index = 1, 4 do
				p = self:AddParticle( TEXTURES.ETHEREAL_1,		0, 0, 0,		0, 0, 0,	0, 0, 0, 0,		1, 1,		true, true, false )
				p:SetSampleProcessing( 4, 0.5 )

				p = self:AddParticle( TEXTURES.ETHEREAL_2,		0, 0, 0,		0, 0, 0,	0, 0, 0, 0,		1, 1,		true, true, false )
				p:SetSampleProcessing( 4, 0.5 )

				p = self:AddParticle( TEXTURES.ETHEREAL_3,		0, 0, 0,		0, 0, 0,	0, 0, 0, 0,		1, 1,		true, true, false )
				p:SetSampleProcessing( 4, 0.5 )
			end

			if unstable then
				self:SetSize( 200, 260, 260 )
				self:SetColor( 1, 1, 1, 1 )
			else
				self:SetSize( 70, 220, 220 )
				self:SetColor( 1, 1, 0.5, 1 )
			end

			self:SpawnAtPlayer( 150 )
		end,
		Update = function( self )
			local r, g, b = self:GetColor()
			local ps = self.Particles
			local p, interval, interval2, cr, cg, cb, m
			local oh, ol = 1, 0
			local numP = #ps
			local offsetInterval = unstable and ( 2 * GetEasedInterval( self.Interval * 4 ) ) or 2
			local alpha = ps[1]:GetViewingAngleAlpha()

			for index = 1, numP do
				m, p = index % 4, ps[ index ]
				interval = math.sin( 2 * math.pi * GetLinearInterval( self.Interval, self.IntervalUnit * index ) )
				interval2 = math.sin( 2 * math.pi * GetLinearInterval( self.Interval, self.IntervalUnit * ( -0.8 + index ) ) )
				cr, cg, cb = interval * r, interval * g, interval * b
				if unstable then
					oh, ol = 1.1 + 0.1 * math.sin( ( index / numP ) * offsetInterval * math.pi ), -0.1 + 0.1 * math.sin( ( index / numP ) * offsetInterval * math.pi )
				end

				if 0 == m then
					p:SetTextureCoords( oh + interval, ol - interval, ol - interval, oh + interval )
					p:SetVertexColors( 1 + 2, cr, cg, 0.7 * cb, alpha * 0.15 * interval2 )
					p:SetVertexColors( 4 + 8, cr, 0.7 * cg, cb, alpha * -0.15 * interval2 )
				elseif 1 == m then
					p:SetTextureCoords( ol - interval, oh + interval, ol - interval, oh + interval )
					p:SetVertexColors( 2 + 4, cr, 0.7 * cg, cb, alpha * 0.15 * interval2 )
					p:SetVertexColors( 1 + 8, 0.7 * cr, cg, cb, alpha * -0.15 * interval2 )
				elseif 2 == m then
					p:SetTextureCoords( ol - interval, oh + interval, oh + interval, ol - interval )
					p:SetVertexColors( 1 + 4, 0.7 * cr, cg, cb, alpha * 0.15 * interval2 )
					p:SetVertexColors( 2 + 8, cr, cg, 0.7 * cb, alpha * -0.15 * interval2 )
				else
					p:SetTextureCoords( oh + interval, ol - interval, oh + interval, ol - interval )
					p:SetVertexColors( 1 + 4, 0.85 * cr, 0.85 * cg, 0.85 * cb, alpha * 0.12 * interval2 )
					p:SetVertexColors( 2 + 8, 0.85 * cr, 0.85 * cg, 0.85 * cb, alpha * -0.12 * interval2 )
				end

				p:SetSampleProcessing( 9 - 2 * math.abs( interval ), 0 )
			end
		end,
		Reset = function( self )
			self:Update()
		end,
	} )
end
--[[
local function AddEnergyBeamEffect( index, name, category, initialR, initialG, initialB, cycleDuration, activeVerticesLeft, activeVerticesRight )
	return EHT.EffectType:New( index, name, {
		Category = category,
		CanPitch = true,
		Init = function( self )
			activeVerticesLeft, activeVerticesRight = activeVerticesLeft or 4, activeVerticesRight or 8

			local p

			for index = 1, 6 do
				p = self:AddParticle( TEXTURES.ENERGY_1, 0, 0, 0, 0, 0, 0, 0.6 + 0.1 * index, 0.6 + 0.1 * index, 0.6 + 0.1 * index, 1, 0.5, 0.8, true, false, true )
				p:SetSampleProcessing( 2, 0.2 )
			end

			self.Particles[5]:SetDodge( true )
			self.Particles[6]:SetDodge( true )

			self.CoeffY = 1
			self.Duration = cycleDuration or 12000
			self.DurationOffset = math.random( 1, self.Duration )
			self.MinAlpha = 0.05
			self:SetSize( 100, 0, 1000 )
			self:SetColor( initialR or 0.1, initialG or 0.5, initialB or 0.5, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 500 )
		end,
		Update = function( self )
			local horizInterval = 0.05 * GetEasedInterval( 0.5 * self.Duration, self.DurationOffset )
			local p, waveInterval
			local r, g, b = self:GetColor()

			waveInterval = GetLinearInterval( self.Duration, self.DurationOffset )
			p = self.Particles[ 1 ]
			p:SetTextureCoords( -horizInterval, 1 + ( 0.5 * horizInterval ), waveInterval, waveInterval + self.CoeffY )
			p:SetVertexColors( activeVerticesRight, r, g, b, self.MinAlpha + 0.5 * math.sin( waveInterval * math.pi ) )

			waveInterval = GetLinearInterval( 0.4 * self.Duration, self.DurationOffset )
			p = self.Particles[ 3 ]
			p:SetTextureCoords( -( 0.3 * horizInterval ), 1 + horizInterval, waveInterval, waveInterval + self.CoeffY )
			p:SetVertexColors( activeVerticesLeft, r, g, b, self.MinAlpha + 0.5 * math.sin( waveInterval * math.pi ) )

			waveInterval = GetLinearInterval( 1.3 * self.Duration, self.DurationOffset )
			p = self.Particles[ 5 ]
			p:SetTextureCoords( 0, 1 + horizInterval, waveInterval, 1 + waveInterval + self.CoeffY )
			p:SetVertexColors( activeVerticesLeft, 0.5 * r, g, b, 0.5 * math.sin( waveInterval * math.pi ) )

			waveInterval = GetLinearInterval( 0.65 * self.Duration, self.DurationOffset )
			waveInterval = ( waveInterval + 0.5 ) % 1
			p = self.Particles[ 2 ]
			p:SetTextureCoords( -horizInterval, 1 + ( horizInterval ), waveInterval, waveInterval + self.CoeffY )
			p:SetVertexColors( activeVerticesRight, r, g, b, self.MinAlpha + 0.5 * math.sin( waveInterval * math.pi ) )

			waveInterval = GetLinearInterval( 1.5 * self.Duration, self.DurationOffset )
			p = self.Particles[ 4 ]
			p:SetTextureCoords( -( 0.5 * horizInterval ), 1 + horizInterval, waveInterval, waveInterval + self.CoeffY )
			p:SetVertexColors( activeVerticesLeft, r, g, b, self.MinAlpha + 0.5 * math.sin( waveInterval * math.pi ) )

			waveInterval = GetLinearInterval( 1.15 * self.Duration, self.DurationOffset )
			p = self.Particles[ 6 ]
			p:SetTextureCoords( 1 + horizInterval, 0, waveInterval, 1 + waveInterval + self.CoeffY )
			p:SetVertexColors( activeVerticesRight, r, 0.5 * g, b, 0.5 * math.sin( waveInterval * math.pi ) )
		end,
		Reset = function( self )
			local sizeX, sizeY, sizeZ = self:GetSize()
			self.CoeffY = zo_clamp( math.max( sizeY, sizeZ ) / 1500, 1, 3 )

			local r, g, b = self:GetColor()

			for index = 1, #self.Particles do
				self.Particles[index]:SetVertexColors( 1 + 2 + 4 + 8, r, g, b, 0 )
			end
		end,
	} )
end
]]
local function AddEnergyBeamEffect( index, name, category, initialR, initialG, initialB, cycleDuration, activeVertices )
	activeVertices = activeVertices or ( 4 + 8 )

	return EHT.EffectType:New( index, name, {
		Category = category,
		CanPitch = true,
		Init = function( self )
			self:AddParticle( TEXTURES.ENERGY_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0.5, 0.8, true, true, true )
			self:AddParticle( TEXTURES.ENERGY_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0.5, 0.8, true, true, true )
			self.Duration = cycleDuration or 3000
			self.DurationOffset = math.random( 1, self.Duration )
			self:SetSize( 100, 0, 1000 )
			self:SetColor( initialR or 0.1, initialG or 0.5, initialB or 0.5, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 500 )
		end,
		Update = function( self )
			local r, g, b = self:GetColor()
			local p1, p2 = self.Particles[1], self.Particles[2]
			local interval = GetLinearInterval( self.Duration, self.DurationOffset )
			local loopInterval = GetLoopInterval( self.Duration, self.DurationOffset )
			local sample = 0.5 * loopInterval
			local sy = self.ScaleY

			p1:SetTextureCoords( 0, 1, interval, sy + interval )
			p1:SetVertexColors( activeVertices, r, g, b, 0.3 + 0.3 * loopInterval )
			p1:SetSampleProcessing( 1 + sample )

			p2:SetTextureCoords( 0.09, 0.91, -interval, sy - interval )
			p2:SetSampleProcessing( 1.35 - sample )
		end,
		Reset = function( self )
			local _, sizeY = self:GetSize()
			local r, g, b = self:GetColor()

			self.ScaleY = math.ceil( sizeY / 1000 )
			for index = 1, #self.Particles do
				self.Particles[index]:SetVertexColors( 1 + 2 + 4 + 8, r, g, b, 0 )
			end
			self.Particles[2]:SetVertexColors( activeVertices, r, g, b, 0.5 )
		end,
	} )
end

EHT.EffectType:New( 1, "Glass, Window Pane", {

	Category = CAT.BUILD,

	Init = function( self )

		local p
		p = self:AddParticle( TEXTURES.SOLID,	0, 0, 0,	 0, 0, 0,	1, 1, 1, 0.3,		1, 1,	true, true )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0, 0.3, 0.3, 1 )
		self:SpawnAtPlayer( 250 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 2, "Ice Sheet", {

	Category = CAT.LAND,

	Init = function( self )

		local p, width, height = nil, 600, 600

		p = self:AddParticle( "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",			0, 0, 0,		0, 0, 0,		1, 1, 1, 1,				1, 1,		true, false )
		p:SetSampleProcessing( 1, 1 )

		p = self:AddParticle( "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",			0, 0, 0,		0, 0, 0,		0.2, 0.8, 1, 0.6,		1, 1,		true, true )
		p:SetSampleProcessing( 1, 1 )
		p:SetTextureRotation( math.rad( 90 ) )

		p = self:AddParticle( "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",			0, 0, 0,		0, 0, 0,		0.5, 0.4, 1, 0.6,		1, 1,		true, true )
		p:SetSampleProcessing( 1, 1 )
		p:SetTextureRotation( math.rad( 135 ) )

		p = self:AddParticle( "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",			0, 0, 0,		0, 0, 0,		0.8, 0.8, 1, 0.6,		1, 1,		true, true )
		p:SetSampleProcessing( 1, 1 )
		p:SetTextureRotation( math.rad( 225 ) )

		p = self:AddParticle( "art/fx/texture/modelfxtextures/solidblue.dds",							0, 0, 0,		0, 0, 0,		1, 1, 1, 0.5,			1, 1,		true, false )

		p = self:AddParticle( "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",			0, 0, 0,		0, 0, 0,		1, 1, 1, 1,				1, 1,		true, false )
		p:SetSampleProcessing( 1, 1 )

		p = self:AddParticle( "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",			0, 0, 0,		0, 0, 0,		0.2, 0.8, 1, 0.6,		1, 1,		true, true )
		p:SetSampleProcessing( 1, 1 )
		p:SetTextureRotation( math.rad( 90 ) )

		p = self:AddParticle( "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",			0, 0, 0,		0, 0, 0,		0.5, 0.4, 1, 0.6,		1, 1,		true, true )
		p:SetSampleProcessing( 1, 1 )
		p:SetTextureRotation( math.rad( 135 ) )

		p = self:AddParticle( "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",			0, 0, 0,		0, 0, 0,		0.8, 0.8, 1, 0.6,		1, 1,		true, true )
		p:SetSampleProcessing( 1, 1 )
		p:SetTextureRotation( math.rad( 225 ) )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( width, 0, height )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 100 )

	end,

} )

EHT.EffectType:New( 3, "Ethereal Glow", {
	Category = CAT.LIGHT,
	CanPitch = true,

	Init = function( self )
		for index = 1, 3 do
			local m = index % 3
			local r = 0 == m and 0.7 or 1
			local g = 1 == m and 0.7 or 1
			local b = 2 == m and 0.7 or 1
			local p = self:AddParticle( "esoui/art/menubar/icon_highlight.dds",		0, 0, 0,	0, 0, 0,	r, g, b, 0.3,		1, 1,	true, true )
			p.Interval = 30000 - ( ( index - 1 ) * 4000 )
			p.IntervalOffset = 8000 * index
			p.RotationCoefficient = 0 == m and 1 or -1
			p.RotationOffsetX = 0.5 + 0.08 * math.sin( RAD360 * ( index - 1 ) )
			p.RotationOffsetY = 0.5 + 0.08 * math.cos( RAD360 * ( index - 1 ) )
			p.Scale = 0.9 - ( ( index - 1 ) * 0.1 )
		end

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 1000, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 250 )
	end,

	Update = function( self )
		for index = 0, 2 do
			local p = self.Particles[index + 1]
			local interval = GetLinearInterval( p.Interval, p.IntervalOffset )
			p:RotateCoords( RAD360 * p.RotationCoefficient * interval, p.RotationOffsetX, p.RotationOffsetY, p.Scale, p.Scale )
		end
	end
} )

EHT.EffectType:New( 4, "Whirlpool", {
	Category = CAT.ANIM,
	CanPitch = true,

	Init = function( self )
		local p = self:AddParticle( "esoui/art/champion/champion_clouds.dds",		0, 0, 0,		math.rad( 90 ), 0, 0,		1, 1, 1, 0.6,		1, 1,		true, true )
		p:SetSampleProcessing( 1.5, 0.5 )

		self:SetSize( 500, 0, 500 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 50 )
	end,

	Update = function( self )
		self.Particles[1]:SetTextureRotation( 2 * math.pi * GetLinearInterval( self.RotationInterval, self.RotationOffset ) )
	end,

	Reset = function( self )
		local _, yaw = self:GetOrientation()
		local width = self:GetSize()

		self.RotationInterval = ( width / 100 ) * 1000
		self.RotationOffset = ( yaw / math.rad( 360 ) ) * self.RotationInterval
		self.Particles[1]:SetSize( width, width )
	end,
} )
--[[
EHT.EffectType:New( 5, "Funnel Cloud", {

	Category = CAT.WEATHER,
	ResetOnScale = true, ResetOnPosition = true, ResetOnColor = true,

	Init = function( self )

		self:SetSize( 1500, 1500, 1500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 750 )
		self:SetCameraFacing( true )

		local numP, p = 18, nil
		for index = 1, numP do
			p = self:AddParticle( "esoui/art/pregameanimatedbackground/smoke_muted_02.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.9, 1, 1, true, false )
			p:SetTextureWrapping( false )
		end

		self.PitchCap = 0.01 * math.pi
		self:Update()

	end,

	Update = function( self )

		local ps = self.Particles
		local heading, numP = CameraHeading, #ps
		local x, y, z = self:GetPosition()
		local yawAngle = math.atan2( CameraX - x, CameraZ - z )
		local yawCosine, yawSine = math.cos( yawAngle ), math.sin( yawAngle )
		local rotation, interval, p, pX, pY, pZ, pitchAngle

		for index = 1, numP do
			p = ps[index]

			interval = GetLinearInterval( 1000 + ( index / numP ) * 5000, 0 )
			rotation = ( ( 0 == index % 2 ) and 2 or -2 ) * math.pi * interval

			p:SetTextureRotation( rotation )
			p:SetAlpha( math.abs( -1 + 2 * interval ) )

			if 8 <= index and 0 == index % 2 then
				p:SetSampleProcessing( 1, ( 0.1 >= interval ) and ( ( interval * 10 ) % 2 ) or 0 )
			end
		end

	end,

	Reset = function( self )

		self:Update()

		local x, y, z = self:GetPosition()
		local _, yaw, _ = self:GetOrientation()
		local sizeX, sizeY, sizeZ = self:GetSize()
		local numP = #self.Particles
		local r, g, b = self:GetColor()
		local color, width
		sizeY = math.max( sizeY, sizeZ )

		for index = 1, numP do
			color = 0.5 + 0.5 * ( ( index % 6 ) / 5 )
			width = 0.9 * sizeX * ( index / numP ) + 0.1 * sizeX

			p = self.Particles[index]
			p:SetSize( width, width )
			p:SetPosition( x + math.sin( yaw ) * ( index - 1 ) * 20, y - 0.5 * sizeY + sizeY * ( index / numP ), z + math.cos( yaw ) * ( index - 1 ) * 20 )
			p:SetColor( r * color, g * color, b * color, zo_clamp( color, 0.6, 0.9 ) )
		end

	end

} )
]]
EHT.EffectType:New( 5, "Funnel Cloud", {

	Category = CAT.WEATHER,
	OrderDrawLevelByIndex = false,
	ResetOnScale = true,
	ResetOnPosition = true,
	ResetOnColor = true,

	Init = function( self )
		self:SetSize( 1500, 1500, 1500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 750 )
		self:SetCameraFacing( true )

		local numP = 10
		local c, p

		for index = numP, 1, -1 do
			c = 0.5 + 1 * ( index / numP )
			p = self:AddParticle( "esoui/art/pregameanimatedbackground/smoke_muted_02.dds", 0, -1 + 1 * c, 3 * ( ( index % 2 ) == 0 and 1 or -1 ), 0, 0, 0, c, c, c, 0.9, ( -0.5 + index ) / numP, 3 / numP, true, false, false )
		end

		self:Update()
	end,

	Update = function( self )
		local ps = self.Particles
		local numP = #ps
		local interval, p

		for index = 1, numP do
			p = ps[index]

			interval = GetLinearInterval( 1000 + ( index / numP ) * 5000, 0 )
			p:SetTextureRotation( ( ( 0 == index % 2 ) and 2 or -2 ) * math.pi * interval )

			if 8 <= index and 0 == index % 2 then
				p:SetSampleProcessing( 1, ( ( 0.1 >= interval ) and ( ( interval * 10 ) % 2 ) or 0 ), 0 )
			end

			interval = GetLoopInterval( 1000 + ( index / numP ) * 5000, 0 )
			p:SetColorOffsets( nil, nil, nil, 0.5 + 0.5 * interval )
		end

		self:Update()
	end,

	Reset = function( self )
		local sx, sy, sz = self:GetSize()
		self:SetSize( math.min( sx, math.max( sy, sz ) ) )
		self:Update()
	end

} )

EHT.EffectType:New( 6, "Fireflies, Swarm", {

	Category = CAT.PET,

	Init = function( self )

		local width, height = 1000, 1000
		local p
		local numStars = 10
		local baseOffsetY = 0.5 * numStars * -4
		local heading = GetPlayerCameraHeading()

		for index = 1, numStars do

			p = self:AddParticle( "esoui/art/champion/champion_star_spiral.dds",		0.25 * width * math.sin( 2 * math.pi * ( index / numStars ) ), 0, 0.25 * width * math.cos( 2 * math.pi * ( index / numStars ) ),		0, math.rad( 1 ) + 2 * math.pi * ( ( index - 1 ) / numStars ), math.rad( 91 ),	1, 1, 1, 1,		0.35, 0.35,	true, false )

		end

		self:SetColor( 1, 0.8, 0.5, 1 )
		self:SetSize( width, 0, height )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end,

	Update = function( self )

		local interval = GetLinearInterval( 20000, 0 )
		self:SetOrientation( nil, math.rad( 360 * interval ), nil )

	end,

} )

EHT.EffectType:New( 7, "Magicka Circle", {

	Category = CAT.ANIM,

	CanPitch = true,

	OffsetPitch = math.rad( 90 ),

	Init = function( self )

		local p = self:AddParticle( "esoui/art/champion/champion_star_unlockedconfirm.dds",		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, true )
		p.Texture:SetTextureSampleProcessingWeight( TEX_SAMPLE_PROCESSING_ALPHA_AS_RGB, 0.1 )
		p.Texture:SetTextureSampleProcessingWeight( TEX_SAMPLE_PROCESSING_RGB, 3.3 )

		self:SetSize( 500, 0, 500 )
		self:SetColor( 0.2, 0.6, 0.6, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 50 )

	end,

	Update = function( self )

		local left, right, top, bottom = GetIntervalSurface( 8, 8, 3000, 0 )
		local p = self.Particles[1]
		p:SetTextureCoords( left, right, top, bottom )

	end,

} )

EHT.EffectType:New( 8, "Evergloam Rift", {
	Category = CAT.ANIM,
	CanPitch = true,
	OrderDrawLevelByIndex = true,
	Init = function( self )
		self.IntervalCoefficient = 1 + math.random()
		self.IntervalOffset = 8000 * self.IntervalCoefficient
		self.CoInterval = 14000 * self.IntervalCoefficient
		self:SetSize( 120, 0, 200 )
		self:SetColor( 0.5, 0.45, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetCameraFacing()
		self:SpawnAtPlayer( 200 )
		self:AddParticle( TEXTURES.ETHEREAL_4,					0, 0, 0,		0, 0, 0,				1, 1, 1, 1,		1, 1,		true, false, false	)
		local p = self:AddParticle( TEXTURES.ETHEREAL_4,		0, 0, 0,		0, 0, 0,				1, 1, 1, 1,		1, 1,		true, false, false	)
		p:SetTextureCoords( 0.001, 1.001, 0.001, 1.001 )
		self:Update()
	end,
	Update = function( self )
		local base1, base2 = 0.01, 0.99
		local r, g, b, a = self:GetColor()
		local co1 = 0.5 + 0.5 * GetLoopInterval( self.CoInterval, self.IntervalOffset )
		local co2 = 1.4 - co1

		local i1 = 2 * base1 * GetEasedInterval( 4500, self.IntervalOffset * co1 )
		local i2 = base1 * GetEasedInterval( 4500, ( self.IntervalOffset + 150 ) * co1 )
		local i8 = 2 * base1 * GetEasedInterval( 4500, ( self.IntervalOffset - 75 ) * co2 )
		local i4 = base1 * GetEasedInterval( 4500, ( self.IntervalOffset + 75 ) * co2 )

		local p1, p2 = self.Particles[1], self.Particles[2]
		local tex = p1.Texture
		tex:SetVertexUV( 1, base1 - 2 * i1, base1 + i1 )
		tex:SetVertexUV( 2, base2 + 2 * i2, base1 + i2 )
		tex:SetVertexUV( 4, base1 - 2 * i4, base2 + i4 )
		tex:SetVertexUV( 8, base2 + 2 * i8, base2 + i8 )

		local c1, c2 = ( 0.7 + 0.3 * i1 ) * a, ( 0.7 - 0.3 * i2 ) * a
		local co1, co2, co3 = 1 + 0.1 * i1, 1 + 0.1 * i2, 1 + 0.1 * i4
		p1:SetVertexColors( 1, r * co1, g * co2, b * co3, c1 )
		p1:SetVertexColors( 2, r * co2, g * co3, b * co1, c2 )
		p1:SetVertexColors( 4, r * co3, g * co1, b * co2, c1 )
		p1:SetVertexColors( 8, r * co1, g * co2, b * co3, c2 )
		p2:SetColor( r, g, b, 0.5 + 0.25 * i1 + 0.25 * i2 )

		p1:SetSampleProcessing( 2 + GetLoopInterval( 3000, self.IntervalOffset ) + GetLoopInterval( 7000, self.IntervalOffset ) )
		p2:SetSampleProcessing( 4 - 2 * GetLoopInterval( 4000, self.IntervalOffset ) )
	end,
} )

AddWaterRipplesToEffect( EHT.EffectType:New( 9, "Water, Calm", {

	Category = CAT.LAND,

	CanPitch = true,
	
	Init = function( self )

		local p

		p = self:AddParticle( "art/fx/texture/modelfxtextures/solidblue.dds", 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0, 0.3, 0.3, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 15 )

	end,

	Update = function( self )

		local waterInterval = GetEasedInterval( 10000, 0 )
		self.Particles[1]:SetColorOffsets( nil, nil, nil, 0.9 + 0.06 * waterInterval )
		self:Update()

	end,

} ) )

EHT.EffectType:New( 10, "Water, Aquarium", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( "art/fx/texture/modelfxtextures/solidblue.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.5, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0, 0.3, 0.3, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 56 )

	end,

	Update = function( self )

		local waterInterval = GetEasedInterval( 10000, 0 )
		self.Particles[1]:SetColorOffsets( nil, nil, nil, 0.5 + 0.05 * waterInterval )
		self:Update()

	end,

} )

AddWaterRipplesToEffect( EHT.EffectType:New( 11, "Water, Shallow", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( "art/fx/texture/modelfxtextures/solidblue.dds", 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 0.4, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0, 0.3, 0.3, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 60 )

	end,

	Update = function( self )

		local waterInterval = GetEasedInterval( 10000, 0 )
		self.Particles[1]:SetColorOffsets( nil, nil, nil, 0.4 + 0.1 * waterInterval )
		self:Update()

	end,

} ) )

EHT.EffectType:New( 12, "Void of Sithis", {

	Category = CAT.ANIM,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/champion/champion_center_bg.dds", 	0, 0, 0,	 0, 0, 0, 	0, 0, 0, 1, 	1, 1,	 true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 500, 0, 500 )
		self:SetColor( 0, 0, 0, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 64 )

	end,

} )

-- 07/29/2019
EHT.EffectType:SetDefaultDateAdded( 1564441493 )

AddSkyEffect(
	13, "Aetherius",
	-- Options
	{ },
	-- Side Textures Table
	{
--[[
		{
			Texture = TEXTURES.SOLID,
			Stretch = true, DodgeColor = true, Wrap = true,
			EasedFadeMinInterval = 12000, EasedFadeOffset = 0, EasedFadeDelay = 0,
			R = 0, G = 0.5, B = 1, A = 0.5,
			X1 = 0, X2 = 1, Y1 = 0, Y2 = 1,
			SampleRGB = 1,
		},
		{
			Texture = TEXTURES.SOLID,
			Stretch = true, DodgeColor = true, Wrap = true,
			EasedFadeMinInterval = 12000, EasedFadeOffset = 4000, EasedFadeDelay = 0,
			R = 0.5, G = 1, B = 0.5, A = 0.5,
			X1 = 0.33, X2 = 1.33, Y1 = 0, Y2 = 1,
			SampleRGB = 1,
		},
		{
			Texture = TEXTURES.SOLID,
			Stretch = true, DodgeColor = true, Wrap = true,
			EasedFadeMinInterval = 12000, EasedFadeOffset = 8000, EasedFadeDelay = 0,
			R = 1, G = 0, B = 0, A = 0.5,
			X1 = 0.67, X2 = 1.67, Y1 = 0, Y2 = 1,
			SampleRGB = 1,
		},
]]
		{
			Texture = "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",
			Stretch = true, AddColor = true, Wrap = true,
			EasedFadeMinInterval = 6000, EasedFadeOffset = 0, EasedFadeDelay = 0,
			R = 0.35, G = 0.85, B = 1, A = 0.2,
			X1 = 1.5, X2 = 0.5, Y1 = -0.25, Y2 = 0.75,
			SampleRGB = 2, SampleAlpha = 0.1,
			MaxVertexAlphas = { 0.01, 0.01, 0.5, 0.5 },
		},
		{
			Texture = "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",
			Stretch = true, AddColor = true, Wrap = true,
			EasedFadeMinInterval = 6000, EasedFadeOffset = 4700, EasedFadeDelay = 0,
			R = 0.85, G = 0.35, B = 0.85, A = 0.2,
			X1 = 1.5, X2 = 0.5, Y1 = 0, Y2 = 1,
			SampleRGB = 1.5, SampleAlpha = 0.1,
			MaxVertexAlphas = { 0.01, 0.01, 1, 0.5 },
		},
		{
			Texture = "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",
			Stretch = true, AddColor = true, Wrap = true,
			EasedFadeMinInterval = 6000, EasedFadeOffset = 1400, EasedFadeDelay = 0,
			R = 0.85, G = 0.35, B = 1, A = 0.2,
			X1 = 0, X2 = 1, Y1 = 0.25, Y2 = 1.25,
			SampleRGB = 1.8, SampleAlpha = 0.1,
			MaxVertexAlphas = { 0.01, 0.01, 1, 0.5 },
		},
		{
			Texture = "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",
			Stretch = true, AddColor = true, Wrap = true,
			EasedFadeMinInterval = 6000, EasedFadeOffset = 3000, EasedFadeDelay = 0,
			R = 0.85, G = 1, B = 0.35, A = 0.2,
			X1 = 0, X2 = 1, Y1 = 0, Y2 = 1,
			SampleRGB = 2.2, SampleAlpha = 0.1,
			MaxVertexAlphas = { 0.01, 0.01, 1, 0.5 },
		},
	},
	-- Top Texture Filename
	TEXTURES.SOLID,
	-- Reset Handler
	function( self )
		self.TopTexture:SetHidden( true )
	end,
	-- Update Handler
	nil
)

EHT.EffectType:SetDefaultDateAdded( 1573266112 )

local function AddCurrentsSkyEffect( id, name, options )
	local texture = options.texture or "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds"
	
	local sideTextures =
	{
		{
			Texture = texture,
			Stretch = true, Wrap = true, SampleRGB = 2, SampleAlpha = 0, AddColor = false,
			R = 1, G = 0.5, B = 1, A = 0.2,
			X1 = 0, X2 = 1,
			MaxVertexAlphas = { 0, 0, 1, 1 },
		},
		{
			Texture = texture,
			Stretch = true, Wrap = true, SampleRGB = 2, SampleAlpha = 0, AddColor = false,
			R = 0.5, G = 1, B = 1, A = 0.2,
			X1 = 1, X2 = 0,
			MaxVertexAlphas = { 0, 0, 1, 1 },
		},
		{
			Texture = texture,
			Stretch = true, Wrap = true, SampleRGB = 2, SampleAlpha = 0, AddColor = false,
			R = 1, G = 0.8, B = 0.5, A = 0.2,
			X1 = 1, X2 = 0,
			MaxVertexAlphas = { 0, 0, 1, 1 },
		},
		{
			Texture = texture,
			Stretch = true, Wrap = true, SampleRGB = 2, SampleAlpha = 0, AddColor = false,
			R = 1, G = 0.8, B = 0.5, A = 0.2,
			X1 = 1, X2 = 0,
			MaxVertexAlphas = { 0, 0, 1, 1 },
		},
	}

	if options.backdropTexture then
		local r, g, b, a = unpack( options.backdropColor or { 1, 1, 1, 1 } )
		table.insert( sideTextures,
		{
			Texture = options.backdropTexture,
			Stretch = true, Wrap = true, SampleRGB = 1, SampleAlpha = 0, AddColor = false,
			R = r, G = g, B = b, A = a,
		} )
	end
	
	local skyOptions = { }
	if options.defaultColor then
		skyOptions.R, skyOptions.G, skyOptions.B, skyOptions.A = unpack( options.defaultColor )
	end
	if options.defaultContrast then
		skyOptions.Contrast = options.defaultContrast
	end

	local et = AddSkyEffect(
		id, name,
		-- Options
		skyOptions,
		-- Side Textures Table
		sideTextures,
		-- Top Texture Filename
		nil,
		-- Reset Handler
		function( self )
			self.MasterAlphaInterval = options.alphaInterval or 9000
			self.MasterAlpha = options.alpha
			self.MasterInterval = 2500000 * options.interval
			self.MasterScaleX = ( options.scaleX or 1 ) - 1
			self.MasterScaleY = ( options.scaleY or 1 ) - 1
			self.MasterWaveScale = options.waveScale or 0.15
			self.BackdropFaces = self.TextureFaces[6]
			self.SkyFaces = { self.TextureFaces[2], self.TextureFaces[3], self.TextureFaces[4], self.TextureFaces[5], }
			self.TopFace = self.TextureFaces[1][1]

			if options.backdropTexture or options.topTexture then
				local r, g, b, a
				if options.backdropColor then
					r, g, b, a = unpack( options.backdropColor )
				else
					r, g, b, a = self:GetColor()
					r, g, b = 0.2 * r, 0.2 * g, 0.2 * b
				end

				if options.backdropTexture then
					for _, p in ipairs( self.BackdropFaces ) do
						p:SetVertexColors( 3, r, g, b, 1 )
						p:SetVertexColors( 12, 0, 0, 0, 1 )
					end
				end

				self.TopFace:SetTextureFile( options.backdropTexture )
				self.TopFace:SetColor( r, g, b, 1 )

				if options.topTexture and not self.TopFace2 then
					local tf = self:CloneParticle( self.TopFace )
					self.TopFace2 = tf
					tf:SetTextureFile( options.topTexture )
					tf:SetTextureWrapping( false )
					tf:SetAdditive( true )
					tf:SetAutoDrawLevelEnabled( false )
					tf:SetCanModifyColor( true )
					tf:SetDrawLevel( 2 )

					tf = self:CloneParticle( self.TopFace2 )
					self.TopFace3 = tf
					tf:SetDrawLevel( 3 )
				end
				
				if self.TopFace2 then
					local r, g, b = self:GetColor()
					self.TopFace2:SetPositionAndOrientation( self.TopFace:GetPositionAndOrientation() )
					self.TopFace2:SetColor( r, g, b, 0.2 )
					self.TopFace2:SetSize( self.TopFace:GetSize() )
					self.TopFace3:SetPositionAndOrientation( self.TopFace:GetPositionAndOrientation() )
					self.TopFace3:SetColor( 0.3 * r, 0.3 * g, 0.3 * b, 0.2 )
					self.TopFace3:SetSize( self.TopFace:GetSize() )
					self.TopFace3:SetSampleProcessing( 2, 0 )
				end
			else
				self.TopFace:SetHidden( true )
			end

			local r, g, b = self:GetColor()
			local sampleRGB, sampleAlpha = options.sampleRGB, options.sampleAlpha
			local r1, g1, b1 = r, 0.75 * g, b
			local r2, g2, b2 = 0.75 * r, g, b
			local r3, g3, b3 = r, g, 0.75 * b
			local r4, g4, b4 = 1, 1, 1
			local faces1, faces2, faces3, faces4 = self.SkyFaces[1], self.SkyFaces[2], self.SkyFaces[3], self.SkyFaces[4]
			local numFaces = #faces1

			for index = 1, numFaces do
				local p1, p2, p3, p4 = faces1[index], faces2[index], faces3[index], faces4[index]

				p1:SetVertexColors( 1 + 2, r1, g1, b1, 0 )
				p2:SetVertexColors( 1 + 2, r2, g2, b2, 0 )
				p3:SetVertexColors( 1 + 2, r3, g3, b3, 0 )
				p4:SetVertexColors( 1 + 2, 1, 1, 1, 0 )
				p4:SetVertexColors( 4 + 8, 1, 1, 1, 1 )

				p1:SetSampleProcessing( sampleRGB, sampleAlpha )
				p2:SetSampleProcessing( sampleRGB, sampleAlpha )
				p3:SetSampleProcessing( sampleRGB, sampleAlpha )
				p4:SetSampleProcessing( 1, 0 )
			end
		end,
		-- Update Handler
		function( self )
			local masterAlpha = self.MasterAlpha
			local masterScaleX = self.MasterScaleX
			local masterScaleY = self.MasterScaleY
			local i1 = GetLinearInterval( self.MasterInterval )
			local r, g, b = self:GetColor()
			local r1, g1, b1 = 0.2 + r, -0.1 + g, 0.1 + b
			local r2, g2, b2 = r, 0.1 + g, 0.2 + b
			local r3, g3, b3 = 0.1 + r, g, -0.1 + b
			local r4, g4, b4 = 1, 1, 1
			local alphaInterval = self.MasterAlphaInterval
			local alphaOffset1, alphaOffset2, alphaOffset3 = GetLoopInterval( alphaInterval ), GetLoopInterval( alphaInterval, 4000 ), GetLoopInterval( alphaInterval, 7000 )
			local faces1, faces2, faces3, faces4 = self.SkyFaces[1], self.SkyFaces[2], self.SkyFaces[3], self.SkyFaces[4]
			local numFaces = #faces1

			if self.TopFace2 then
				local interval1 = 0.1 * GetEasedInterval( 7000 )
				local interval2 = 0.03 * GetEasedInterval( 11000 )
				self.TopFace2:SetAlpha( 0.3 + interval1 )
				self.TopFace3:SetAlpha( 0.3 - interval1 )
				self.TopFace2:RotateCoords( 0, 0.5 + interval2, 0.5 + interval2, 0.65 + interval2, 0.6 + interval2 )
				self.TopFace3:RotateCoords( RAD180, 0.5 + interval2, 0.5 + interval2, 0.6 + interval2, 0.65 + interval2 )
			end

			if options.fixedScale then
				local i2 = GetLinearInterval( self.MasterInterval * 1.5 )
				local offsetY1 = self.MasterWaveScale * GetEasedInterval( 36000 )
				local offsetY2 = -offsetY1
				local offsetY3, offsetY4 = 0.5 * offsetY1, 0.25 * offsetY1
				local x1, x2
				if options.bidirectional then
					x1, x2 = i1 + 3.25 + masterScaleX, i1 + 0.25
				else
					x1, x2 = i1 + 0.25, i1 + 3.25 + masterScaleX
				end
				ProjectCylinderTextureFaces( faces1, 0, x1, x2, offsetY2, masterScaleY + offsetY2 + 1 )
				ProjectCylinderTextureFaces( faces2, 0, i1 + 0.5, i1 + 1.5 + masterScaleX, -1.1 + offsetY3, -masterScaleY + -0.1 + offsetY3 )
				if options.bidirectional then
					x1, x2 = i2 + 3 + masterScaleX, i2
				else
					x1, x2 = i2, i2 + 3 + masterScaleX
				end
				ProjectCylinderTextureFaces( faces3, 0, x1, x2, offsetY1, masterScaleY + offsetY1 + 1 )
				ProjectCylinderTextureFaces( faces4, 0, i2 + 0.33, i2 + 2.33 + masterScaleX, -0.33 - offsetY4, -masterScaleY + -1.33 - offsetY4 )
			else
				i1 = 2 * i1
				ProjectCylinderTextureFaces( faces1, 0, 3 * i1, 2 + 3 * i1, 2 * i1, 1 + masterScaleY + 2 * i1 )
				ProjectCylinderTextureFaces( faces2, 0, 0.2 + 4 * i1, 3.2 + 4 * i1, 3 * i1, 1.5 + masterScaleY + 3 * i1 )
				ProjectCylinderTextureFaces( faces3, 0, 0.5 + 5 * i1, 2.5 + 5 * i1, 0.2 + 5 * i1, 1.2 + masterScaleY + 5 * i1 )
				ProjectCylinderTextureFaces( faces4, 0, 7 * i1, 6 + 7 * i1, 4 * i1, 2 + masterScaleY + 4 * i1 )
			end

			for index = 1, numFaces do
				local p1, p2, p3 = faces1[index], faces2[index], faces3[index]
				local ratio1, ratio2 = ( index - 1 ) / numFaces, index / numFaces

				local a1 = masterAlpha * VariableEase( ( alphaOffset1 + ratio1 ) % 1, 1.1 )
				local a2 = masterAlpha * VariableEase( ( alphaOffset1 + ratio2 ) % 1, 1.1 )

				p1:SetVertexColors( 4, r1, g1, b1, a1 )
				p1:SetVertexColors( 8, r1, g1, b1, a2 )

				a1 = masterAlpha * VariableEase( ( alphaOffset2 + ratio1 ) % 1, 1.3 )
				a2 = masterAlpha * VariableEase( ( alphaOffset2 + ratio2 ) % 1, 1.3 )

				p2:SetVertexColors( 4, r2, g2, b2, 0.7 * a1 )
				p2:SetVertexColors( 8, r2, g2, b2, 0.7 * a2 )

				a1 = masterAlpha * VariableEase( ( alphaOffset3 + ratio1 ) % 1, 1.7 )
				a2 = masterAlpha * VariableEase( ( alphaOffset3 + ratio2 ) % 1, 1.7 )

				p3:SetVertexColors( 4, r3, g3, b3, 0.85 * a1 )
				p3:SetVertexColors( 8, r3, g3, b3, 0.85 * a2 )
			end
		end
	)
	return et
end

AddCurrentsSkyEffect( 14, "Witching Hour", {
	alpha = 1,
	interval = 0.1,
	sampleRGB = 2,
	sampleAlpha = 2,
} )

EHT.EffectType:SetDefaultDateAdded( 1500000000 )

AddSkyEffect(
	15, "Void, The",
	-- Options
	{ },
	-- Side Textures Table
	{
		{
			Texture = TEXTURES.SOLID,
			Stretch = true,
			AddColor = false,
			R = 0, G = 0, B = 0, A = 1,
		},
	},
	-- Top Texture Filename
	nil,
	-- Reset Handler
	nil,
	-- Update Handler
	nil
)

EHT.EffectType:New( 16, "Darkness, Veil", {

	Category = CAT.LIGHT,

	Global = true,

	Overlay = true,

	UniqueClass = "Veil of Darkness",

	Init = function( self )

		self:SetAutoDrawLevelEnabled( false )
		self:SetColor( 0.5, 0.5, 0.5, 0.5 )
		self:AddParticle( "", 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, true, false )

		local tex = self.Particles[1].Texture
		tex:SetAnchor( CENTER, GuiRoot, CENTER, 0, 0 )
		tex:SetDimensions( 5500, 3000 )

	end,

	Reset = function( self )

		local r, g, b = self:GetColor()
		local alpha = ( r + g + b ) / 3
		self:SetColor( r, g, b, alpha )
		self:Update()

		zo_callLater( function()
			if not self.Particles then return end

			local tex = self.Particles[1].Texture
			if not tex then return end

			tex:Destroy3DRenderSpace()
			tex:SetAnchor( CENTER, GuiRoot, CENTER, 0, 0 )
			tex:SetDimensions( 5500, 3000 )
			tex:SetDrawLevel( DRAW_LEVEL_OVERLAY_EFFECT )
		end, 1000 )

	end,

} )

EHT.EffectType:New( 17, "Darkness, Carpet", {

	Category = CAT.LIGHT,

	Init = function( self )

		local p

		p = self:AddParticle( "", 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0.5, 0.5, 0.5, 0.5 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 50 )

	end,

	Reset = function( self )

		local r, g, b = self:GetColor()
		local alpha = ( r + g + b ) / 3
		self:SetColor( r, g, b, alpha )

	end,

} )

EHT.EffectType:New( 18, "Darkness, Shaft", {

	Category = CAT.LIGHT,

	Init = function( self )

		local p

		p = self:AddParticle( "", 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0.5, 0.5, 0.5, 0.5 )
		self:SetOrientation( math.rad( 45 ), 0, 0 )
		self:SpawnAtPlayer( 500 )

	end,

	Reset = function( self )

		local r, g, b = self:GetColor()
		local alpha = ( r + g + b ) / 3
		self:SetColor( r, g, b, alpha )

	end,

} )

EHT.EffectType:New( 19, "Darkness, Wall", {

	Category = CAT.LIGHT,

	Init = function( self )

		local p

		p = self:AddParticle( "", 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0.5, 0.5, 0.5, 0.5 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 500 )

	end,

	Reset = function( self )

		local r, g, b = self:GetColor()
		local alpha = ( r + g + b ) / 3
		self:SetColor( r, g, b, alpha )

	end,

} )

AddWaterRipplesToEffect( EHT.EffectType:New( 20, "Water, Gentle Current", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local texWater, texWaves = TEXTURES.WATER_SQUARE, TEXTURES.WATER_1
		local p

		p = self:AddParticle( texWater, 0, 0, 0, math.rad( 90 ), 0, 0, 0.8, 0.8, 0.8, 0.9, 1, 1, true, false, false )

		for index = 1, 2 do
			p = self:AddParticle( texWaves, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false, true )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.4, 0.6, 0.6, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 70 )

	end,

	Update = function( self )

		local colorInterval, sideInterval, waveInterval = 5000, 0.025 * GetEasedInterval( 18000, 0 ), GetLinearInterval( 28000, 0 )
		local p

		p = self.Particles[ 2 ]
		p:SetTextureCoords( sideInterval, 1 + sideInterval, 2 + waveInterval, waveInterval )
		p:SetIntervalVertexColors( 0.6, 0, 0.9, 0, 1, 0, 0.4, 0.2, colorInterval, 0.5 * colorInterval, 400, 200, 200 )

		p = self.Particles[ 3 ]
		p:SetTextureCoords( 0.5 + sideInterval, 2 + sideInterval, 2.5 + waveInterval, 0.5 + waveInterval )
		p:SetIntervalVertexColors( 0.5, 0, 1, 0, 1, 0, 0.4, 0.2, colorInterval, 0, 0, 200, 200 )

	end,

} ) )

AddWaterRipplesToEffect( EHT.EffectType:New( 21, "Water, Mild Current", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local texWater, texWaves = TEXTURES.WATER_SQUARE, TEXTURES.WATER_1
		local p

		p = self:AddParticle( texWater, 0, 0, 0, math.rad( 90 ), 0, 0, 0.8, 0.8, 0.8, 0.9, 1, 1, true, false, false )

		for index = 1, 2 do
			p = self:AddParticle( texWaves, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false, true )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.4, 0.6, 0.6, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 70 )

	end,

	Update = function( self )

		local colorInterval, sideInterval, waveInterval = 4500, 0.05 * GetEasedInterval( 16000, 0 ), GetLinearInterval( 12000, 0 )
		local p

		p = self.Particles[ 2 ]
		p:SetTextureCoords( sideInterval, 1 + sideInterval, 2 + waveInterval, waveInterval )
		p:SetIntervalVertexColors( 0.6, 0, 0.9, 0, 1, 0, 0.4, 0.3, colorInterval, 0.5 * colorInterval, 400, 200, 200 )

		p = self.Particles[ 3 ]
		p:SetTextureCoords( 0.5 + sideInterval, 2 + sideInterval, 2.5 + waveInterval, 0.5 + waveInterval )
		p:SetIntervalVertexColors( 0.5, 0, 1, 0, 1, 0, 0.4, 0.3, colorInterval, 0, 0, 200, 200 )

	end,

} ) )

AddWaterRipplesToEffect( EHT.EffectType:New( 22, "Water, Swift Current", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local texWater, texWaves = TEXTURES.WATER_SQUARE, TEXTURES.WATER_1
		local p

		p = self:AddParticle( texWater, 0, 0, 0, math.rad( 90 ), 0, 0, 0.8, 0.8, 0.8, 0.9, 1, 1, true, false, false )

		for index = 1, 2 do
			p = self:AddParticle( texWaves, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false, true )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.4, 0.6, 0.6, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 70 )

	end,

	Update = function( self )

		local colorInterval, sideInterval, waveInterval = 4000, 0.075 * GetEasedInterval( 14000, 0 ), GetLinearInterval( 6500, 0 )
		local p

		p = self.Particles[ 2 ]
		p:SetTextureCoords( sideInterval, 1 + sideInterval, 1.5 + waveInterval, waveInterval )
		p:SetIntervalVertexColors( 0.6, 0, 0.9, 0, 1, 0, 0.4, 0.3, colorInterval, 0.5 * colorInterval, 400, 200, 200 )

		p = self.Particles[ 3 ]
		p:SetTextureCoords( 0.5 + sideInterval, 2 + sideInterval, 2 + waveInterval, 0.5 + waveInterval )
		p:SetIntervalVertexColors( 0.5, 0, 1, 0, 1, 0, 0.4, 0.3, colorInterval, 0, 0, 200, 200 )

	end,

} ) )

AddWaterRipplesToEffect( EHT.EffectType:New( 23, "Water, Rapids", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local texWater, texWaves = TEXTURES.WATER_SQUARE, TEXTURES.WATER_1
		local p

		p = self:AddParticle( texWater, 0, 0, 0, math.rad( 90 ), 0, 0, 0.8, 0.8, 0.8, 0.9, 1, 1, true, false, false )

		for index = 1, 2 do
			p = self:AddParticle( texWaves, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false, true )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.4, 0.6, 0.6, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 70 )

	end,

	Update = function( self )

		local colorInterval, sideInterval, waveInterval = 3000, 0.1 * GetEasedInterval( 13000, 0 ), GetLinearInterval( 3000, 0 )
		local p

		p = self.Particles[ 2 ]
		p:SetTextureCoords( sideInterval, 1 + sideInterval, 1 + waveInterval, waveInterval )
		p:SetIntervalVertexColors( 0.6, 0, 0.9, 0, 1, 0, 0.4, 0.3, colorInterval, 0.5 * colorInterval, 400, 200, 200 )

		p = self.Particles[ 3 ]
		p:SetTextureCoords( 0.5 + sideInterval, 2 + sideInterval, 1.5 + waveInterval, 0.5 + waveInterval )
		p:SetIntervalVertexColors( 0.5, 0, 1, 0, 1, 0, 0.4, 0.3, colorInterval, 0, 0, 200, 200 )

	end,

} ) )

AddRandomizedParticleEffect( 24, "Snowfall, Light", CAT.WEATHER, TEXTURES.SNOWFLAKE_1,
	50000, 4000, 4000,		1, 1, 1, 1,		0, 0.49, 0,				0.5, 0, 0.5,	2, 0.475, 2,	0.1, 50, 80, true,			60000, 60000,
	3, 6, 0, 0,				0.8, 5,			0.9, 0.9, 0.9, 0,		1, 1, 1, 0.4,	0, 0.6,			10, math.pi, nil, nil,		-15, -100, -15,		15, -200, 15,		20 )

EHT.EffectType:New( 25, "Sigil, Summoning", {
	Category = CAT.SIGIL,
	CanPitch = true,
	EnhanceContrast = true,
	Init = function( self )
		local p

		p = self:AddParticle( TEXTURES.SIGIL_15,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 0.5, 1, 0.5,		0.5, 0.5,	true, false, false )
		p:SetSampleProcessing( 3, 0 )

		p = self:AddParticle( TEXTURES.SIGIL_16,		0, 0, 0,	math.rad( 90 ), 0, 0,	0.5, 1, 1, 0.5,		0.5, 0.5,	true, false, false )
		p:SetSampleProcessing( 3, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1500, 0, 1500 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 40 )
		self.PulseInterval = 10000 + math.random() * 10000
	end,
	Update = function( self )
		local angle = 2 * math.pi * GetLinearInterval( 20000 )

		for index = 1, #self.Particles do
			p = self.Particles[index]
			p:SetTextureRotation( angle )
		end

		local a1, a2 = GetEasedInterval( 6000, 0 ), GetEasedInterval( 6000, 3000 )
		self.Particles[1]:SetAlpha( 0.6 + a1 * 0.5 )
		self.Particles[2]:SetAlpha( 0.6 + a2 * 0.5 )
	end,
} )

EHT.EffectType:New( 26, "Sigil, Inscription", {
	Category = CAT.SIGIL,
	CanPitch = true,
	EnhanceContrast = true,
	Init = function( self )
		local p

		p = self:AddParticle( TEXTURES.SIGIL_7,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 500, 0, 500 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 54 )
		self.PulseInterval = 10000 + math.random() * 10000
	end,
	Update = function( self )
		local p

		p = self.Particles[ 1 ]
		p:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )

		self:Update()
	end,
} )

EHT.EffectType:New( 27, "Sigil, Invocation", {
	Category = CAT.SIGIL,
	CanPitch = true,
	EnhanceContrast = true,
	Init = function( self )
		local p

		p = self:AddParticle( TEXTURES.SIGIL_6,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false, false )
		p:SetSampleProcessing( 3, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 58 )
		self.PulseInterval = 10000 + math.random() * 10000
	end,
	Update = function( self )
		local interval = GetEasedInterval( self.PulseInterval )
		local p

		p = self.Particles[1]
		p:SetTextureRotation( math.rad( 360 * GetLinearInterval( 20000 ) ) )
		p:SetSampleProcessing( 1.5 + interval, 0 )
		p:SetAlpha( 0.8 + 0.3 * interval )
	end,
	Reset = function( self )
		self:Update()
	end,
} )

EHT.EffectType:New( 28, "Sigil, Binding", {

	Category = CAT.SIGIL,

	CanPitch = true,

	EnhanceContrast = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SIGIL_5,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 62 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	Update = function( self )

		local p

		p = self.Particles[ 1 ]
		p:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )

		self:Update()

	end,

} )

EHT.EffectType:New( 29, "Sigil, Translocate", {

	Category = CAT.SIGIL,

	CanPitch = true,

	EnhanceContrast = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SIGIL_4,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 66 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	Update = function( self )

		local p

		p = self.Particles[ 1 ]
		p:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )

		self:Update()

	end,

} )

EHT.EffectType:New( 30, "Sigil, Daedric", {

	Category = CAT.SIGIL,

	CanPitch = true,

	EnhanceContrast = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SIGIL_3,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 70 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	function( self )

		local p

		p = self.Particles[ 1 ]
		p:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )

		self:Update()

	end,

} )

EHT.EffectType:New( 31, "Sigil, Darkness", {

	Category = CAT.SIGIL,

	CanPitch = true,

	EnhanceContrast = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SIGIL_2,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 74 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	Update = function( self )

		local p

		p = self.Particles[ 1 ]
		p:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )

		self:Update()

	end,

} )

EHT.EffectType:New( 32, "Sigil, Druidic", {

	Category = CAT.SIGIL,

	CanPitch = true,

	EnhanceContrast = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SIGIL_1,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 78 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	Update = function( self )

		local p

		p = self.Particles[ 1 ]
		p:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )

		self:Update()

	end,

} )

EHT.EffectType:New( 33, "Sigil, Elemental", {

	Category = CAT.SIGIL,

	CanPitch = true,

	EnhanceContrast = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SIGIL_8,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 82 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	Update = function( self )

		local p

		p = self.Particles[ 1 ]
		p:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )

		self:Update()

	end,

} )

EHT.EffectType:New( 34, "Sigil, Spellcraft", {

	Category = CAT.SIGIL,

	CanPitch = true,

	EnhanceContrast = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SIGIL_14,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 1000, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 550 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	Update = function( self )

		local p

		p = self.Particles[ 1 ]
		p:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )

		self:Update()

	end,

} )

EHT.EffectType:New( 35, "Sigil, Aedric", {

	Category = CAT.SIGIL,

	CanPitch = true,

	EnhanceContrast = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.SIGIL_9,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 86 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	Update = function( self )

		self.Particles[1]:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )
		self:Update()

	end,

} )

EHT.EffectType:New( 36, "Sigil, Arcane", {

	Category = CAT.SIGIL,

	CanPitch = true,

	EnhanceContrast = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SIGIL_13,		0, 0, 0,		math.rad( 90 ), 0, 0,		1, 1, 1, 1,		0.5, 0.5,		true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 90 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	Update = function( self )

		local p

		p = self.Particles[ 1 ]
		p:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )

		self:Update()

	end,

} )

EHT.EffectType:New( 37, "Sigil, Triquetra", {

	Category = CAT.SIGIL,

	CanPitch = true,

	EnhanceContrast = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SIGIL_10,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 94 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	Update = function( self )

		self.Particles[ 1 ]:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )
		self:Update()

	end,

} )

EHT.EffectType:New( 38, "Evergloam Wisps", {

	Category = CAT.ANIM,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( "art/fx/texture/crackglowing_02.dds",		0, 0, 0,		0, 0, 0,	1, 1, 1, 1,		0, 0,	true, false	)
		p:SetTextureWrapping( false )
		p:SetSampleProcessing( 3.3, 0.1 )
		p:SetTextureCoords( 0, 1, 0.2, 0.75 )

		self.FacingDirection = 2 * math.random()
		self.VisibleInterval = 10000 + 5000 * math.random()
		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0.2, 0.95, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 1000 )
		self:Update()

	end,

	Update = function( self )

		local p, visible, alpha, eX, eY, eZ, x, y, z, angle, offsetX, offsetY
		local sizeX, sizeY, sizeZ = self:GetSize()
		local index = 1

		p = self.Particles[ index ]
		visible = 0.25 < GetLinearInterval( self.VisibleInterval )

		if not visible then
			_, _, _, alpha = p:GetColorOffsets()

			if 0 < alpha then
				p:SetColorOffsets( nil, nil, nil, alpha - 0.05 )
			else
				self.VisibleInterval = 10000 + 5000 * math.random()
				self.FacingDirection = 2 * math.random()
			end
		else
			_, _, _, alpha = p:GetColorOffsets()

			if 0 >= alpha then
				p:SetPositionOffsets( -0.5 * sizeX + sizeX * math.random(), -0.5 * sizeY + sizeY * math.random(), -0.5 * sizeZ + sizeZ * math.random() )
			end

			if 1 > alpha then
				p:SetColorOffsets( nil, nil, nil, alpha + 0.05 )
			end

			offsetX, offsetY = math.abs( GetEasedInterval( 13800 ) ), math.abs( GetEasedInterval( 19150 ) )
			p:SetSizeOffsets( 0.6 + 0.2 * offsetX, 0.6 + 0.6 * offsetY )
			--p:SetTextureCoords( 0.2 + 0.2 * math.abs( GetEasedInterval( 6000, 500 * index ) ), 0.2 + 0.5 * math.abs( GetEasedInterval( 6000, 500 * index ) ) )

			eX, eY, eZ = self:GetPosition()
			x, y, z = p:GetPositionOffsets()
			_, angle = EHT.World:GetDistanceAndAngleFromPlayer( eX + x, eY + y, eZ + z )
			p:SetOrientationOffsets( 0, angle + ( 1 > self.FacingDirection and 0 or math.rad( 180 ) ), 0 )
		end

		self:Update()

	end,

} )

EHT.EffectType:New( 39, "New Life Tree, Modern", {

	Category = CAT.LAND,

	Init = function( self )

		self:SetColor( 0, 0.6, 0, 1 )
		self:SetSize( 500, 2000, 2000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 200 )
		self.PrevSizeX, self.PrevSizeY = 0, 0

		local icon = "esoui/art/icons/housing_veg_bsh_deshaanrockbush001.dds"
		local itemScaleWidth, itemScaleHeight, rgbWeight, alphaWeight = 0.4, 0.1, 1, 2
		local p

		for index = 1, 120 do

			p = self:AddParticle( icon,		0, 0, 0,	0, 0, 0,	0.5, 0.5, 0.5, 1,		itemScaleWidth, itemScaleHeight,	true, false )
			p:SetSampleProcessing( rgbWeight, alphaWeight )
			p:SetTextureWrapping( false )
			p:SetTextureCoords( 0, 1, 1, 0 )

		end

	end,

	Update = function( self )

		local sizeX, sizeY = self:GetSize()
		if sizeX ~= self.PrevSizeX or sizeY ~= self.PrevSizeY then

			self.PrevSizeX, self.PrevSizeY = sizeX, sizeY

			local radius, p
			local theta = 2 * math.pi
			local heightRatio = 1 / 40
			local baseHeight = 0
			local width, height = self:GetSize()
			local texIndex = 1

			radius = self:GetSize()
			radius = radius * 2

			for index = 0.01, 1, heightRatio do

				p = self.Particles[ texIndex ]
				texIndex = texIndex + 1

				p:SetPositionOffsets( radius * math.sin( theta * index ), baseHeight + height * index, radius * math.cos( theta * index ) )
				p:SetOrientationOffsets( 0, theta * index, 0 )

				radius = radius * ( 1 - heightRatio )

			end

			radius = self:GetSize()
			radius = radius * 2

			for index = 0.01, 1, heightRatio do

				p = self.Particles[ texIndex ]
				texIndex = texIndex + 1

				p:SetPositionOffsets( ( 5 + radius ) * math.sin( theta * ( 0.33 + index ) ), baseHeight + height * index, ( 5 + radius ) * math.cos( theta * ( 0.33 + index ) ) )
				p:SetOrientationOffsets( math.rad( 180 ), math.rad( 180 ) + theta * ( 0.33 + index ), 0 )

				radius = radius * ( 1 - heightRatio )

			end

			radius = self:GetSize()
			radius = radius * 2

			for index = 0.01, 1, heightRatio do

				p = self.Particles[ texIndex ]
				texIndex = texIndex + 1

				p:SetPositionOffsets( radius * math.sin( theta * ( 0.67 + index ) ), baseHeight + height * index, radius * math.cos( theta * ( 0.67 + index ) ) )
				p:SetOrientationOffsets( 0, theta * ( 0.67 + index ), 0 )

				radius = radius * ( 1 - heightRatio )

			end

			self:Update()

		end
	
	end,

} )

EHT.EffectType:New( 40, "Bonesnap Binding Bubble", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.BUBBLE_1,				0, 0, 0,	0, 0, 0,	1, 1, 1, 0.5,		1, 1,	true, true )
		p:SetSampleProcessing( 1.5, 1 )
		p:SetTextureWrapping( false )

		p = self:AddParticle( TEXTURES.BUBBLE_HIGHLIGHT,		0, 0, 0,	0, 0, 0,	1, 1, 1, 0.5,		1, 1,	true, true )
		p:SetSampleProcessing( 1, 0.5 )
		p:SetTextureWrapping( false )

		p = self:AddParticle( TEXTURES.BUBBLE_1,				0, 0, 0,	0, 0, 0,	1, 1, 1, 0.5,		1, 1,	true, true )
		p:SetSampleProcessing( 1.5, 1 )
		p:SetTextureWrapping( false )

		self:SetColor( 0, 0.5, 0.7, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 200 )

	end,

	Update = function( self )

		local angle = GetPlayerCameraHeading()
		local x, y, z = self:GetPosition()
		local playerX, playerY, playerZ = GetPlayerWorldPositionInHouse()
		local relativePitch = zo_clamp( -( math.rad( 90 ) - math.atan2( math.sqrt( ( ( x - playerX ) * ( x - playerX ) ) + ( ( z - playerZ ) * ( z - playerZ ) ) ), math.abs( y - playerY ) ) ), 0, math.rad( -45 ) )
		self:SetOrientation( relativePitch, angle, 0 )

	end,

} )

local EFFECT_TYPE_EXTENSIONS =
{
	["ForegroundParticles"] =
	{
		Init = function(baseFunction, data, self)
			if baseFunction then
				baseFunction(self)
			end

			self.ForegroundParticles = {}
			local textureIndex = 1
			for index = 1, data.numParticles do
				local texture = data.textures[textureIndex]
				textureIndex = 1 + ((textureIndex + 1) % #data.textures)
				local p = self:AddParticle2D(texture,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, true)
				table.insert(self.ForegroundParticles, p)
			end

			EHT.RegisterTemporaryUpdateEvent("EHT.Effect.ForegroundParticles", 1, function()
				EHT.ForegroundParticleNoiseX = math.sin(((FrameTime % 3000) / 3000) * RAD360)
				EHT.ForegroundParticleNoiseY = math.cos(((FrameTime % 3900) / 3900) * RAD360)
			end)
		end,
		Update = function(baseFunction, data, self)
			if baseFunction then
				baseFunction(self)
			end

			local noiseX, noiseY = EHT.ForegroundParticleNoiseX, EHT.ForegroundParticleNoiseY
			for index, p in ipairs(self.ForegroundParticles) do
				
			end
		end,
	},
}

function AddEffectTypeExtension(data, effectType)
	local extensionType = EFFECT_TYPE_EXTENSIONS[data.extensionType]
	if not extensionType then
		df("Failed to add effect type extension for effect type %s.", effectType:GetName())
		return effectType
	end

	if extensionType.Init then
		local originalFunction = effectType.Init
		effectType.Init = function(...)
			return extensionType.Init(originalFunction, data, ...)
		end
	end

	if extensionType.Update then
		local originalFunction = effectType.Update
		effectType.Update = function(...)
			return extensionType.Update(originalFunction, data, ...)
		end
	end

	if extensionType.Reset then
		local originalFunction = effectType.Reset
		effectType.Reset = function(...)
			return extensionType.Reset(originalFunction, data, ...)
		end
	end

	return effectType
end

local extensionData =
{
	extensionType = "ForegroundParticles",
	textures = {TEXTURES.SNOWFLAKE_1,},
	minInterval = 500,
	maxInterval = 1500,
	minScale = 0.01,
	maxScale = 0.025,
	minVector = {-1, 0.5},
	maxVector = {1, 1},
	minVectorNoise = 0.2,
	maxVectorNoise = 0.5,
}
--[[
AddEffectTypeExtension(extensionData, AddRandomizedParticleEffect( 41, "Snowfall, Moderate", CAT.WEATHER, TEXTURES.SNOWFLAKE_1,
	50000, 4000, 4000,		1, 1, 1, 1,		0, 0.49, 0,				0.5, 0, 0.5,	2, 0.475, 2,	0.4, 10, 20, true,			60000, 60000,
	8, 14, 0, 0,			0.8, 5,			0.9, 0.9, 0.9, 0,		1, 1, 1, 0.4,	0, 0.6,			20, math.pi, nil, nil,		-150, -300, -150,	150, -100, 150,		50 ))

AddEffectTypeExtension(extensionData, AddRandomizedParticleEffect( 42, "Snowfall, Heavy", CAT.WEATHER, TEXTURES.SNOWFLAKE_1,
	50000, 4000, 4000,		1, 1, 1, 1,		0, 0.49, 0,				0.5, 0, 0.5,	2, 0.475, 2,	10, 20, 40, true,			60000, 60000,
	10, 16, 0, 0,			0.8, 5,			0.9, 0.9, 0.9, 0,		1, 1, 1, 0.4,	0, 0.6,			50, math.pi, nil, nil,		-450, -600, -450,	450, -150, 450,		200 ))
]]
AddRandomizedParticleEffect( 41, "Snowfall, Moderate", CAT.WEATHER, TEXTURES.SNOWFLAKE_1,
	50000, 4000, 4000,		1, 1, 1, 1,		0, 0.49, 0,				0.5, 0, 0.5,	2, 0.475, 2,	0.4, 100, 200, true,		60000, 60000,
	8, 14, 0, 0,			0.8, 5,			0.9, 0.9, 0.9, 0,		1, 1, 1, 0.4,	0, 0.6,			20, math.pi, nil, nil,		-150, -300, -150,	150, -100, 150,		50 )

AddRandomizedParticleEffect( 42, "Snowfall, Heavy", CAT.WEATHER, TEXTURES.SNOWFLAKE_1,
	50000, 4000, 4000,		1, 1, 1, 1,		0, 0.49, 0,				0.5, 0, 0.5,	2, 0.475, 2,	10, 150, 300, true,			60000, 60000,
	10, 16, 0, 0,			0.8, 5,			0.9, 0.9, 0.9, 0,		1, 1, 1, 0.4,	0, 0.6,			50, math.pi, nil, nil,		-450, -600, -450,	450, -150, 450,		200 )

AddParticleGeneratorEffect(
	43, "Sparkles (Rising), Sparse", nil, nil, nil,
	500, 1000,
	0, 1, 1, 0.5,
	32, 3,
	-2, -6,
	-2, 2, -2, 2 )

AddParticleGeneratorEffect(
	44, "Sparkles (Rising), Moderate", nil, nil, nil,
	500, 1000,
	0, 1, 1, 0.6,
	16, 4,
	-2, -6,
	-2, 2, -2, 2 )

AddParticleGeneratorEffect(
	45, "Sparkles (Rising), Dense", nil, nil, nil,
	500, 1000,
	0, 1, 1, 0.7,
	8, 4,
	-2, -6,
	-2, 2, -2, 2 )

AddParticleGeneratorEffect(
	46, "Sparkles (Falling), Sparse", nil, nil, nil,
	500, 1000,
	0, 1, 1, 0.5,
	32, 3,
	2, 6,
	-2, 2, -2, 2 )

AddParticleGeneratorEffect(
	47, "Sparkles (Falling), Moderate", nil, nil, nil,
	500, 1000,
	0, 1, 1, 0.6,
	16, 4,
	2, 6,
	-2, 2, -2, 2 )

AddParticleGeneratorEffect(
	48, "Sparkles (Falling), Dense", nil, nil, nil,
	500, 1000,
	0, 1, 1, 0.7,
	8, 4,
	2, 6,
	-2, 2, -2, 2 )

AddParticleGeneratorEffect( 49, "Sparkles (Exploding), Sparse", nil, nil, nil,		400, 400,		0, 1, 1, 0.5,	32, 3,		-5, 5,		-20, 20, -20, 20 )
AddParticleGeneratorEffect( 50, "Sparkles (Exploding), Moderate", nil, nil, nil,	600, 600,		0, 1, 1, 0.6,	16, 4,		-10, 10,	-20, 20, -20, 20 )
AddParticleGeneratorEffect( 51, "Sparkles (Exploding), Dense", nil, nil, nil,		800, 800,		0, 1, 1, 0.7,	8, 4,		-25, 25,	-25, 25, -25, 25 )

do
	local function OnUpdate( self )
		local interval = 2 * math.pi * GetLinearInterval( 2500 )
		local x, y = 8 * math.sin( interval ), 8 * math.cos( interval )
		local a = self.Animation

		a.MinDriftX, a.MaxDriftOffsetX = x, x
		a.MinSpeed, a.MaxSpeedOffset = y, y
	end

	AddParticleGeneratorEffect( 52, "Fireworks, Pinwheel", nil, nil, OnUpdate,		1000, 1000,		0, 1, 1, 0.7,		32, 12,		-25, 25,	-25, 25, -2, 2, 2000, 3000 )
end

EHT.EffectType:New( 53, "Fireworks, Explosion", {

	Category = CAT.ANIM,

	Init = function( self )

		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0.5, 1, 1, 1 )
		self:SpawnAtPlayer( 750 )

	end,

	Update = function( self )

		if self.Emitter then self.Emitter:Update() end

		local ft = FrameTime
		if self.NextInterval and ft >= self.NextInterval then
			self.IntervalEnd, self.NextInterval = ft + 1000, ft + math.random( 12000, 16000 )
			self.Emitter.MinActiveEmissions, self.Emitter.MaxActiveEmissions = 1, 40

			if self:GetPlayerDistance() <= 2500 then PlaySound( "GiftInventoryView_FanfareSparks" ) end
		elseif self.IntervalEnd and ft >= self.IntervalEnd then
			self.Emitter.MinActiveEmissions, self.Emitter.MaxActiveEmissions = 0, 0
		end

	end,

	Reset = function( self )

		self:Update()

		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()

		if sy < sx then
			sy = sx
			self:SetSize( sx, sy, sz )
		end

		local velocity = zo_clamp( 0.5 * sx, 10, 400 )
		local maxRadius

		local o = { }
		o.Texture = TEXTURES.CIRCLE_SOFT

		o.EmissionX, o.EmissionY, o.EmissionZ = x, y, z
		o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.RANDOM, 0, 0
		o.EmissionFrequency = 25

		o.MinActiveEmissions, o.MaxActiveEmissions, o.ReuseActiveEmissions = 1, 100, false
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0, 0, 0
		o.MaxOffsetY = sy

		local v = sx / 4
		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
		o.MinVectorX, o.MinVectorY, o.MinVectorZ = -v, -v, -v
		o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = v, v, v
		o.WindFactor = 0

		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r - 0.08, g - 0.08, b - 0.08, 1
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r + 0.08, g + 0.08, b + 0.08, 1
		o.ColorShift, o.AlphaShift = -0.5, -1

		o.MinSize, o.MaxSize = zo_clamp( ( sx / 500 ) * 6, 9, 90 ), zo_clamp( ( sx / 500 ) * 7, 10, 100 )
		o.MinGrowth, o.MaxGrowth = -0.5 * o.MinSize, 0
		o.MinTTL, o.MaxTTL, o.AutoOrientation, o.Yaw = 4000, 5000, EHT.ParticleEmitter.ORIENTATIONS.CAMERA, yaw
		o.GravityCoefficient = 1

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end

		local ft = FrameTime
		self.IntervalEnd, self.NextInterval = ft + 1400, ft + math.random( 12000, 16000 )

	end,

} )

EHT.EffectType:New( 54, "Technicolor", {

	Category = CAT.LIGHT,

	Global = true,

	Overlay = true,

	Init = function( self )

		self:SetAutoDrawLevelEnabled( false )
		self:SetColor( 0.5, 0, 0.5, 1 )
		local tex = self:AddParticle( "", 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.3, 1, 1, true, false ).Texture

	end,

	Reset = function( self )

		self:Update()
		local tex = self.Particles[1].Texture
		zo_callLater( function()
			tex:Destroy3DRenderSpace()
			tex:SetAnchor( CENTER, GuiRoot, CENTER, 0, 0 )
			tex:SetDimensions( 5500, 3000 )
			tex:SetDrawLevel( DRAW_LEVEL_OVERLAY_EFFECT )
		end, 1000 )

	end,

} )

AddSkyEffect(
	55, "Stars, 1",
	-- Options
	{ },
	-- Side Textures Table
	{
		{
			Texture = TEXTURES.SKY_STARS_3,
			Stretch = true, Wrap = true, SampleRGB = 1, SampleAlpha = 0, 
			R = 1, G = 1, B = 1, A = 1,
			X1 = 0, X2 = 2, Y1 = 0, Y2 = 1,
			MaxVertexAlphas = { 1, 1, 1, 1 },
		},
		{ Texture = TEXTURES.BLACK, Stretch = true, R = 0, G = 0, B = 0, A = 1, },
	},
	-- Top Texture Filename
	TEXTURES.SKY_STARS_1,
	-- Reset Handler
	function( self )
		local r, g, b = self:GetColor()
		local p = self.TextureFaces[1][1]

		p:SetSampleProcessing( 0.5, 0 )
		p:SetColor( 0.5 + 0.5 * r, 0.5 + 0.5 * g, 0.5 + 0.5 * b, 1 )

		for _, face in ipairs( self.TextureFaces[2] ) do
			face:SetAlpha( 0.1 )
		end
	end,
	-- Update Handler
	function( self )
		local int1, int2 = 0.5 * GetLoopInterval( 10000, 0 ), 0.5 * GetLoopInterval( 17300, 0 )
		local sample = 0.75 + 0.5 * ( int1 + int2 )

		for index, face in ipairs( self.TextureFaces[2] ) do
			face:SetSampleProcessing( sample, 0 )
		end
	end
)

EHT.EffectType:New( 56, "Laser, Steady", {

	Category = CAT.ANIM,

	Init = function( self )

		local p = self:AddParticle( "art/fx/texture/glowsubtlemulticolor.dds",		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		1, 1,	true, true )
		p:SetSampleProcessing( 1, 1.4 )

		self:SetColor( 1, 0, 1, 1 )
		self:SetSize( 50, 0, 2000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 500 )

	end,

} )

EHT.EffectType:New( 57, "Laser, Pulsating", {

	Category = CAT.ANIM,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( "art/fx/texture/glowsubtlemulticolor.dds",		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		1, 1,	true, true )

		self:SetColor( 1, 0, 1, 1 )
		self:SetSize( 50, 0, 2000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 500 )
		self.Seed = 1000 * math.random()

	end,

	Update = function( self )

		local flicker = ( 0.5 * math.abs( GetEasedInterval( 298, self.Seed ) ) + 0.5 * math.abs( GetEasedInterval( 487, self.Seed ) ) + 0.5 * math.abs( GetEasedInterval( 903, self.Seed ) ) )
		local p = self.Particles[1]

		if 0.45 < flicker then
			p:SetSampleProcessing( 1, 1 + flicker )
		else
			p:SetSampleProcessing( 1, 1.2 )
		end

	end,

} )

AddSkyEffect(
	58, "Dark Aether",
	-- Options
	{ },
	-- Side Textures Table
	{
		-- Color Dodge texture faces.
		{
			Texture = TEXTURES.SOLID,
			Stretch = true, DodgeColor = true, Wrap = true,
			R = 0, G = 0, B = 0, A = 0.5, SampleRGB = 0, SampleAlpha = 1.5,
			MaxVertexAlphas = { 1, 1, 0, 0 },
		},
		{
			Texture = TEXTURES.SMOKE_1_TILE,
			Stretch = true, AddColor = false, Wrap = true,
			R = 1, G = 0, B = 0, A = 0.3, SampleRGB = 1, SampleAlpha = 0,
			X1 = 0, X2 = 1, Y1 = 0, Y2 = 1,
			MaxVertexAlphas = { 0, 0, 0.3, 0.3 },
		},
		{
			Texture = TEXTURES.SMOKE_1_TILE,
			Stretch = true, AddColor = false, Wrap = true,
			R = 0, G = 1, B = 0, A = 0.3, SampleRGB = 1, SampleAlpha = 0,
			X1 = 0.25, X2 = 1.25, Y1 = 0, Y2 = 1,
			MaxVertexAlphas = { 0, 0, 0.3, 0.3 },
		},
		{
			Texture = TEXTURES.SMOKE_1_TILE,
			Stretch = true, AddColor = false, Wrap = true,
			R = 0, G = 0, B = 1, A = 0.3, SampleRGB = 1, SampleAlpha = 0,
			X1 = 0.5, X2 = 1.5, Y1 = 0, Y2 = 1,
			MaxVertexAlphas = { 0, 0, 0.3, 0.3 },
		},
		{ Texture = TEXTURES.SOLID, Stretch = true, R = 0, G = 0, B = 0, A = 1, CanModifyColor = false, },
	},
	-- Top Texture Filename
	TEXTURES.BLACK,
	-- Reset Handler
	nil,
	-- Update Handler
	function( self )
		local r1, g1, b1 = GetEasedInterval( 3000, 0 ), GetEasedInterval( 4500, 1000 ), GetEasedInterval( 5000, 2000 )
		local r2, g2, b2 = 1 - r1, 1 - g1, 1 - b1
		local faces = self.TextureFaces[ 2 ]	-- Color Dodge texture faces.

		r1, g1, b1 = 0.5 * r1, 0.5 * g1, 0.5 * b1
		r2, g2, b2 = 0.5 * r2, 0.5 * g2, 0.5 * b2

		for index, face in ipairs( faces ) do
			face:SetVertexColors( 1 + 2, r1, g1, b1, 0.5 )
			face:SetVertexColors( 4 + 8, r2, g2, b2, 0.5 )
		end
	end
)

EHT.EffectType:New( 59, "Sigil, Imperial", {

	Category = CAT.SIGIL,

	EnhanceContrast = true,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.SIGIL_11,		0, 0, 0,	math.rad( 0 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 3, 3 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 618 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	Update = function( self )

		self.Particles[ 1 ]:SetColorOffsets( nil, nil, nil, 1.5 - math.abs( GetEasedInterval( self.PulseInterval ) ) )
		self:Update()

	end,

} )

EHT.EffectType:New( 60, "Sigil, Tablet", {

	Category = CAT.SIGIL,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.SIGIL_12,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		0.5, 0.5,	true, false )
		p:SetSampleProcessing( 1, 1 )
		p:SetTextureWrapping( false )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 1000, 0, 1000 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 180 )
		self.PulseInterval = 10000 + math.random() * 10000

	end,
	
	Update = function( self )

		self.Particles[1]:SetSampleProcessing( 1, GetEasedInterval( self.PulseInterval ) )

	end,

} )

local function AddFogEffect( id, name, alphaCoefficient, minScale, scaleRange, defaultInterval )
	local et = EHT.EffectType:New( id, name, {
		Category = CAT.WEATHER,
		CanPitch = true,
		ResetOnOrient = true, ResetOnPosition = true, ResetOnScale = true,
		Init = function( self )
			self.IntervalOffset = math.random( 0, defaultInterval )
			self.IntervalDuration = defaultInterval
			self.AlphaCoefficient = alphaCoefficient

			local numP = 8
			local partition = numP * 0.7
			local p

			for index = 1, numP do
				p = self:AddParticle( TEXTURES.SMOKE_4,		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 0,		1, 1,	true, false, false )
				p:SetSampleProcessing( 1, 0 )
				p.IntervalOffset = self.IntervalOffset + ( index / partition ) * self.IntervalDuration
				p.IntervalDuration = self.IntervalDuration -- * ( 0.5 + ( index / numP ) )
				p.FogTheta, p.FogVecScale, p.FogVecX, p.FogVecY, p.FogScale = 0, 0, 0, 0, 0
				p.ColorVertex = 1
				p.FogDirty = true
			end

			self:SetColor( 0.9, 1, 1, 1 )
			self:SetSize( 4000, 0, 4000 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 50 )
		end,
		Update = function( self )
			local globalInterval = GetLinearInterval( self.IntervalDuration )
			local eR, eG, eB = self:GetColor()
			local numP = #self.Particles
			local ac = self.AlphaCoefficient

			for index = 1, numP do
				local p = self.Particles[index]
				local interval = GetLinearInterval( p.IntervalDuration, p.IntervalOffset )
				local easedInterval = math.sin( interval * 1.2 * math.pi )

				if 0 > easedInterval or p.FogDirty then
					local cR, cG, cB, cA = 0.7 + 0.3 * math.random(), 0.7 + 0.3 * math.random(), 0.7 + 0.3 * math.random(), 0.5 + 0.5 * math.random()
					local scale = minScale + scaleRange * math.random()
					local range = ( 1 - scale ) * 0.5
					local offsetX = 0 == range and 0.5 or ( 0.5 - range + 2 * range * math.random() )
					local offsetY = 0 == range and 0.5 or ( 0.5 - range + 2 * range * math.random() )

					p.FogDirty = false
					p:SetColorOffsets( cR * eR, cG * eG, cB * eB, cA )
					p:SetSampleProcessing( 0.9 + 0.2 * math.random(), 0 )
					p.ColorVertex = math.random( 1, 4 )
					p.FogScale = scale
					p.FogTheta = 0.5 * math.pi * math.random( 1, 4 )
					p.FogVecX, p.FogVecY = offsetX, offsetY
					p.FogVecScale = math.random( -15, -1 ) / 100
				end

				local s = p.FogScale + zo_lerp( 0, p.FogVecScale, interval )
				p:RotateCoords( p.FogTheta, p.FogVecX, p.FogVecY, s, s )

				local cR, cG, cB, cA = p:GetColorOffsets()
				local cv = p.ColorVertex
				local alpha = ac * cA * easedInterval

				if 1 == cv then
					p:SetVertexColors( 1 + 2, eR, eG, eB, alpha )
					p:SetVertexColors( 4 + 8, cR, cG, cB, alpha )
				elseif 2 == cv then
					p:SetVertexColors( 4 + 8, eR, eG, eB, alpha )
					p:SetVertexColors( 1 + 2, cR, cG, cB, alpha )
				elseif 3 == cv then
					p:SetVertexColors( 1 + 4, eR, eG, eB, alpha )
					p:SetVertexColors( 2 + 8, cR, cG, cB, alpha )
				elseif 4 == cv then
					p:SetVertexColors( 1 + 8, eR, eG, eB, alpha )
					p:SetVertexColors( 4 + 2, cR, cG, cB, alpha )
				end
			end
		end,
		Reset = function( self )
			self:Update()
			for _, p in ipairs( self.Particles ) do
				p.FogDirty = true
			end
		end
	} )
	return et
end

AddFogEffect( 61, "Fog, Dense",		0.8,	0.7, 0.4,	6000 )
AddFogEffect( 62, "Fog, Moderate",	0.4,	0.4, 0.7,	4000 )
AddFogEffect( 63, "Fog, Light",		0.3,	0.2, 0.7,	4000 )

EHT.EffectType:New( 64, "Colored Room, Meridia's", {
	Category = CAT.LIGHT,
	Overlay = true,
	Init = function( self )
		self:SetAutoDrawLevelEnabled( false )
		self:AddParticle( "", 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, true, true )
		self:AddParticle( TEXTURES.SPHERE, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, false, false )
		self:SetColor( 0.5, 0, 0.5, 0 )
		self.MaxAlpha = 0.15
		self:SetSize( 1000, 1000, 1000 )
		self.CurrentSize = self:GetSize()
		self:SpawnAtPlayer( 0 )
	end,
	Update = function( self )
		local tex = self.Particles[1].Texture
		local cR, cG, cB, alpha = tex:GetColor()
		local size = self:GetSize()
		local x, y, z = self:GetPosition()
		local inRange = zo_distance3D( PlayerX, PlayerY, PlayerZ, x, y, z ) <= 0.5 * size

		if inRange then
			alpha = math.min( alpha + ( self.MaxAlpha * 0.1 ), self.MaxAlpha )
		else
			alpha = math.max( alpha - ( self.MaxAlpha * 0.1 ), 0 )
		end

		tex:SetAlpha( alpha )
		local p = self.Particles[2]

		if self == EHT.GetEffectEditor().Effect then
			p:FaceCamera()
			if inRange then
				p:SetColor( 0, 1, 1, 0.8 )
			else
				p:SetColor( 1, 1, 1, 0.5 )
			end
			p:SetHidden( false )
		else
			p:SetHidden( true )
		end
	end,
	Reset = function( self )
		local newSize1, newSize2, newSize3 = self:GetSize()
		if self.CurrentSize ~= newSize1 then
			self:SetSize( newSize1, newSize1, newSize1 )
		elseif self.CurrentSize ~= newSize2 then
			self:SetSize( newSize2, newSize2, newSize2 )
		else
			self:SetSize( newSize3, newSize3, newSize3 )
		end
		self.CurrentSize = self:GetSize()
		self:Update()

		local cR, cG, cB = self:GetColor()

		local p = self.Particles[2]
		p:SetHidden( true )
		p:SetSize( self.CurrentSize, self.CurrentSize, self.CurrentSize )
		p:SetPosition( self:GetPosition() )
		p:SetColor( cR, cG, cB, 0.5 )

		p = self.Particles[1]
		if cR == cG and cG == cB then
			p:SetAdditive( false )
			self.MaxAlpha = 0.5
		else
			p:SetAdditive( true )
			self.MaxAlpha = 0.15
		end

		local tex = p.Texture
		tex:SetColor( cR, cG, cB, 0 )

		zo_callLater( function()
			tex:Destroy3DRenderSpace()
			tex:SetAnchor( CENTER, GuiRoot, CENTER, 0, 0 )
			tex:SetDimensions( 5500, 3000 )
			tex:SetDrawLevel( DRAW_LEVEL_OVERLAY_EFFECT )
		end, 1000 )
	end,
} )

EHT.EffectType:New( 65, "Colored Panel, Thin", {
	Category = CAT.BUILD,

	Init = function( self )
		local p = self:AddParticle( "", 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.3, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0, 0.5, 0, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 500 )
	end,
} )

EHT.EffectType:New( 66, "Colored Panel, Sturdy", {
	Category = CAT.BUILD,

	Init = function( self )
		local p = self:AddParticle( "", 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.6, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0, 0.5, 0, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 500 )
	end,
} )

EHT.EffectType:New( 67, "Colored Panel, Solid", {
	Category = CAT.BUILD,

	Init = function( self )
		local p = self:AddParticle( "", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0, 0.5, 0, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 500 )
	end
} )
--[[
function AddBubbleEffect(id, name, maxBubbles, minSize, maxSize, vecY)
	vecY = vecY or 1

	return EHT.EffectType:New(id, name, {
		Category = CAT.ANIM,
		ResetOnPosition = true,
		ResetOnScale = true,

		Init = function(self)
			self:SetAutoPositionEnabled(false)
			self:SetAutoSizeEnabled(false)
			self:SetAutoOrientationEnabled(false)
			self:SetSize(250, 250, 250)
			self:SetColor(0, 0.6, 1, 1)
			self:SetOrientation(0, 0, 0)
			self:SetCameraFacing(true)

			local axialCells = math.ceil(math.sqrt(maxBubbles))
			self.AxialCells = axialCells
			for index = 0, maxBubbles - 1 do
				local p = self:AddParticle(TEXTURES.BUBBLE,	 0, 0, 0,	 0, 0, 0,	 1, 1, 1, 1, 	0.1, 0.1, 	true, false, false)
				p:SetSize(0, 0)
				p.OffsetX = (index % axialCells) / (axialCells - 1)
				p.OffsetZ = (math.floor((index / maxBubbles) * axialCells) / (axialCells - 1))
				p.StartTime = 0
				p.Interval = 1
				p.AlphaCoeff = 1
			end

			self:SpawnAtPlayer(200)
		end,

		Update = function(self)
			local r, g, b = self:GetColor()
			local x, y, z = self:GetPosition()
			local ft = FrameTime
			local maxP = #self.Particles
			local PI = RAD180

			for index = 1, maxP do
				local p = self.Particles[index]
				local reset = false
				local interval = ft > p.StartTime and ((ft - p.StartTime) / p.Interval) or 0

				if 1 < interval then
					local r = math.random()
					local scale = zo_lerp(0.25, 1, r)

					p.PX = zo_lerp(self.MinX, self.MaxX, p.OffsetX)
					p.PZ = zo_lerp(self.MinZ, self.MaxZ, p.OffsetZ)
					p.PMinY, p.PMaxY = self.MinY, self.MaxY
					p.AlphaCoeff = 1 + r
					p.StartTime = ft
					p.Interval = math.random(self.MinInterval, self.MaxInterval)
					p:SetAlpha(0)
					p:SetSampleProcessing(1 + r)
					p:RotateCoords(r * PI, 0.5, 0.5, scale, scale)
				else
					p:SetPosition(p.PX, zo_lerp(p.PMinY, p.PMaxY, interval), p.PZ)
					p:SetAlpha(math.sin(interval * PI) * p.AlphaCoeff)
				end
			end
		end,

		Reset = function(self)
			local x, y, z = self:GetPosition()
			local sizeX, sizeY, sizeZ = self:GetSize()
			if sizeX < 25 or sizeY < 25 or sizeZ < 25 then
				sizeX, sizeY, sizeZ = math.max(25, sizeX), math.max(25, sizeY), math.max(25, sizeZ)
				self:SetSize(sizeX, sizeY, sizeZ)
			end
			
			self.MinInterval = zo_clamp((sizeY / 1000) * 2000, 500, 10000)
			self.MaxInterval = self.MinInterval * 2

			local sizeX, sizeY, sizeZ = self:GetSize()
			local radiusX, radiusY, radiusZ = sizeX * 0.5, sizeY * 0.5, sizeX * 0.5
			self.MinX, self.MinY, self.MinZ = x - radiusX, y - radiusY, z - radiusZ
			self.MaxX, self.MaxY, self.MaxZ = x + radiusX, y + radiusY, z + radiusZ

			if 0 > vecY then
				local temp = self.MinY
				self.MinY = self.MaxY
				self.MaxY = temp
			end

			local pSize = zo_clamp(0.4 * sizeX / self.AxialCells, 8, 200)
			for index = 1, #self.Particles do
				p = self.Particles[index]
				p:SetSize(pSize, pSize)
			end
		end,
	})
end
]]
function AddBubbleEffect(id, name, maxBubbles, minSize, maxSize, vecY)
	vecY = vecY or 1
	local offsetVecY = -0.5 * vecY
	local numRowCells = math.ceil(math.sqrt(maxBubbles))
	maxBubbles = numRowCells * numRowCells

	local cellSizeX = 1
	local cellSizeZ = 1
	local minBubbleSize = 1
	local maxBubbleSize = 1
	local minTravelTime = 4000
	local maxTravelTime = 7000
	local yOffset = 0

	return EHT.EffectType:New(id, name, {
		Category = CAT.ANIM,
		Init = function(self)
			self:SetSize(500, 1000, 500)
			self:SetColor(0.6, 0.75, 1, 1)
			self:SetOrientation(0, 0, 0)
			self:SetCameraFacing(true)
			self.ResetOnColor = false

			local p
			for index = 1, maxBubbles do
				p = self:AddParticle(TEXTURES.CIRCLE_SOFT,	0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		0.1, 0.1,	true, false)
				p:SetAlpha(0)
				p:SetTextureWrapping(false)
				
				p.Distribution = (((index - 1) / (maxBubbles - 1)) * 4.3) % 1
				p.EndTime = 1
				p.TravelTime = 1
				p.AlphaEaseCoeff = zo_lerp(0.3, 0.7, p.Distribution)
			end

			self:SpawnAtPlayer(350)
		end,

		Update = function(self)
			local ft = FrameTime
			local r, g, b = self:GetColor()
			local x, y, z = self:GetPosition()
			local sizeX, sizeY, sizeZ = self:GetSize()
			sizeX, sizeY, sizeZ = sizeX * 0.5, sizeY * 0.5, sizeX * 0.5
			
			for index, p in ipairs(self.Particles) do
				local recycle = true
				if p.EndTime and p.TravelTime then
					local interval = 1 - ((p.EndTime - ft) / p.TravelTime)
					if 1 > interval then
						p:SetPosition(p.X, y + (vecY * interval + offsetVecY) * sizeY, p.Z)
						p:SetAlpha(VariableEase(interval, p.AlphaEaseCoeff))
						p:SetHidden(false)
						recycle = false
					end
				end

				if recycle then
					p:SetHidden(true)

					local texSize = math.random(minBubbleSize, maxBubbleSize)
					p:SetSize(texSize, texSize)
					p:SetPosition(x + p.CellX + cellSizeX * math.random(), y - yOffset, z + p.CellZ + cellSizeZ * math.random())
					p.EndTime = ft + p.TravelTime
				end
			end
		end,

		Reset = function(self)
			self:SetAutoPositionEnabled(false)
			self:SetAutoSizeEnabled(false)
			self:SetAutoOrientationEnabled(false)

			local x, y, z = self:GetPosition()
			local _, yaw = self:GetOrientation()
			local sizeX, sizeY, sizeZ = self:GetSize()

			minTravelTime = zo_clamp(sizeY * 1.5, 1000, 10000)
			maxTravelTime = minTravelTime * 3

			local cellSizeXZ = math.max(1, (sizeX - 4 * numRowCells) / numRowCells)
			cellSizeX = cellSizeXZ
			cellSizeZ = cellSizeXZ
			yOffset = -0.5 * sizeY * vecY
			minBubbleSize = math.max(2, cellSizeXZ * minSize)
			maxBubbleSize = math.max(2, cellSizeXZ * maxSize)

			local wrapCellNum = numRowCells - 1
			local cellOffsetX = -sizeX * 0.5
			local cellOffsetZ = -sizeX * 0.5
			local cellX = 0
			local cellZ = 0
			local maxR, maxG, maxB = self:GetColor()
			local minR, minG, minB = maxR * 0.5, maxG * 0.5, maxB * 0.5
			local numParticles = #self.Particles
			for index, p in ipairs(self.Particles) do
				local dist = p.Distribution
				p:SetColor(zo_lerp(minR, maxR, dist), zo_lerp(minG, maxG, dist), zo_lerp(minB, maxB, dist), 0)
				p.TravelTime = zo_lerp(minTravelTime, maxTravelTime, dist)
				p.CellX = cellOffsetX + cellX * (cellSizeX + 4)
				p.CellZ = cellOffsetZ + cellZ * (cellSizeZ + 4)
				cellX = cellX + 1
				if cellX >= wrapCellNum then
					cellX = 0
					cellZ = cellZ + 1
				end
			end

			self:SetOrientation(0, yaw, 0)
			self:Update()
		end,
	})
end

AddBubbleEffect(68, "Bubbles, Sparse",		5,		0.02, 0.04)
AddBubbleEffect(69, "Bubbles, Moderate",	10,		0.06, 0.1)
AddBubbleEffect(70, "Bubbles, Dense",		20,		0.12, 0.16)

EHT.EffectType:New( 71, "Bubbles, Intermittent", {

	Category = CAT.ANIM,

	Init = function( self )

		self.MaxBubbles, self.MinSize, self.MaxSizeOffset, self.MinTravelTime, self.MaxTravelTime = 50, 0.01, 0.08, 1500, 5000
		self.MaxTravelTimeOffset = self.MaxTravelTime - self.MinTravelTime
		self:SetSize( 50, 250, 250 )
		self:SetColor( 0, 0.6, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetAutoSizeEnabled( false )
		self:SetAutoOrientationEnabled( false )

		local p
		for index = 1, self.MaxBubbles do
			p = self:AddParticle( TEXTURES.CIRCLE_SOFT, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.8, 0.1, 0.1, true, false )
			p:SetTextureWrapping( false )
			p:SetSampleProcessing( 1, 1 )
			p:SetAdditive( true )
		end

		self:SpawnAtPlayer( 200 )

	end,

	Update = function( self )

		local sizeX, sizeY = self:GetSize()
		local minX, minY = -0.5 * sizeX, -0.5 * sizeY
		local ft = FrameTime
		local maxP = #self.Particles
		local color, p, interval, texSize

		if self.NextRelease <= ft then
			self.NextRelease = ft + self.MaxTravelTime + 2000 + self.MaxTravelTime * math.random()

			for index = 1, maxP do
				p = self.Particles[index]
				p:SetOrientation( 0, CameraHeading, 0 )

				p.BaseX = minX + sizeX * math.random()
				p:SetPositionOffsets( p.BaseX, 0, minX + ( sizeX * ( index / maxP ) ) )

				texSize = sizeX * ( self.MinSize + self.MaxSizeOffset * math.random() )
				p:SetSize( texSize, texSize )

				color = 0.8 + 0.2 * math.random()
				p.BaseAlpha = 0.2 + 0.5 * math.random()
				p:SetColorOffsets( color, color, color, p.BaseAlpha )

				p.StartTime, p.TravelTime = ft + 2000 * math.random(), self.MinTravelTime + self.MaxTravelTimeOffset * math.random()
				p.WaveFreq = 4 * ( ( self.MaxTravelTime - p.TravelTime ) / self.MaxTravelTime )
				p.WaveMagnitude = 2 * p.WaveFreq * math.random()
			end
		else
			for index = 1, maxP do
				p = self.Particles[index]
				p:SetOrientation( 0, CameraHeading, 0 )
				interval = ( ft - p.StartTime ) / p.TravelTime

				if 1 > interval and 0 <= interval then
					p:SetPositionOffsets( p.BaseX + p.WaveMagnitude * math.sin( interval * p.WaveFreq * math.pi ), minY + ( interval * sizeY ) )
					p:SetColorOffsets( nil, nil, nil, p.BaseAlpha * math.min( 1, ( 1.2 - interval ) / 1 ) )
					p:SetHidden( false )
				else
					p:SetHidden( true )
				end
			end
		end

		self:Update()

	end,

	Reset = function( self )

		local _, yaw = self:GetOrientation()
		self.NextRelease = FrameTime

		local p
		for index = 1, #self.Particles do
			p = self.Particles[index]
			p.StartTime, p.TravelTime = 1, 1
		end

		self:SetOrientation( 0, yaw, 0 )
		self:Update()

	end,

} )

EHT.EffectType:New( 72, "Sonar Rings", {

	Category = CAT.ANIM,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( "esoui/art/mappins/maprallypoint.dds",		0, 0, 0,	math.rad( 90 ), 0, 0,	1, 1, 1, 1,		1, 1,	true, true )
		p:SetSampleProcessing( 0.5, 0.5 )

		self:SetSize( 200, 0, 200 )
		self:SetColor( 1, 0, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 50 )

	end,

	Update = function( self )

		self.Particles[1]:SetTextureCoords( GetIntervalSurface( 32, 1, 1000, 0 ) )

	end,

	Reset = function( self )

	end,

} )

EHT.EffectType:New( 73, "Tile, Ice Mage", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/atronach/crowncrate_atronach_back.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.225, 0.775, 0.065, 0.935 )

		self:SetSize( 500, 700, 700 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 74, "Seal, Ice Mage", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/atronach/crowncrate_atronach_crate-add.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.56, 0.94, 0.1, 0.45 )
		p:SetSampleProcessing( 2, 0 )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 75, "Tile, Fire Mage", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/flameatronach/crowncrate_flameatronach_back.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.225, 0.775, 0.065, 0.94 )

		self:SetSize( 500, 700, 700 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 76, "Seal, Fire Mage", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/flameatronach/flameatronach_crate001-add.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.56, 0.94, 0.1, 0.45 )
		p:SetSampleProcessing( 2, 0 )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 77, "Tile, Dragon Priest", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/scale/crowncrate_scale_back.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.225, 0.775, 0.065, 0.94 )

		self:SetSize( 500, 700, 700 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 78, "Seal, Dragon Priest", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/scale/crowncrate_scale_crate-add.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.56, 0.94, 0.1, 0.45 )
		p:SetSampleProcessing( 2, 0 )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 79, "Tile, Warden", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/wildhunt/crowncrate_wildhunt_back.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.225, 0.775, 0.065, 0.93 )

		self:SetSize( 500, 700, 700 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 80, "Seal, Warden", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/wildhunt/crowncrate_wildhunt_crate-add.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.56, 0.94, 0.1, 0.45 )
		p:SetSampleProcessing( 2, 0 )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 81, "Tile, Brotherhood", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/dbh/crowncrate_dbh_back.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.225, 0.775, 0.065, 0.932 )

		self:SetSize( 500, 700, 700 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 82, "Seal, Brotherhood", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/dbh/crowncrate_dbh_crate-add.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.56, 0.94, 0.1, 0.45 )
		p:SetSampleProcessing( 2, 0 )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 83, "Tile, Dwarven", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/dwemer/crowncrate_dwemer_back.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.225, 0.775, 0.065, 0.932 )

		self:SetSize( 500, 700, 700 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 84, "Seal, Dwarven", {

	Category = CAT.DECO,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/crowncrates/dwemer/crowncrate_dwemer_crate-add.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetTextureCoords( 0.56, 0.94, 0.1, 0.45 )
		p:SetSampleProcessing( 2, 0 )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end

} )

EHT.EffectType:New( 85, "Waterfall", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		for index = 1, 5 do
			p = self:AddParticle( TEXTURES.WAVES_1, 0, 0, 0, 0, 0, 0, 0.6 + 0.1 * index, 0.6 + 0.1 * index, 0.6 + 0.1 * index, 1, 1, 1, true, false )
			p:SetTextureWrapping( true )
		end

		for index = 1, 5 do
			p = self:AddParticle( "esoui/art/pregameanimatedbackground/smoke_muted_02.dds",			0, 0, 0,	0, 0, 0,	1, 1, 1, 0,		1, 1,	true, true )
			p:SetTextureWrapping( false )
			p:SetSampleProcessing( 0.8, 0.2 )
		end

		self.CoeffY = 1
		self:SetSize( 500, 0, 500 )
		self:SetColor( 0.4, 0.6, 0.6, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 500 )

	end,

	Update = function( self )

		local duration = 3000
		local horizInterval = 0.05 * GetEasedInterval( 8000 )
		local p, waveInterval

		waveInterval = GetLinearInterval( duration, 0 )
		p = self.Particles[ 1 ]
		p:SetTextureCoords( 0 + horizInterval, 3 + horizInterval, 1.23 + waveInterval + self.CoeffY, 0.23 + waveInterval )
		p:SetAlpha( 0.5 * math.sin( waveInterval * math.pi ) )

		waveInterval = ( waveInterval + 0.2 ) % 1
		p = self.Particles[ 2 ]
		p:SetTextureCoords( 3 - horizInterval, 0 - horizInterval, 1.74 + waveInterval + self.CoeffY, 0.74 + waveInterval )
		p:SetAlpha( 0.5 * math.sin( waveInterval * math.pi ) )

		waveInterval = ( waveInterval + 0.2 ) % 1
		p = self.Particles[ 3 ]
		p:SetTextureCoords( 0.5 + horizInterval, 4 + horizInterval, 2.19 + waveInterval + self.CoeffY, 0.19 + waveInterval )
		p:SetAlpha( 0.5 * math.sin( waveInterval * math.pi ) )

		waveInterval = ( waveInterval + 0.2 ) % 1
		p = self.Particles[ 4 ]
		p:SetTextureCoords( 3 + horizInterval, 0.25 + horizInterval, 1.89 + waveInterval + self.CoeffY, 0.89 + waveInterval )
		p:SetAlpha( 0.5 * math.sin( waveInterval * math.pi ) )

		waveInterval = ( waveInterval + 0.2 ) % 1
		p = self.Particles[ 5 ]
		p:SetTextureCoords( 0.75 - horizInterval, 3.15 - horizInterval, 2.27 + waveInterval + self.CoeffY, 0.27 + waveInterval )
		p:SetAlpha( 0.5 * math.sin( waveInterval * math.pi ) )

		waveInterval = GetLinearInterval( 5000, 0 )
		local b, c, offset = true, 1, -0.6

		for index = 1, 5 do
			p = self.Particles[ index + 5 ]
			if b then
				p:SetTextureCoords( offset - 1 + 0.5 * waveInterval, offset + 2 - 0.5 * waveInterval, -0.5, 0.5 * waveInterval )
			else
				p:SetTextureCoords( offset + 2 + 0.5 * waveInterval, offset - 1 - 0.5 * waveInterval, -0.5, 0.6 * waveInterval )
			end
			c = 0.8 + 2 * index * horizInterval
			p:SetColor( c, c, c, math.sin( waveInterval * math.pi ) )
			b, offset, waveInterval = not b, offset + 0.3, ( waveInterval + 0.2 ) % 1
		end

	end,

	Reset = function( self )

		local sizeX, sizeY, sizeZ = self:GetSize()
		self.CoeffY = zo_clamp( math.max( sizeY, sizeZ ) / 1500, 1, 3 )

	end,

} )

EHT.EffectType:New( 86, "Steam, Scalding", {
	Category = CAT.ANIM,
	CanPitch = true,
	Init = function( self )
		self.IntervalDuration = 2000
		self.MaxMargin = 1.4
		self.IndexMod = 0

		local numP = 10
		local p

		for index = 1, numP do
			if 0 == index % 2 then
				p = self:AddParticle( "esoui/art/pregameanimatedbackground/smoke_muted_02.dds",			0, 0, 0,	0, 0, 0,	1, 1, 1, 0,		1, 1,	true, true )
			else
				p = self:AddParticle( "esoui/art/tradinghouse/tradinghouse_itemicon_highlightbg.dds",	0, 0, 0,	0, 0, 0,	1, 1, 1, 0,		1, 1,	true, true )
			end
			p:SetTextureWrapping( false )
			p:SetSampleProcessing( 0.8, 0.2 )
			p.IntervalOffset = ( index / numP ) * self.IntervalDuration
		end

		self:SetColor( 0.5, 0.5, 0.6, 1 )
		self:SetSize( 700, 500, 500 )
		self:SpawnAtPlayer( 250 )
		self:SetOrientation( 0, 0, 0 )
	end,
	Update = function( self )
		local interval, easedInterval, dX1, dX2, cR, cG, cB, cA, cRand, p
		local numP = #self.Particles
		local pitch = self:GetOrientation()

		for index = 1, numP do
			p = self.Particles[index]
			interval = GetLinearInterval( self.IntervalDuration, p.IntervalOffset )
			easedInterval = math.sin( interval * 1.2 * math.pi )
			cR, cG, cB, cA = p:GetColorOffsets()

			if 0 > easedInterval and 0 < cA then
				cRand = 0.5 + 0.45 * math.random()
				self.IndexMod = ( self.IndexMod + 1 ) % 4
				dX1, dX2 = 0.1 + self.MaxMargin * math.random(), 0.1 + self.MaxMargin * math.random()

				if 1 > 2 * math.random() then
					dX1, dX2 = -dX1 - 1, 2 + dX2
				else
					dX1, dX2 = 2 + dX1, -dX2 - 1
				end

				p.BaseX1, p.BaseX2 = dX1, dX2
				p:SetColorOffsets( cRand, cRand, cRand, 0 )
				p:SetTextureCoords( dX1, dX2, 0, 1 )
				p:SetHidden( true )
			elseif 0 < easedInterval then
				if not p.BaseX1 then
					p:SetTextureCoords( nil, nil, 0, 1 + 2 * interval )
				elseif p.BaseX1 < p.BaseX2 then
					p:SetTextureCoords( p.BaseX1 + 0.5 * interval, p.BaseX2 - 0.5 * interval, 0, 1 + 2 * interval )
				else
					p:SetTextureCoords( p.BaseX1 - 0.5 * interval, p.BaseX2 + 0.5 * interval, 0, 1 + 2 * interval )
				end
				p:SetColorOffsets( cR, cG, cB, 2 * easedInterval)
				p:SetHidden( false )
			end
		end

		self:Update()
	end,
} )

EHT.EffectType:New( 87, "Steam, Vaporous", {
	Category = CAT.ANIM,
	CanPitch = true,
	Init = function( self )
		self.IntervalDuration = 6000
		self.MaxMargin = 3
		self.IndexMod = 0

		local numP = 8
		local p

		for index = 1, numP do
			if 0 == index % 2 then
				p = self:AddParticle( "esoui/art/pregameanimatedbackground/smoke_muted_02.dds",			0, 0, 0,	0, 0, 0,	1, 1, 1, 0,		1, 1,	true, true )
			else
				p = self:AddParticle( "esoui/art/tradinghouse/tradinghouse_itemicon_highlightbg.dds",	0, 0, 0,	0, 0, 0,	1, 1, 1, 0,		1, 1,	true, true )
			end
			p:SetTextureWrapping( false )
			p:SetSampleProcessing( 0.4, 0.2 )
			p.IntervalOffset = ( index / numP ) * self.IntervalDuration
		end

		self:SetColor( 0.5, 0.5, 0.6, 1 )
		self:SetSize( 700, 500, 500 )
		self:SpawnAtPlayer( 250 )
		self:SetOrientation( 0, 0, 0 )
	end,
	Update = function( self )
		local interval, easedInterval, dX1, dX2, cR, cG, cB, cA, cRand, p
		local numP = #self.Particles
		local pitch = self:GetOrientation()

		for index = 1, numP do
			p = self.Particles[index]
			interval = GetLinearInterval( self.IntervalDuration, p.IntervalOffset )
			easedInterval = math.sin( interval * 1.2 * math.pi )
			cR, cG, cB, cA = p:GetColorOffsets()

			if 0 > easedInterval and 0 < cA then
				cRand = 0.5 + 0.45 * math.random()
				self.IndexMod = ( self.IndexMod + 1 ) % 4
				dX1, dX2 = 0.1 + self.MaxMargin * math.random(), 0.1 + self.MaxMargin * math.random()

				if 1 > 2 * math.random() then
					dX1, dX2 = -dX1 - 1, 2 + dX2
				else
					dX1, dX2 = 2 + dX1, -dX2 - 1
				end

				p.BaseX1, p.BaseX2 = dX1, dX2
				p:SetColorOffsets( cRand, cRand, cRand, 0 )
				p:SetTextureCoords( dX1, dX2, 0, 1 )
				p:SetHidden( true )
			elseif 0 < easedInterval then
				if not p.BaseX1 then
					p:SetTextureCoords( nil, nil, 0, 1 + 2 * interval )
				elseif p.BaseX1 < p.BaseX2 then
					p:SetTextureCoords( p.BaseX1 + 0.5 * interval, p.BaseX2 - 0.5 * interval, 0, 1 + 2 * interval )
				else
					p:SetTextureCoords( p.BaseX1 - 0.5 * interval, p.BaseX2 + 0.5 * interval, 0, 1 + 2 * interval )
				end
				p:SetColorOffsets( cR, cG, cB, 2 * easedInterval)
				p:SetHidden( false )
			end
		end

		self:Update()
	end,
} )

EHT.EffectType:New( 88, "Steam, Escaping", {
	Category = CAT.ANIM,
	CanPitch = true,
	Init = function( self )
		self.MaxMargin = 1.4
		self.IndexMod = 0

		local numP = 14
		local p

		for index = 1, numP do
			if 0 == index % 2 then
				p = self:AddParticle( "esoui/art/pregameanimatedbackground/smoke_muted_02.dds",			0, 0, 0,	0, 0, 0,	1, 1, 1, 0,		1, 1,	true, true )
			else
				p = self:AddParticle( "esoui/art/tradinghouse/tradinghouse_itemicon_highlightbg.dds",	0, 0, 0,	0, 0, 0,	1, 1, 1, 0,		1, 1,	true, true )
			end
			p:SetTextureWrapping( false )
			p:SetSampleProcessing( 0.8, 0.2 )
			p.IntervalOffset = ( math.floor( index / 7 ) * 3300 )
			p.IntervalDuration = 10000
		end

		self:SetColor( 0.5, 0.5, 0.6, 1 )
		self:SetSize( 300, 700, 700 )
		self:SpawnAtPlayer( 300 )
		self:SetOrientation( 0, 0, 0 )
	end,
	Update = function( self )
		local interval, easedInterval, dX1, dX2, cR, cG, cB, cA, cRand, p
		local numP = #self.Particles

		for index = 1, numP do
			p = self.Particles[index]
			interval = GetLinearInterval( p.IntervalDuration, p.IntervalOffset )
			easedInterval = math.sin( interval * 1.8 * math.pi )
			cR, cG, cB, cA = p:GetColorOffsets()

			if 0 > easedInterval and 0 < cA then
				cRand = 0.5 + 0.45 * math.random()
				self.IndexMod = ( self.IndexMod + 1 ) % 4
				dX1, dX2 = 0.1 + self.MaxMargin * math.random(), 0.1 + self.MaxMargin * math.random()

				if 1 > 2 * math.random() then
					dX1, dX2 = -dX1 - 1, 2 + dX2
				else
					dX1, dX2 = 2 + dX1, -dX2 - 1
				end

				p.BaseX1, p.BaseX2 = dX1, dX2
				p:SetColorOffsets( cRand, cRand, cRand, 0 )
				p:SetTextureCoords( dX1, dX2, 0, 1 )
				p:SetHidden( true )
			elseif 0 < easedInterval then
				if not p.BaseX1 then
					p:SetTextureCoords( nil, nil, 0, 1 + 2 * interval )
				elseif p.BaseX1 < p.BaseX2 then
					p:SetTextureCoords( p.BaseX1 + 0.5 * interval, p.BaseX2 - 0.5 * interval, 0, 1 + 2 * interval )
				else
					p:SetTextureCoords( p.BaseX1 - 0.5 * interval, p.BaseX2 + 0.5 * interval, 0, 1 + 2 * interval )
				end
				p:SetColorOffsets( cR, cG, cB, 2 * easedInterval)
				p:SetHidden( false )
			end
		end

		self:Update()
	end,
	Reset = function( self )
		for index = 1, #self.Particles do
			self.Particles[index]:SetHidden( true )
		end
	end,
} )

do
	local durationOffset = 0

	EHT.EffectType:New( 89, "New Life Star", {

		Category = CAT.DECO,

		CanPitch = true,

		Init = function( self )

			self.AnimationDuration = 9000 + durationOffset * 1371
			durationOffset = ( durationOffset + 1 ) % 10

			local p

			p = self:AddParticle( "esoui/art/chatwindow/chat_notification_burst.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
			p:SetTextureWrapping( false )
			p:SetTextureCoords( 0, 1, 0, 1 )
			p:SetColorOffsets( 1, 1, 1, 0 )

			p = self:AddParticle( "esoui/art/champion/champion_star_pulse.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
			p:SetTextureWrapping( false )
			p:SetTextureCoords( 0, 0.25, 0, 0.25 )
			p:SetColorOffsets( 1, 1, 1, 1 )

			self:SetSize( 300, 300, 300 )
			self:SetColor( 1, 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 250 )

		end,

		Update = function( self )

			local p, interval
			local yaw = CameraHeading

			for index = 1, #self.Particles do
				p = self.Particles[index]
				p:SetOrientationOffsets( 0, yaw, 0 )
			end

			p = self.Particles[1]
			interval = math.abs( GetEasedInterval( self.AnimationDuration, 0.5 * self.AnimationDuration ) )
			p:SetTextureCoords( -0.28 * interval, 1 + 0.28 * interval, -0.28 * interval, 1 + 0.28 * interval )
			p:SetColorOffsets( 1, 1, 1, 0.4 + 0.25 * interval )

			self:Update()

		end,

		Reset = function( self )

			local pitch = self:GetOrientation()
			self:SetOrientation( pitch, 0, 0 )
			self:Update()

		end,

	} )

end

EHT.EffectType:New( 90, "Ground Impact", {

	Category = CAT.DECO,

	EnhanceContrast = true,

	Init = function( self )

		local p

		p = self:AddParticle( "esoui/art/champion/champion_star_burst.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.75, 1, 1, true, false )
		p:SetTextureWrapping( false )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0, 0, 0, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Reset = function( self )

		self.Particles[1]:SetSampleProcessing( 2, 0 )
		self:Update()

	end,

} )

EHT.EffectType:New( 91, "Fishing Hole", {

	Category = CAT.PET,

	Init = function( self )

		local p, angle

		for index = 0, 3 do
			angle = math.rad( 90 * index )
			p = self:AddParticle( "esoui/art/icons/crafting_fishing_river_betty.dds", 0, 0, 0, math.rad( 90 ), angle + math.rad( 45 ), 0, 1, 1, 1, 1, 0.25, 0.25, true, false )
			p:SetTextureWrapping( true )
			p:SetTextureCoords( 0, 1, 0, 1 )
			p:SetColor( 1, 1, 1, 0.95 )
			p:SetPositionOffsets( math.sin( angle ) * 100, 0, math.cos( angle ) * 100 )
		end

		self:SetSize( 250, 250, 250 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 10 )

	end,

	Update = function( self )

		local p, angle

		for index = 0, 3 do
			angle = ( 1 - GetLinearInterval( 16000, 12000 * index ) ) * 2 * math.pi
			p = self.Particles[index + 1]
			p:SetOrientationOffsets( math.rad( 90 ), angle + math.rad( 45 ) )
			p:SetPositionOffsets( math.sin( angle ) * ( self.Radius or 100 ), 0, math.cos( angle ) * ( self.Radius or 100 ) )
		end

		self:Update()

	end,

	Reset = function( self )

		local x, y, z = self:GetSize()
		self.Radius = x * 0.5
		self:SetSize( x, x, x )
		self:Update()

	end,

} )

do

	local durationOffset = 0

	EHT.EffectType:New( 92, "Star Trio, Twinkling", {

		Category = CAT.ANIM,

		CanPitch = true,

		Init = function( self )

			self:SetAutoOrientationEnabled( false )
			self:SetSize( 250, 250, 250 )
			self:SetColor( 1, 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )

			self.AnimationDuration = 4000 + 2000 * math.random()
			self.AnimationOffset = durationOffset * 891
			durationOffset = ( durationOffset + 1 )
			if durationOffset > 9 then durationOffset = 0 end

			local p
			for index = 1, 3 do
				p = self:AddParticle( "esoui/art/champion/champion_star_pulse.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0.2, 0.2, true, false )
				p:SetTextureWrapping( false )
				p:SetTextureCoords( 0, 0.25, 0, 0.25 )
				p:SetColorOffsets( 1, 1, 1, 1 )
			end
			self.Particles[2]:SetSizeOffsets( 0.3, 0.3 )

			self:SpawnAtPlayer( 250 )

		end,

		Update = function( self )

			local color, colorInterval, surfaceIndex
			local pitch = self:GetOrientation()
			local p

			for index = 1, #self.Particles do
				p = self.Particles[index]
				
				colorInterval = math.abs( GetEasedInterval( self.AnimationDuration, self.AnimationOffset + index * index * 391 ) )
				surfaceIndex = zo_clamp( math.floor( colorInterval * 16 ), 1, 16 )
				color = 0.25 + 0.2 * colorInterval + 0.25 * index

				p:SetOrientation( pitch, CameraHeading, 0 )
				p:SetTextureCoords( GetSurface( surfaceIndex, 4, 4 ) )
				p:SetColorOffsets( color, color, color, 1 )

			end

			self:Update()

		end,

		Reset = function( self )

			local maxX, maxY, maxZ = self:GetSize()
			local p

			p = self.Particles[1]
			p:SetPositionOffsets( ( -0.5 + 0.15 ) * maxX, ( -0.5 + 0.5 ) * maxY, 0 )
			p = self.Particles[2]
			p:SetPositionOffsets( ( -0.5 + 0.5 ) * maxX, ( -0.5 + 0.25 ) * maxY, 0 )
			p = self.Particles[3]
			p:SetPositionOffsets( ( -0.5 + 0.85 ) * maxX, ( -0.5 + 0.85 ) * maxY, 0 )

			self:Update()

		end,

	} )

end

do

	local durationOffset = 0

	EHT.EffectType:New( 93, "Star Cluster, Twinkling", {

		Category = CAT.ANIM,

		CanPitch = true,

		Init = function( self )

			self:SetAutoOrientationEnabled( false )
			self:SetSize( 250, 250, 250 )
			self:SetColor( 1, 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )

			self.AnimationDuration = 6000 + 4000 * math.random()
			self.AnimationOffset = durationOffset * 891
			durationOffset = ( durationOffset + 1 )
			if durationOffset > 9 then durationOffset = 0 end

			local p
			for index = 1, 9 do
				p = self:AddParticle( "esoui/art/champion/champion_star_pulse.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0.075 * math.floor( ( index + 2 ) / 3 ), 0.075 * math.floor( ( index + 2 ) / 3 ), true, false )
				p:SetTextureWrapping( false )
				p:SetTextureCoords( 0, 0.25, 0, 0.25 )
				p:SetColorOffsets( 1, 1, 1, 1 )
			end
			self.Particles[2]:SetSizeOffsets( 0.3, 0.3 )

			self:SpawnAtPlayer( 250 )

		end,

		Update = function( self )

			local color, colorInterval, surfaceIndex
			local pitch = self:GetOrientation()
			local p

			for index = 1, #self.Particles do
				p = self.Particles[index]
				
				colorInterval = math.abs( GetEasedInterval( self.AnimationDuration, self.AnimationOffset + ( index * index ) * 191 ) )
				surfaceIndex = zo_clamp( math.floor( colorInterval * 16 ), 1, 16 )
				color = 0.25 + 0.2 * colorInterval + 0.17 * index * 0.5

				p:SetOrientation( pitch, CameraHeading, 0 )
				p:SetTextureCoords( GetSurface( surfaceIndex, 4, 4 ) )
				p:SetColorOffsets( color, color, color, 1 )

			end

			self:Update()

		end,

		Reset = function( self )

			local maxX, maxY, maxZ = self:GetSize()
			local p

			p = self.Particles[1]
			p:SetPositionOffsets( ( -0.5 + 0.65 ) * maxX, ( -0.5 + 0.5 ) * maxY, 0 )
			p = self.Particles[2]
			p:SetPositionOffsets( ( -0.5 + 0.5 ) * maxX, ( -0.5 + 0.25 ) * maxY, 0 )
			p = self.Particles[3]
			p:SetPositionOffsets( ( -0.5 + 0.85 ) * maxX, ( -0.5 + 0.85 ) * maxY, 0 )

			p = self.Particles[4]
			p:SetPositionOffsets( ( -0.5 + 0.15 ) * maxX, ( -0.5 + 0.15 ) * maxY, 0 )
			p = self.Particles[5]
			p:SetPositionOffsets( ( -0.5 + 0.25 ) * maxX, ( -0.5 + 0.5 ) * maxY, 0 )
			p = self.Particles[6]
			p:SetPositionOffsets( ( -0.5 + 0.85 ) * maxX, ( -0.5 + 0.15 ) * maxY, 0 )

			p = self.Particles[7]
			p:SetPositionOffsets( ( -0.5 + 0.85 ) * maxX, ( -0.5 + 0.5 ) * maxY, 0 )
			p = self.Particles[8]
			p:SetPositionOffsets( ( -0.5 + 0.5 ) * maxX, ( -0.5 + 0.75 ) * maxY, 0 )
			p = self.Particles[9]
			p:SetPositionOffsets( ( -0.5 + 0.15 ) * maxX, ( -0.5 + 0.85 ) * maxY, 0 )

			self:Update()

		end,

	} )

end

do

	local durationOffset = 0

	EHT.EffectType:New( 94, "Star Field, Twinkling", {

		Category = CAT.ANIM,

		CanPitch = true,

		Init = function( self )

			self:SetAutoOrientationEnabled( false )
			self:SetSize( 250, 250, 250 )
			self:SetColor( 1, 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )

			self.AnimationDuration = 6000 + 4000 * math.random()
			self.AnimationOffset = durationOffset * 891
			durationOffset = ( durationOffset + 1 )
			if durationOffset > 9 then durationOffset = 0 end

			local p
			for index = 1, 9 do
				p = self:AddParticle( "esoui/art/champion/champion_star_pulse.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0.075 * math.floor( ( index + 2 ) / 3 ), 0.075 * math.floor( ( index + 2 ) / 3 ), true, false )
				p:SetTextureWrapping( false )
				p:SetTextureCoords( 0, 0.25, 0, 0.25 )
				p:SetColorOffsets( 1, 1, 1, 1 )
			end
			self.Particles[2]:SetSizeOffsets( 0.3, 0.3 )

			self:SpawnAtPlayer( 250 )

		end,

		Update = function( self )

			local color, colorInterval, surfaceIndex
			local pitch = self:GetOrientation()
			local p

			for index = 1, #self.Particles do
				p = self.Particles[index]
				
				colorInterval = math.abs( GetEasedInterval( self.AnimationDuration, self.AnimationOffset + ( index * index ) * 191 ) )
				surfaceIndex = zo_clamp( math.floor( colorInterval * 16 ), 1, 16 )
				color = 0.25 + 0.2 * colorInterval + 0.17 * index * 0.5

				p:SetOrientation( pitch, CameraHeading, 0 )
				p:SetTextureCoords( GetSurface( surfaceIndex, 4, 4 ) )
				p:SetColorOffsets( color, color, color, 1 )

			end

			self:Update()

		end,

		Reset = function( self )

			local maxX, maxY, maxZ = self:GetSize()
			local p

			p = self.Particles[1]
			p:SetPositionOffsets( ( -0.5 + 0.65 ) * maxX, ( -0.5 + 0.5 ) * maxY, ( -0.5 + 0.1 ) * maxZ )
			p = self.Particles[2]
			p:SetPositionOffsets( ( -0.5 + 0.5 ) * maxX, ( -0.5 + 0.25 ) * maxY, ( -0.5 + 0.2 ) * maxZ )
			p = self.Particles[3]
			p:SetPositionOffsets( ( -0.5 + 0.85 ) * maxX, ( -0.5 + 0.85 ) * maxY, ( -0.5 + 0.3 ) * maxZ )

			p = self.Particles[4]
			p:SetPositionOffsets( ( -0.5 + 0.15 ) * maxX, ( -0.5 + 0.15 ) * maxY, ( -0.5 + 0.4 ) * maxZ )
			p = self.Particles[5]
			p:SetPositionOffsets( ( -0.5 + 0.25 ) * maxX, ( -0.5 + 0.5 ) * maxY, ( -0.5 + 0.5 ) * maxZ )
			p = self.Particles[6]
			p:SetPositionOffsets( ( -0.5 + 0.85 ) * maxX, ( -0.5 + 0.15 ) * maxY, ( -0.5 + 0.6 ) * maxZ )

			p = self.Particles[7]
			p:SetPositionOffsets( ( -0.5 + 0.85 ) * maxX, ( -0.5 + 0.5 ) * maxY, ( -0.5 + 0.7 ) * maxZ )
			p = self.Particles[8]
			p:SetPositionOffsets( ( -0.5 + 0.5 ) * maxX, ( -0.5 + 0.75 ) * maxY, ( -0.5 + 0.8 ) * maxZ )
			p = self.Particles[9]
			p:SetPositionOffsets( ( -0.5 + 0.15 ) * maxX, ( -0.5 + 0.85 ) * maxY, ( -0.5 + 0.9 ) * maxZ )

			self:Update()

		end,

	} )

end

EHT.EffectType:New( 95, "Triforce", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.TRIFORCE, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( false )
		p:SetColor( 1, 1, 1, 1 )

		self:SetSize( 100, 100, 100 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 100 )

	end,

	Reset = function( self )

		self.Particles[1]:SetTextureCoords( 0, 1, 0, 1 )
		self:Update()

	end,

} )

local PaintingMetaParams =
{
	GetMetaParamByName( "Scale % (X)" ),
	GetMetaParamByName( "Scale % (Y)" ),
	GetMetaParamByName( "Offset % (X)" ),
	GetMetaParamByName( "Offset % (Y)" ),
}

local function OnPaintingInit(self)
	self:AddParticle(self.EffectType.PaintingTexture,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, true)
	self:SetSize(460, 287, 287)
	self:SetColor(1, 1, 1, 1)
	self:SetOrientation(0, 0, 0)
	self:SpawnAtPlayer(144)
end

local function OnPaintingReset(self)
	local p = self.Particles[1]
	if p then
		local scaleX, scaleY = (tonumber(self:GetMetaData("Scale % (X)")) or 100) / 100, (tonumber(self:GetMetaData("Scale % (Y)")) or 100) / 100
		local offsetX, offsetY = (tonumber(self:GetMetaData("Offset % (X)")) or 0) / 100, (tonumber(self:GetMetaData("Offset % (Y)")) or 0) / 100
		p:RotateCoords(0, (offsetX + 0.5) % 1, (offsetY + 0.5) % 1, scaleX, scaleY)
	end
end

local function AddPaintingEffect( enabled, index, name, texture )
	return EHT.EffectType:New( index, string.format( "Painting, %s", name ), {
		Category = CAT.PAINT,
		Enabled = enabled ~= false,
		IsPainting = true,
		PaintingTexture = texture,
		MetaParams = PaintingMetaParams,
		Init = OnPaintingInit,
		Reset = OnPaintingReset,
	} )
end

do

	local index = 96

	AddPaintingEffect( true, index, "Abecean Sea", "esoui/art/loadingscreens/loadscreen_abecean_sea_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Aetherian Archive", "esoui/art/loadingscreens/loadscreen_aetherianarchive_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Aldmeri Manor", "esoui/art/loadingscreens/loadscreen_aldmerimanor_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Alik'r Desert", "esoui/art/loadingscreens/loadscreen_alikir_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Alik'r", "esoui/art/loadingscreens/loadscreen_alikrtheward_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Altmer Home", "esoui/art/loadingscreens/loadscreen_altmer_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ancestral Tomb", "esoui/art/loadingscreens/loadscreen_ancestraltomb_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Angofs Sanctum", "esoui/art/loadingscreens/loadscreen_angofs_sanctum_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Anvil Otlaw Refuge", "esoui/art/loadingscreens/loadscreen_anviloutlawrefuge_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Apartment Inn", "esoui/art/loadingscreens/loadscreen_apartment_inn_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Argent Mine", "esoui/art/loadingscreens/loadscreen_argentmine_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Argonian", "esoui/art/loadingscreens/loadscreen_argonian_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Argonian Ruins", "esoui/art/loadingscreens/loadscreen_argonian_ruins_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Arx Corinium", "esoui/art/loadingscreens/loadscreen_arx_corinium_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ash Mountain", "esoui/art/loadingscreens/loadscreen_ash_mountain_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ashaba Pass", "esoui/art/loadingscreens/loadscreen_ashaba_pass_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Asylum Sanctorium", "esoui/art/loadingscreens/loadscreen_asylumsanctorium_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Athimah Family Estate", "esoui/art/loadingscreens/loadscreen_athimahfamilyestate_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Auridon, 1", "esoui/art/loadingscreens/loadscreen_auridon_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Auridon, 2", "esoui/art/loadingscreens/loadscreen_auridon_02.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ayleid, 1", "esoui/art/loadingscreens/loadscreen_ayleid_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ayleid, 2", "esoui/art/loadingscreens/loadscreen_ayleid_02.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ayleid, 3", "esoui/art/loadingscreens/loadscreen_ayleid_03.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ayleid, 4", "esoui/art/loadingscreens/loadscreen_ayleid_04.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Badman's Hollow", "esoui/art/loadingscreens/loadscreen_badmanshollow_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Bahrahas Gloom", "esoui/art/loadingscreens/loadscreen_bahrahasgloom_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Balfoyen", "esoui/art/loadingscreens/loadscreen_balfoyen_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Balmora Inn", "esoui/art/loadingscreens/loadscreen_balmorainn_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Banished Cell", "esoui/art/loadingscreens/loadscreen_banishedcell_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Bangkorai", "esoui/art/loadingscreens/loadscreen_bankorai_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ald Carac", "esoui/art/loadingscreens/loadscreen_battleground_ald_carac_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Arcane University", "esoui/art/loadingscreens/loadscreen_battleground_arcaneuniversity_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Foyada Quarry", "esoui/art/loadingscreens/loadscreen_battleground_foyadaquarry_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ularra", "esoui/art/loadingscreens/loadscreen_battleground_ularra_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Betnikh", "esoui/art/loadingscreens/loadscreen_betnikh_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Blackforge", "esoui/art/loadingscreens/loadscreen_blackforge_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Blackheart Haven", "esoui/art/loadingscreens/loadscreen_blackheart_haven_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Blackwood Borderlands", "esoui/art/loadingscreens/loadscreen_blackwoodborderlands_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Bleakrock", "esoui/art/loadingscreens/loadscreen_bleakrock_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Bleeding Monolith", "esoui/art/loadingscreens/loadscreen_bleedingmonolith_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Blessed Crucible", "esoui/art/loadingscreens/loadscreen_blessed_crucible_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Bloodroot Forge", "esoui/art/loadingscreens/loadscreen_bloodrootforge_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Bonegrinder", "esoui/art/loadingscreens/loadscreen_bonegrinder_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Bonerock Caverns", "esoui/art/loadingscreens/loadscreen_bonerockcaverns_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Bonesnap Ruins", "esoui/art/loadingscreens/loadscreen_bonesnapruins_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Bosmer", "esoui/art/loadingscreens/loadscreen_bosmer_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Bosmer Home", "esoui/art/loadingscreens/loadscreen_bosmerhouse_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Breton", "esoui/art/loadingscreens/loadscreen_breton_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Buried Sands", "esoui/art/loadingscreens/loadscreen_buriedsands_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Camlorn Keep", "esoui/art/loadingscreens/loadscreen_camlorn_keep_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Castle Anvil", "esoui/art/loadingscreens/loadscreen_castleanvil_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Castle Kvatch", "esoui/art/loadingscreens/loadscreen_castlekvatch_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cave, 1", "esoui/art/loadingscreens/loadscreen_cave_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cave, 2", "esoui/art/loadingscreens/loadscreen_cave_02.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cave, 3", "esoui/art/loadingscreens/loadscreen_cave_03.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cave, 4", "esoui/art/loadingscreens/loadscreen_cave_04.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cave of Trophies", "esoui/art/loadingscreens/loadscreen_cave_of_trophies_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cavemine", "esoui/art/loadingscreens/loadscreen_cavemine_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cavern of the Incarnate", "esoui/art/loadingscreens/loadscreen_cavernoftheincarnates_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Chambers of Light", "esoui/art/loadingscreens/loadscreen_chambers_of_light_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Chambers of Loyalty", "esoui/art/loadingscreens/loadscreen_chambersofloyalty_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Chapter 1, 1", "esoui/art/loadingscreens/loadscreen_chapter1_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Chapter 1, 2", "esoui/art/loadingscreens/loadscreen_chapter1_5_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Chapter 1, 3", "esoui/art/loadingscreens/loadscreen_chapter2_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Chapter 1, 4", "esoui/art/loadingscreens/loadscreen_chapter2_5_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Chapter 1, 5", "esoui/art/loadingscreens/loadscreen_chapter3_5_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Chapter 1, 6", "esoui/art/loadingscreens/loadscreen_chapter4_5_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Chapter 1, 7", "esoui/art/loadingscreens/loadscreen_chapter5_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Chapter 1, 8", "esoui/art/loadingscreens/loadscreen_chapter6_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ravenous Rodent", "esoui/art/loadingscreens/loadscreen_chateau_of_the_ravenous_rodent_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cheerful Slaughter", "esoui/art/loadingscreens/loadscreen_circus_of_the_cheerful_slaughter_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "City of Ash", "esoui/art/loadingscreens/loadscreen_city_of_ash_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Clockwork City, 1", "esoui/art/loadingscreens/loadscreen_clockworkcity_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Clockwork City, 2", "esoui/art/loadingscreens/loadscreen_clockworkcity_zone_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cogitum Centralis", "esoui/art/loadingscreens/loadscreen_cogitumcentralis_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Coldblood Cavern", "esoui/art/loadingscreens/loadscreen_coldbloodcavern_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Coldharbour", "esoui/art/loadingscreens/loadscreen_coldharbor_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Surreal Estate", "esoui/art/loadingscreens/loadscreen_coldharbourplot_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Coldperch Cavern", "esoui/art/loadingscreens/loadscreen_coldperchcavern_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Colored Rooms", "esoui/art/loadingscreens/loadscreen_coloredrooms_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cradlecrush Arena, 1", "esoui/art/loadingscreens/loadscreen_cradlecrush_arena_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cradlecrush Arena, 2", "esoui/art/loadingscreens/loadscreen_cradlecrush_arena_02.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cradle of Shadows", "esoui/art/loadingscreens/loadscreen_cradleofshadows_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Craglorn", "esoui/art/loadingscreens/loadscreen_craglorn_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Crowswood", "esoui/art/loadingscreens/loadscreen_crowswood_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Crypt of Hearts", "esoui/art/loadingscreens/loadscreen_crypt_of_hearts_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Crypt of Tarishzi", "esoui/art/loadingscreens/loadscreen_cryptoftarishzi_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Volcano Island", "esoui/art/loadingscreens/loadscreen_cs1_volcano_island_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Craglorn Ruins", "esoui/art/loadingscreens/loadscreen_cs2_craglorn_ruins_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Cyrodiil", "esoui/art/loadingscreens/loadscreen_cyrodiil_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Daedric, 1", "esoui/art/loadingscreens/loadscreen_daedric_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Daedric, 2", "esoui/art/loadingscreens/loadscreen_daedric_02.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Daedric, 3", "esoui/art/loadingscreens/loadscreen_daedric_03.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Daedric Ruins", "esoui/art/loadingscreens/loadscreen_daedricruins_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Daedroth", "esoui/art/loadingscreens/loadscreen_daedroth_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Daggerfall Castle", "esoui/art/loadingscreens/loadscreen_daggerfall_castle_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Daggerfall Manor", "esoui/art/loadingscreens/loadscreen_daggerfallmanor_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Darkshade Caverns", "esoui/art/loadingscreens/loadscreen_darkshade_caverns_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Sanctuary", "esoui/art/loadingscreens/loadscreen_dbsanctuary_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Den of Lorkhaj", "esoui/art/loadingscreens/loadscreen_den_of_lorkhaj_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Deshaan", "esoui/art/loadingscreens/loadscreen_deshaan_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Direfrost Keep", "esoui/art/loadingscreens/loadscreen_direfrost_keep_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Doomcrag", "esoui/art/loadingscreens/loadscreen_doomcrag_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Dourstone Vault", "esoui/art/loadingscreens/loadscreen_dourstone_vault_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Drabul", "esoui/art/loadingscreens/loadscreen_drabul_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Dragonstar Arena", "esoui/art/loadingscreens/loadscreen_dragonstararena_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Dranilkir", "esoui/art/loadingscreens/loadscreen_dranilkir_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Dunmer", "esoui/art/loadingscreens/loadscreen_dunmer_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Dunmer Crypt", "esoui/art/loadingscreens/loadscreen_dunmer_crypt_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Dwemer, 1", "esoui/art/loadingscreens/loadscreen_dwemer_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Dwemer, 2", "esoui/art/loadingscreens/loadscreen_dwemer_02.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Dwemer Ruins", "esoui/art/loadingscreens/loadscreen_dwemerruins_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Eastmarch", "esoui/art/loadingscreens/loadscreen_eastmarch_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ebonheart Pact Manor", "esoui/art/loadingscreens/loadscreen_ebonheartpactmanor_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Elden Hollow", "esoui/art/loadingscreens/loadscreen_elden_hollow_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Elden Tree Platform", "esoui/art/loadingscreens/loadscreen_eldentreeplatform_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Enclave of the Hourglass", "esoui/art/loadingscreens/loadscreen_enclaveofthehourglass_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Evergloam", "esoui/art/loadingscreens/loadscreen_evergloam_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Everwound Wellspring", "esoui/art/loadingscreens/loadscreen_everwoundwellspring_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Exarchs Stronghold", "esoui/art/loadingscreens/loadscreen_exarchsstronghold_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Eyevea", "esoui/art/loadingscreens/loadscreen_eyevea_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Falkreath Hall", "esoui/art/loadingscreens/loadscreen_falkreathhall_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Falkreaths Demise", "esoui/art/loadingscreens/loadscreen_falkreathsdemise_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Fearfangs Cavern", "esoui/art/loadingscreens/loadscreen_fearfangscavern_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Fharun Prison", "esoui/art/loadingscreens/loadscreen_fharunprison_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Firemoth Island", "esoui/art/loadingscreens/loadscreen_firemothisland_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Five Fingers Dance", "esoui/art/loadingscreens/loadscreen_five_fingers_dance_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Forgotten Crypts", "esoui/art/loadingscreens/loadscreen_forgotten_crypts_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Forgotten Wastes", "esoui/art/loadingscreens/loadscreen_forgottenwastes_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Fort, 1", "esoui/art/loadingscreens/loadscreen_fort_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Fort, 2", "esoui/art/loadingscreens/loadscreen_fort_02.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Fort Virak", "esoui/art/loadingscreens/loadscreen_fort_virak_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Frostbreak Fortress", "esoui/art/loadingscreens/loadscreen_frostbreakfortress_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Fulstrom Homestead", "esoui/art/loadingscreens/loadscreen_fulstromhomestead_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Fungal Grotto", "esoui/art/loadingscreens/loadscreen_fungal_grotto_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Garlasagea", "esoui/art/loadingscreens/loadscreen_garlasagea_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Crypt", "esoui/art/loadingscreens/loadscreen_generic_crypt_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Glade of the Divine", "esoui/art/loadingscreens/loadscreen_glade_of_the_divine_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Glassmine", "esoui/art/loadingscreens/loadscreen_glassmine_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Glenumbra", "esoui/art/loadingscreens/loadscreen_glenumbra_01.dds" )  index = index + 1
	AddPaintingEffect( false, index, "Glenumbra, 2", "esoui/art/loadingscreens/loadscreen_glenumbra_02.dds" )  index = index + 1 -- DUPLICATE
	AddPaintingEffect( true, index, "Goldcoast", "esoui/art/loadingscreens/loadscreen_goldcoast_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Grahtwood", "esoui/art/loadingscreens/loadscreen_grahtwood_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Great Shackle", "esoui/art/loadingscreens/loadscreen_greatshackle_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Greenshade", "esoui/art/loadingscreens/loadscreen_greenshade_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Grundas Gatehouse", "esoui/art/loadingscreens/loadscreen_grundas_gatehouse_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Haddocks Market", "esoui/art/loadingscreens/loadscreen_haddocksmarket_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Halls of Fabrication", "esoui/art/loadingscreens/loadscreen_hallsoffabrication_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Halls of Regulation", "esoui/art/loadingscreens/loadscreen_hallsofregulation_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Hel Ra Citadel", "esoui/art/loadingscreens/loadscreen_helracitadel_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Hewsbane", "esoui/art/loadingscreens/loadscreen_hewsbane_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Hircines Haunt", "esoui/art/loadingscreens/loadscreen_hircineshaunt_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Hlaalu Manor", "esoui/art/loadingscreens/loadscreen_hlaalumanor_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Honors Rest", "esoui/art/loadingscreens/loadscreen_honorsrest_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Hrota Cave", "esoui/art/loadingscreens/loadscreen_hrotacave_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Hulajabad Estate", "esoui/art/loadingscreens/loadscreen_hulajabadestate_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ice Cave", "esoui/art/loadingscreens/loadscreen_ice_cave_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Iceflint Cave", "esoui/art/loadingscreens/loadscreen_iceflintcave_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Icehearts Lair", "esoui/art/loadingscreens/loadscreen_iceheartslair_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ilthagsunder Tower", "esoui/art/loadingscreens/loadscreen_ilthagsundertower_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Imperial", "esoui/art/loadingscreens/loadscreen_imperial_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Imperial City, 1", "esoui/art/loadingscreens/loadscreen_imperialcity_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Dragonfire Cathedral", "esoui/art/loadingscreens/loadscreen_imperialcity_dragonfirecathedral_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Imperial City, 2", "esoui/art/loadingscreens/loadscreen_imperialcity_keyart_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Imperial City Prison", "esoui/art/loadingscreens/loadscreen_imperialcity_prison_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Imperial City Sewers", "esoui/art/loadingscreens/loadscreen_imperialcity_sewers_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Incarnatorium", "esoui/art/loadingscreens/loadscreen_incarnatorium_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Jarol Estate", "esoui/art/loadingscreens/loadscreen_jarolestate_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Jerall Mountains", "esoui/art/loadingscreens/loadscreen_jerallmountains_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Kenarthis Roost", "esoui/art/loadingscreens/loadscreen_kenathis_roost_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Khajiit, 1", "esoui/art/loadingscreens/loadscreen_khajiit_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Khajiit, 2", "esoui/art/loadingscreens/loadscreen_khajit_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "King Emeric", "esoui/art/loadingscreens/loadscreen_kingemeric_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Knightsgrave", "esoui/art/loadingscreens/loadscreen_knightsgrave_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Kvatch Cathedral", "esoui/art/loadingscreens/loadscreen_kvatchcathedral_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Kwamamine", "esoui/art/loadingscreens/loadscreen_kwamamine_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Lions Den", "esoui/art/loadingscreens/loadscreen_lions_den_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Na-totambu", "esoui/art/loadingscreens/loadscreen_lost_city_of_na-totambu_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Lost Barrow", "esoui/art/loadingscreens/loadscreen_lostbarrow_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Lothna Caverns", "esoui/art/loadingscreens/loadscreen_lothnacaverns_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Maelstrom Arena", "esoui/art/loadingscreens/loadscreen_maelstromarena_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Malabaltor", "esoui/art/loadingscreens/loadscreen_malabaltor_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Maloocs Path", "esoui/art/loadingscreens/loadscreen_maloocspath_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Market District", "esoui/art/loadingscreens/loadscreen_marketdistrict_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Maw of Lorkaj", "esoui/art/loadingscreens/loadscreen_maw_of_lorkaj.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Mazzatun", "esoui/art/loadingscreens/loadscreen_mazzatun_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Mechanical Fundament", "esoui/art/loadingscreens/loadscreen_mechanicalfundament_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Mnemonic Planisphere", "esoui/art/loadingscreens/loadscreen_mnemonicplanisphere_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Molagmar", "esoui/art/loadingscreens/loadscreen_molagmar_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Mournhold Sewers", "esoui/art/loadingscreens/loadscreen_mournhold_sewers_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Nibenese Manor", "esoui/art/loadingscreens/loadscreen_nibenesemanor_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Nord", "esoui/art/loadingscreens/loadscreen_nord_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Nord Crypt, 1", "esoui/art/loadingscreens/loadscreen_nord_crypt_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Nord Crypt, 2", "esoui/art/loadingscreens/loadscreen_nord_crypt_02.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Noshira Citadel", "esoui/art/loadingscreens/loadscreen_noshiracitadel_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Odirniran", "esoui/art/loadingscreens/loadscreen_odirniran_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Old Orsinium", "esoui/art/loadingscreens/loadscreen_oldorsinium_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Orbsevatory Prior", "esoui/art/loadingscreens/loadscreen_orbsevatoryhousing.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Orc", "esoui/art/loadingscreens/loadscreen_orc_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Orc, Old Sanctuary", "esoui/art/loadingscreens/loadscreen_orsimtempleoldsanctuary.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Orc, Temple Rectory", "esoui/art/loadingscreens/loadscreen_orsimtemplerectory_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Orsinium", "esoui/art/loadingscreens/loadscreen_orsinium_keyart_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Orsinium Keep", "esoui/art/loadingscreens/loadscreen_orsiniumkeep_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Orsinium Outlaws Refuge", "esoui/art/loadingscreens/loadscreen_orsiniumoutlawsrefuge_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Orsinium Temple", "esoui/art/loadingscreens/loadscreen_orsiniumtemple_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Refuge, Ayleid", "esoui/art/loadingscreens/loadscreen_outlaw_refuge_ayleid_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Refuge, Dunmer", "esoui/art/loadingscreens/loadscreen_outlaw_refuge_dunmer_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Refuge, Grahtwood", "esoui/art/loadingscreens/loadscreen_outlaw_refuge_grahtwood_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Refuge, Jungle Cave", "esoui/art/loadingscreens/loadscreen_outlaw_refuge_jungle_cave_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Refuge, Khajiit", "esoui/art/loadingscreens/loadscreen_outlaw_refuge_khajiit_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Refuge, Nedic", "esoui/art/loadingscreens/loadscreen_outlaw_refuge_nedic_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Refuge, Nord", "esoui/art/loadingscreens/loadscreen_outlaw_refuge_nord_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Refuge, Redguard", "esoui/art/loadingscreens/loadscreen_outlaw_refuge_redguard_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Refuge, Sewer", "esoui/art/loadingscreens/loadscreen_outlaw_refuge_sewer_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Paragons Remembrance", "esoui/art/loadingscreens/loadscreen_paragonsremembrance_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Nirn Portal", "esoui/art/loadingscreens/loadscreen_portalnirn_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Prison of Xykenaz", "esoui/art/loadingscreens/loadscreen_prisonofxykenaz_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Rahniza School", "esoui/art/loadingscreens/loadscreen_rahnizaschool_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Razaks Wheel", "esoui/art/loadingscreens/loadscreen_razaks_wheel_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Reapers March", "esoui/art/loadingscreens/loadscreen_reapersmarch_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Redguard", "esoui/art/loadingscreens/loadscreen_redguard_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Redoran Council Hall", "esoui/art/loadingscreens/loadscreen_redorancouncilhall_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Redoran Manor", "esoui/art/loadingscreens/loadscreen_redoranmanor_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Reinholds Retreat", "esoui/art/loadingscreens/loadscreen_reinholds_retreat_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Rift", "esoui/art/loadingscreens/loadscreen_rift_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Rivenspire", "esoui/art/loadingscreens/loadscreen_rivenspire_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Rkindaleft", "esoui/art/loadingscreens/loadscreen_rkindaleft_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Root Sunder", "esoui/art/loadingscreens/loadscreen_root_sunder_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ruins of Kardala", "esoui/art/loadingscreens/loadscreen_ruinsofkardala_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Rulanyils Fall", "esoui/art/loadingscreens/loadscreen_rulanyils_fall_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Sanctum of Prowess", "esoui/art/loadingscreens/loadscreen_sanctumofprowess_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Sanessalmos Madness", "esoui/art/loadingscreens/loadscreen_sanessalmos_madness_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Selenes Web", "esoui/art/loadingscreens/loadscreen_selenes_web_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Serpents Nest", "esoui/art/loadingscreens/loadscreen_serpentsnest_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Serpent Trial", "esoui/art/loadingscreens/loadscreen_serpenttrial_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Shad Astula", "esoui/art/loadingscreens/loadscreen_shad_astula_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Shadas Tear", "esoui/art/loadingscreens/loadscreen_shadastear_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Shadowfen", "esoui/art/loadingscreens/loadscreen_shadowfen_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Sharksteeth Grotto", "esoui/art/loadingscreens/loadscreen_sharksteethgrotto_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Skuldafn", "esoui/art/loadingscreens/loadscreen_skuldafn_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Skyreach Catacombs", "esoui/art/loadingscreens/loadscreen_skyreachcatacombs_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Skyreach Hold", "esoui/art/loadingscreens/loadscreen_skyreachhold_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Skyreach Pinnacle", "esoui/art/loadingscreens/loadscreen_skyreachpinnacle_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Skyreach Temple", "esoui/art/loadingscreens/loadscreen_skyreachtemple_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Refuge, Slagtown", "esoui/art/loadingscreens/loadscreen_slagtownoutlawsrefuge_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Sorrow", "esoui/art/loadingscreens/loadscreen_sorrow_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Spindleclutch", "esoui/art/loadingscreens/loadscreen_spindleclutch_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Stirk", "esoui/art/loadingscreens/loadscreen_stirk_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Stonefalls", "esoui/art/loadingscreens/loadscreen_stonefalls_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Stormhaven", "esoui/art/loadingscreens/loadscreen_stormhaven_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Stros M'kai", "esoui/art/loadingscreens/loadscreen_strosmkai_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Telvanni Tower", "esoui/art/loadingscreens/loadscreen_telvannitower_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Tempest Island", "esoui/art/loadingscreens/loadscreen_tempest_island_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Thieve's Guild Den", "esoui/art/loadingscreens/loadscreen_tg_banditden.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Thieve's Guild Safehouse", "esoui/art/loadingscreens/loadscreen_tg_safehouse_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Depraved Grotto", "esoui/art/loadingscreens/loadscreen_the_depraved_grotto_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Hunting Grounds", "esoui/art/loadingscreens/loadscreen_the_hunting_grounds_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Plane of Jode", "esoui/art/loadingscreens/loadscreen_the_plane_of_jode_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Vile Manse", "esoui/art/loadingscreens/loadscreen_the_vile_manse_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Wailing Maw", "esoui/art/loadingscreens/loadscreen_the_wailing_maw_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Brass Fortress", "esoui/art/loadingscreens/loadscreen_thebrassfortress_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Howling Sepulchre", "esoui/art/loadingscreens/loadscreen_thehowlingsepulchre_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Kennel", "esoui/art/loadingscreens/loadscreen_thekennel_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Mages Staff", "esoui/art/loadingscreens/loadscreen_themagesstaff_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Mooring", "esoui/art/loadingscreens/loadscreen_themooring_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Refuge of Dread", "esoui/art/loadingscreens/loadscreen_therefugeofdread_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Serviflume", "esoui/art/loadingscreens/loadscreen_theserviflume_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "The Shadowcleft", "esoui/art/loadingscreens/loadscreen_theshadowcleft_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Tonal Quarry", "esoui/art/loadingscreens/loadscreen_tonalquarry_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Toothmaul Gully", "esoui/art/loadingscreens/loadscreen_toothmaul_gully_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Tribunal", "esoui/art/loadingscreens/loadscreen_tribunal_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Trollcave", "esoui/art/loadingscreens/loadscreen_trollcave_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Tuwhaccas Throne", "esoui/art/loadingscreens/loadscreen_tuwhaccasthrone_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Uggamogs Lair", "esoui/art/loadingscreens/loadscreen_uggamogslair_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Underskar", "esoui/art/loadingscreens/loadscreen_underskar_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Vaults of Madness", "esoui/art/loadingscreens/loadscreen_vaults_of_madness_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Ventral Terminus", "esoui/art/loadingscreens/loadscreen_ventralterminus_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Village of the Lost", "esoui/art/loadingscreens/loadscreen_village_of_the_lost_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Refuge, Vivec", "esoui/art/loadingscreens/loadscreen_vivecoutlawrefuge_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Vivecs Antlers", "esoui/art/loadingscreens/loadscreen_vivecs_antlers_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Volcanic Cave", "esoui/art/loadingscreens/loadscreen_volcanic_cave_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Vollenfell", "esoui/art/loadingscreens/loadscreen_vollenfell_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Vvardenfel", "esoui/art/loadingscreens/loadscreen_vvardenfel_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Vvardenfell Cave", "esoui/art/loadingscreens/loadscreen_vvardenfell_cave_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Watchers Hold", "esoui/art/loadingscreens/loadscreen_watchershold_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Wayrest Sewers", "esoui/art/loadingscreens/loadscreen_wayrestsewers_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "White Gold Tower", "esoui/art/loadingscreens/loadscreen_whitegoldtower_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Witch Hut", "esoui/art/loadingscreens/loadscreen_witchhut_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Wrothgar", "esoui/art/loadingscreens/loadscreen_wrothgar_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Wrothgar Ruins", "esoui/art/loadingscreens/loadscreen_wrothgarruins.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Zalgazs Den", "esoui/art/loadingscreens/loadscreen_zalgazsden_01.dds" )  index = index + 1
	AddPaintingEffect( true, index, "Zthenganaz", "esoui/art/loadingscreens/loadscreen_zthenganaz_01.dds" )  index = index + 1

end

do

	local paintingsList

	EHT.EffectType:New( 388, "Painting Slideshow, Crossfade", {

		Category = CAT.PAINT,
		CanPitch = true,
		OrderDrawLevelByIndex = true,

		Init = function( self )
			local coordRight, coordBottom = coordRight or 1, coordBottom or 0.999 -- coordRight or 0.8, coordBottom or 0.5
			local xDefault, yDefault = 460, 287
			local p

			-- Cache the Paintings list.
			if nil == paintingsList then paintingsList = EHT.EffectType:GetFilteredEnabledList( "IsPainting", true ) end

			self.PaintingIndex, self.Phase, self.NextPhase, self.SlideInterval, self.TransitionInterval = math.random( 1, #paintingsList ), 1, 0, 3000, 2000
			local currentIndex, nextIndex = self.PaintingIndex, ( ( self.PaintingIndex + 1 ) % #paintingsList ) + 1

			p = self:AddParticle( "art/fx/texture/blacksquare.dds", 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, true, false )
			p:SetTextureWrapping( false )

			p = self:AddParticle( paintingsList[currentIndex].PaintingTexture, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, true, false )
			p:SetTextureWrapping( false )
			p:SetTextureCoords( 0, coordRight, 0, coordBottom )

			p = self:AddParticle( paintingsList[nextIndex].PaintingTexture, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, true, false )
			p:SetTextureWrapping( false )
			p:SetTextureCoords( 0, coordRight, 0, coordBottom )

			self:SetSize( xDefault, yDefault, yDefault )
			self:SetColor( 1, 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( yDefault * 1.5, false )
		end,

		Update = function( self )
			local ft = FrameTime
			local p1, p2 = self.Particles[2], self.Particles[3]
			local r, g, b = self:GetColor()

			if self.NextPhase <= ft then
				if 1 == self.Phase then
					self.PaintingIndex = self.PaintingIndex + 1
					if self.PaintingIndex > #paintingsList then self.PaintingIndex = 1 end

					p1:SetTextureFile( paintingsList[self.PaintingIndex].PaintingTexture )

					self.Phase = 2
					self.NextPhase = ft + self.TransitionInterval
				elseif 2 == self.Phase then
					p2:SetTextureFile( paintingsList[self.PaintingIndex].PaintingTexture )

					self.Phase = 1
					self.NextPhase = ft + self.SlideInterval
				end
			end

			if 2 == self.Phase then

				local alpha = ( self.NextPhase - ft ) / ( self.TransitionInterval / 2 )
				local animation = self.PaintingIndex % 6

				if 0 == animation then
					p1:SetVertexColors( 1 + 2, r, g, b, 1 - alpha )
					p1:SetVertexColors( 4 + 8, r, g, b, 2 - alpha )
					p2:SetVertexColors( 4 + 8, r, g, b, alpha - 1 )
					p2:SetVertexColors( 1 + 2, r, g, b, alpha )
				elseif 1 == animation then
					p1:SetVertexColors( 1 + 2, r, g, b, 2 - alpha )
					p1:SetVertexColors( 4 + 8, r, g, b, 1 - alpha )
					p2:SetVertexColors( 4 + 8, r, g, b, alpha )
					p2:SetVertexColors( 1 + 2, r, g, b, alpha - 1 )
				elseif 2 == animation then
					p1:SetVertexColors( 1 + 4, r, g, b, 2 - alpha )
					p1:SetVertexColors( 2 + 8, r, g, b, 1 - alpha )
					p2:SetVertexColors( 2 + 8, r, g, b, alpha )
					p2:SetVertexColors( 1 + 4, r, g, b, alpha - 1 )
				elseif 3 == animation then
					p1:SetVertexColors( 1 + 4, r, g, b, 1 - alpha )
					p1:SetVertexColors( 2 + 8, r, g, b, 2 - alpha )
					p2:SetVertexColors( 2 + 8, r, g, b, alpha - 1 )
					p2:SetVertexColors( 1 + 4, r, g, b, alpha )
				elseif 4 == animation then
					p1:SetVertexColors( 1 + 8, r, g, b, 2 - alpha )
					p1:SetVertexColors( 2 + 4, r, g, b, 1 - alpha )
					p2:SetVertexColors( 2 + 4, r, g, b, alpha )
					p2:SetVertexColors( 1 + 8, r, g, b, alpha - 1 )
				else
					p1:SetVertexColors( 1 + 8, r, g, b, 1 - alpha )
					p1:SetVertexColors( 2 + 4, r, g, b, 2 - alpha )
					p2:SetVertexColors( 2 + 4, r, g, b, alpha - 1 )
					p2:SetVertexColors( 1 + 8, r, g, b, alpha )
				end

			end
		end,

		Reset = function( self )
			self:Update()
		end,

	} )

end

AddSkyEffect(
	389, "Anu and Padomay",
	-- Options
	{ CanModifyTopColor = false },
	-- Side Textures Table
	{
		{
			Texture = TEXTURES.NEBULA_1,
			Stretch = true, Additive = true, Wrap = true,
			R = 0.5, G = 0.5, B = 0, A = 0.25,
			X1 = 0, X2 = 2, Y1 = 0, Y2 = 1,
			EasedFadeMinInterval = 6000,
			EasedFadeMaxInterval = 12000,
			EasedFadeDelay = 6000,
		},
		{
			Texture = TEXTURES.NEBULA_1,
			Stretch = true, Wrap = true,
			X1 = 0, X2 = 2, Y1 = 0, Y2 = 1,
		},
		{ Texture = TEXTURES.BLACK, Stretch = true, R = 0, G = 0, B = 0, A = 1, },
	},
	-- Top Texture Filename
	TEXTURES.SKY_STARS_1,
	-- Reset Handler
	function( self )
		local sx, sy = self:GetSize()
		local circ = 2 * math.pi * 0.5 * sx
		local y2 = EHT.World:GetAspectRatioWidth( 900, 1600, sy, circ, true )

		ProjectCylinderTextureFaces( self.TextureFaces[2], 0, 0, 2, 0, y2 )
		ProjectCylinderTextureFaces( self.TextureFaces[3], 0, 0, 2, 0, y2 )
	end,
	-- Update Handler
	nil
)

EHT.EffectType:New( 390, "Window, Round (Stained Glass)", {

	Category = CAT.BUILD,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.WINDOW_ROUND_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( false )
		p:SetColor( 1, 1, 1, 1 )
		p:SetSampleProcessing( 0.75, 0 )

		self:SetSize( 400, 400, 400 )
		self:SetColor( 0, 0, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end,

	Reset = function( self )

		self.Particles[1]:SetTextureCoords( 0, 1, 0, 1 )
		self:Update()

	end,

} )

EHT.EffectType:New( 391, "Frozen Lake", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.ICE_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.75, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetSampleProcessing( 1, 0 )

		p = self:AddParticle( TEXTURES.ICE_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.5, 1, 1, true, true )
		p:SetTextureWrapping( true )
		p:SetSampleProcessing( 0, 0.3 )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 10 )

	end,

	Reset = function( self )

		local sizeX, sizeY, sizeZ = self:GetSize()
		local texX, texY = sizeX / 2200, math.max( sizeY, sizeZ ) / 2200

		self.Particles[1]:SetTextureCoords( 0, texX + 1, 0, texY + 1 )
		self.Particles[2]:SetTextureCoords( 0.01, texX + 1.01, 0.01, texY + 1.01 )
		self:Update()

	end,

} )

EHT.EffectType:New( 392, "Sigil, Luminous", {

	Category = CAT.SIGIL,

	CanPitch = true,

	EnhanceContrast = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.RUNES_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, true )
		p:SetTextureWrapping( true )

		for index = 1, 3 do
			p = self:AddParticle( TEXTURES.RUNES_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
			p:SetTextureWrapping( true )
			p:SetDodge( true )
		end

		self.Particles[2]:SetSampleProcessing( 0, 8 )
		self.Particles[3]:SetSampleProcessing( 0, 8 )
		self.Particles[4]:SetSampleProcessing( 0, 8 )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 50 )

	end,

	Update = function( self )

		self.Particles[2]:SetIntervalVertexColors( 1, 0, 1, 0, 1, 0, 0, 0.1, 5000, 0, 600 )
		self.Particles[3]:SetIntervalVertexColors( 1, 0, 0, 0, 0, 0, 0, 0.1, 4000, 1000, 600 )
		self.Particles[4]:SetIntervalVertexColors( 0, 0, 1, 0, 0, 0, 0, 0.1, 6000, 2000, 600 )

	end,

	Reset = function( self )

		for index = 1, #self.Particles do
			self.Particles[index]:SetTextureCoords( 0, 1, 0, 1 )
		end
		self:Update()

	end,

} )

EHT.EffectType:New( 393, "Window, Arched (Stained Glass)", {

	Category = CAT.BUILD,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.WINDOW_GOTHIC, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( false )
		p:SetTextureCoords( 0.23, 0.77, 0, 1 )

		self:SetSize( 300, 560, 560 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 394, "Lava, Flowing", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.LAVA_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		p = self:AddParticle( TEXTURES.LAVA_1_NEG, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetDodge( true )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 10 )

	end,

	Update = function( self )

		local colorInterval, flowInterval = GetEasedInterval( 4000, 0 ), GetLinearInterval( 10000, 0 )
		local p

		p = self.Particles[1]
		p:SetTextureCoords( 0, ( self.TCy or 1 ), flowInterval, ( self.TCx or 1 ) + flowInterval )

		p = self.Particles[2]
		p:SetIntervalVertexColors( 0.5, 0.5, 0.5, -0.5, 0.5, 0, 0.5, 0.5, 4000, 0, 1000 )
		p:SetTextureCoords( ( self.TCy or 1 ), 0, flowInterval, ( self.TCx or 1 ) + flowInterval )

	end,

	Reset = function( self )

		local x, y, z = self:GetSize()
		x, y = x / 250, math.min( y, z ) / 250
		self.TCx, self.TCy = x, y

		for index = 1, #self.Particles do
			self.Particles[index]:SetTextureCoords( 0, x, 0, y )
		end

		self:Update()

	end,

} )

EHT.EffectType:New( 395, "Stones, Barren", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.STONES_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetSampleProcessing( 0.6, 0 )

		p = self:AddParticle( TEXTURES.STONES_1_NEG, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 0.5, 0.3, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetSampleProcessing( 0, 0.5 )
		p:SetDodge( true )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 10 )

	end,

	Update = function( self )

		local heading = GetPlayerCameraHeading()
		local offsetX, offsetY = ( 0.021 ) * math.sin( heading ), ( 0.021 ) * math.cos( heading )
		local p

		p = self.Particles[2]
		p:SetTextureCoords( offsetX, ( self.TCx or 1 ) + offsetX, offsetY, ( self.TCy or 1 ) + offsetY )

	end,

	Reset = function( self )

		local x, y, z = self:GetSize()
		x, y = x / 200, math.max( y, z ) / 200
		self.TCx, self.TCy = zo_clamp( x, 1, 3 ), zo_clamp( y, 1, 3 )

		for index = 1, #self.Particles do
			self.Particles[index]:SetTextureCoords( 0, self.TCx, 0, self.TCy )
		end

		self:Update()

	end,

} )

EHT.EffectType:New( 396, "Stones, Grassy", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.STONES_2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetSampleProcessing( 1, 0 )

		p = self:AddParticle( TEXTURES.STONES_2_NEG, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 0.5, 0.6, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetSampleProcessing( 1, 0 )
		p:SetDodge( true )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.5, 0.6, 0.6, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 10 )

	end,

	Update = function( self )

		local heading = GetPlayerCameraHeading()
		local offsetX, offsetY = ( 0.021 ) * math.sin( heading ), ( 0.021 ) * math.cos( heading )
		local p = self.Particles[2]
		p:SetTextureCoords( offsetX, ( self.TCx or 1 ) + offsetX, offsetY, ( self.TCy or 1 ) + offsetY )

	end,

	Reset = function( self )

		local x, y, z = self:GetSize()
		x, y = ( x / 200 ), ( math.max( y, z ) / 200 )
		self.TCx, self.TCy = zo_clamp( x, 1, 3 ), zo_clamp( y, 1, 3 )

		for index = 1, #self.Particles do
			self.Particles[index]:SetTextureCoords( 0, self.TCx, 0, self.TCy )
		end

		self:Update()

	end,

} )

EHT.EffectType:New( 397, "Window Trio, Arched", {

	Category = CAT.BUILD,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.WINDOWS_TRIO, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( false )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 400 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 398, "Dirt", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )
		local p

		p = self:AddParticle( TEXTURES.DIRT_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 30 )
	end,

	Reset = function( self )
		self:TileRange(512, 512, 1, 1)
		self:Update()
	end,

} )

EHT.EffectType:New( 399, "Grass", {
	Category = CAT.LAND,
	CanPitch = true,
	Init = function( self )
		self.OrderDrawLevelByIndex = true
		self.TileX, self.TileY = 0, 0
		for index = 1, 2 do
			self:AddParticle( TEXTURES.GRASS_1,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, true )
		end
		self:SetSize( 512, 512, 512 )
		self:SetColor( 0.85, 0.6, 0.2, 0.95 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 5 )
	end,
	Reset = function( self )
		local p = self.Particles
		local r, g, b, a = self:GetColor()
		p[1]:Tile( 384, 384 )
		p[2]:Tile( -314, -314, 100, 200 )
		self:Update()
		p[2]:SetVertexColors( 1, r, g, b, a )
		p[2]:SetVertexColors( 2, r, g, b, a )
		p[2]:SetVertexColors( 4, r, g, b, 0 )
		p[2]:SetVertexColors( 8, r, g, b, 0 )
	end,
} )

EHT.EffectType:New( 400, "Marble", {

	Category = CAT.BUILD,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.MARBLE_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Reset = function( self )
		self:TileRange(512, 512, 1, 1)
		self:Update()
	end,

} )

EHT.EffectType:New( 401, "Rock, 1", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.ROCK_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Reset = function( self )

		self:Tile( 512, 512 )
		self:Update()

	end,

} )

EHT.EffectType:New( 402, "Sand", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SAND_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Reset = function( self )

		self:Tile( 512, 512 )
		self:Update()

	end,

} )

EHT.EffectType:New( 403, "Wood, Planks", {

	Category = CAT.BUILD,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.WOOD_PLANKS_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Reset = function( self )

		self:Tile( 512, 512 )
		self:Update()

	end,

} )

EHT.EffectType:New( 404, "Mud, Cracked", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.CRACKS_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 0.6, 0.5, 0, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Reset = function( self )

		self:Tile( 512, 512 )
		self:Update()

	end,

} )

EHT.EffectType:New( 405, "Ground, Cracked", {
	Category = CAT.ANIM,
	CanPitch = true,

	Init = function( self )
		local p = self:AddParticle( TEXTURES.CRACKS_2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetSampleProcessing( 1.5, 0 )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 1, 0.5, 0, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 2 )
	end,
} )

EHT.EffectType:New( 406, "Metal, Sheet", {

	Category = CAT.BUILD,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.METAL_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Reset = function( self )

		self:Tile( 512, 512 )
		self:Update()

	end,

} )

EHT.EffectType:New( 407, "Glass, Stained", {

	Category = CAT.BUILD,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.GLASS_STAINED_01, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.65, 1, 1, true, false )
		p:SetTextureWrapping( true )

		p = self:AddParticle( TEXTURES.GLASS_STAINED_01_NEG, 0, 0, 0, 0, 0, 0, 0.8, 0.8, 0.8, 0.5, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetSampleProcessing( 1.7, 0 )
		p:SetDodge( true )

		self:SetSize( 200, 200, 200 )
		self:SetColor( 0, 0.5, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 200 )

	end,

	Update = function( self )

		local offsetX, offsetY = 0.015 * math.sin( CameraHeading + 0.5 * math.pi ), 0.015 * math.cos( CameraHeading + 0.5 * math.pi )
		local x1, x2, y1, y2 = self.Particles[1]:GetTextureCoords()
		self.Particles[2]:SetTextureCoords( x1 + offsetX, x2 + offsetX, y1 - offsetY, y2 - offsetY )

	end,

	Reset = function( self )

		self:Tile( 200, 200 )
		self:Update()

	end,

} )

do

	local paintingsList

	EHT.EffectType:New( 408, "Painting Slideshow, Holographic", {

		Category = CAT.PAINT,
		CanPitch = true,
		OrderDrawLevelByIndex = true,
		ResetOnPosition = true,
		ResetOnColor = true,
		ResetOnOrient = true,

		Init = function( self )
			local coordRight, coordBottom = coordRight or 1, coordBottom or 0.999 -- coordRight or 0.8, coordBottom or 0.5
			local xDefault, yDefault = 460, 287
			local p

			-- Cache the Paintings list.
			if nil == paintingsList then paintingsList = EHT.EffectType:GetFilteredEnabledList( "IsPainting", true ) end

			self.PaintingIndex = math.random( 1, #paintingsList )
			self.IntervalOffset, self.IntervalPeriod, self.Interval = FrameTime, nil, 6000

			local pIndex = self.PaintingIndex
			local pTex = paintingsList[pIndex].PaintingTexture

			p = self:AddParticle( TEXTURES.SOLID,	0, 0, 0,	0, 0, 0,		0, 0, 0, 1,		1, 1,		true, false, false )

			for index = 1, 3 do
				p = self:AddParticle( pTex,		0, 0, 0,		0, 0, 0,		0, 0, 0, 1,		1, 1,		true, true, false )
				p:SetTextureCoords( 0, coordRight, 0, coordBottom )
				p:SetSampleProcessing( 1, 0 )

				p = self:AddParticle( pTex,		0, 0, 0,		0, 0, 0,		0, 0, 0, 0,		1, 1,		true, true, false )
				p:SetTextureCoords( 0, coordRight, 0, coordBottom )
				p:SetSampleProcessing( 1, 0 )
			end

			self:SetSize( xDefault, yDefault, yDefault )
			self:SetColor( 1, 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( yDefault * 0.75, false )
		end,

		Update = function( self )
			local period = GetIntervalPeriod( self.Interval, self.IntervalOffset )
			local interval = GetLinearInterval( self.Interval, self.IntervalOffset )
			local alphaCurrent, alphaNext = 1.2 - 5 * interval, 5 * interval
			local r, g, b = self:GetColor()
			local p = self.Particles

			if period ~= self.IntervalPeriod then
				for index = 2, 6, 2 do
					p[index]:SetTextureFile( paintingsList[self.PaintingIndex].PaintingTexture )
				end
			end

			for index = 2, 6, 2 do
				local p1, p2 = p[index], p[index + 1]
				p1:SetColorOffsets(nil, nil, nil, alphaCurrent)
				p2:SetColorOffsets(nil, nil, nil, alphaNext)
			end

			self:Update()

			if period ~= self.IntervalPeriod then
				local pIndex = 1 + ( ( self.PaintingIndex + 1 ) % #paintingsList )
				local pTex = paintingsList[pIndex].PaintingTexture

				self.IntervalPeriod = period
				self.PaintingIndex = pIndex

				for index = 3, 7, 2 do
					p[index]:SetTextureFile( pTex )
				end
			end
		end,

		Reset = function( self )
			local sizeX, sizeY, sizeZ = self:GetSize()
			local baseOffset, offsetInterval = -2, zo_clamp(-math.floor(sizeX / 50), -1000, -5)
			local r, g, b = self:GetColor()
			local p = self.Particles

			p[2]:SetPositionOffsets( 0, 0, baseOffset + offsetInterval )
			p[2]:SetColorOffsets( r, 0, 0 )
			p[3]:SetPositionOffsets( 0, 0, baseOffset + offsetInterval )
			p[3]:SetColorOffsets( r, 0, 0 )

			p[4]:SetPositionOffsets( 0, 0, baseOffset + 2 * offsetInterval )
			p[4]:SetColorOffsets( 0, g, 0 )
			p[5]:SetPositionOffsets( 0, 0, baseOffset + 2 * offsetInterval )
			p[5]:SetColorOffsets( 0, g, 0 )

			p[6]:SetPositionOffsets( 0, 0, baseOffset + 3 * offsetInterval )
			p[6]:SetColorOffsets( 0, 0, b )
			p[7]:SetPositionOffsets( 0, 0, baseOffset + 3 * offsetInterval )
			p[7]:SetColorOffsets( 0, 0, b )

			self:Update()
		end,

	} )

end

EHT.EffectType:New( 409, "Sand, Pouring", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		self.CycleInterval = 2000
		self.DodgeInterval = 2131
		self.DodgeInterval2 = 1133

		self:SetSize( 200, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 250 )

		local p
		p = self:AddScaledParticle( TEXTURES.SAND_1,	1, 1,	0, 0,		0.5, 0.5, 0.5, 0.75,		1 )
		p:SetTextureWrapping( true )

		p = self:AddScaledParticle( TEXTURES.SAND_1,	1, 1,	0, 0,		1, 1, 1, 1,		1 )
		p:SetDodge( true )

	end,

	Update = function( self )

		local ps = self.Particles
		ps[1]:SetScaleOffsets( nil, -GetLinearInterval( self.CycleInterval, 0 ) )
		ps[2]:SetIntervalVertexColors( 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.4, -0.25, self.DodgeInterval, 260, 0, self.DodgeInterval2 + 260, self.DodgeInterval2 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 410, "Pet, Rabbit", {

	Category = CAT.PET,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.RABBIT_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( false )

		self:SetSize( 64, 64, 64 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 32 )

	end,

	Update = function( self )

		local x, y, z = self:GetPosition()
		local tilt = math.atan( ( CameraY - y ) / math.sqrt( ( CameraX - x ) ^ 2 + ( CameraZ - z ) ^ 2 ) )
		self.Particles[1]:SetOrientation( -tilt, CameraHeading, 0 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 411, "Pet, Poring", {

	Category = CAT.PET,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.PORING_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( false )

		self.BounceOffset, self.BounceHeight, self.BounceSound = math.random() * 1800, 32, 0
		self:SetSize( 64, 64, 64 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 32 )

	end,

	Update = function( self )

		local x, y, z = self:GetPosition()
		local tilt = math.atan( ( CameraY - y ) / math.sqrt( ( CameraX - x ) ^ 2 + ( CameraZ - z ) ^ 2 ) )
		local bounce = math.abs( GetEasedInterval( 2000, self.BounceOffset ) )
		local p = self.Particles[1]

		p:SetPosition( x, y + self.BounceHeight * bounce, z )
		p:SetOrientation( -tilt, CameraHeading, 0 )

		local ft = FrameTime
		if 0.15 > bounce and ft > self.BounceSound then
			if 1000 > zo_distance3D( CameraX, CameraY, CameraZ, x, y, z ) then
				PlaySound( "LevelUpReward_ClaimAppear" )
			end
			self.BounceSound = ft + 1000
		end

	end,

	Reset = function( self )

		local _, sizeY, sizeZ = self:GetSize()
		self.BounceHeight = 0.5 * math.min( math.max( sizeY, sizeZ ), 256 )
		self.BounceSound = 0
		self:Update()

	end,

} )

EHT.EffectType:New( 412, "Flowers, Lotus", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddScaledParticle( TEXTURES.LOTUS,			0.9, 0.9,		0, 0,		1, 1, 1, 1 )
		p = self:AddScaledParticle( TEXTURES.LOTUS_NEG,		0.9, 0.9,		0, 0,		1, 1, 1, 0.5,		3 )

		self:SetSize( 200, 200, 200 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), math.pi, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Update = function( self )

		local heading = GetPlayerCameraHeading()
		local offsetX, offsetY = ( OFFX or 0.035 ) * math.sin( heading ), ( OFFY or 0.035 ) * math.cos( heading )
		local p, pn, ps = nil, nil, self.Particles
		local scaleX, scaleY

		for index = 1, #ps, 2 do
			p, pn = ps[index], ps[index + 1]
			scaleX, scaleY = p:GetScaleOffsets()
			pn:SetScaleOffsets( scaleX + offsetX, scaleY + offsetY )
		end

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 413, "Flowers, Lotus (Trio)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddScaledParticle( TEXTURES.LOTUS,			0.6, 0.6,		-0.5, 0,		1, 1, 1, 1 )
		p = self:AddScaledParticle( TEXTURES.LOTUS_NEG,		0.6, 0.6,		-0.5, 0,		1, 1, 1, 0.5,		3 )

		p = self:AddScaledParticle( TEXTURES.LOTUS,			0.6, 0.6,		0.25, -0.5,		1, 1, 1, 1 )
		p = self:AddScaledParticle( TEXTURES.LOTUS_NEG,		0.6, 0.6,		0.25, -0.5,		1, 1, 1, 0.5,		3 )

		p = self:AddScaledParticle( TEXTURES.LOTUS,			0.6, 0.6,		0.5, 0.5,		1, 1, 1, 1 )
		p = self:AddScaledParticle( TEXTURES.LOTUS_NEG,		0.6, 0.6,		0.5, 0.5,		1, 1, 1, 0.5,		3 )

		self:SetSize( 300, 300, 300 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), math.pi, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Update = function( self )

		local heading = GetPlayerCameraHeading()
		local offsetX, offsetY = ( OFFX or 0.035 ) * math.sin( heading ), ( OFFY or 0.035 ) * math.cos( heading )
		local p, pn, ps = nil, nil, self.Particles
		local scaleX, scaleY

		for index = 1, #ps, 2 do
			p, pn = ps[index], ps[index + 1]
			scaleX, scaleY = p:GetScaleOffsets()
			pn:SetScaleOffsets( scaleX + offsetX, scaleY + offsetY )
		end

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 414, "Flowers, Water Lily", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddScaledParticle( TEXTURES.WATER_LILY,			0.9, 0.9,		0, 0,		1, 1, 1, 1 )
		p = self:AddScaledParticle( TEXTURES.WATER_LILY_NEG,		0.9, 0.9,		0, 0,		1, 1, 1, 0.5,		3 )

		self:SetSize( 200, 200, 200 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), math.pi, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Update = function( self )

		local heading = GetPlayerCameraHeading()
		local offsetX, offsetY = ( OFFX or 0.035 ) * math.sin( heading ), ( OFFY or 0.035 ) * math.cos( heading )
		local p, pn, ps = nil, nil, self.Particles
		local scaleX, scaleY

		for index = 1, #ps, 2 do
			p, pn = ps[index], ps[index + 1]
			scaleX, scaleY = p:GetScaleOffsets()
			pn:SetScaleOffsets( scaleX + offsetX, scaleY + offsetY )
		end

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 415, "Flowers, Water Lily (Trio)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddScaledParticle( TEXTURES.WATER_LILY,			0.6, 0.6,		-0.5, 0,		1, 1, 1, 1 )
		p = self:AddScaledParticle( TEXTURES.WATER_LILY_NEG,		0.6, 0.6,		-0.5, 0,		1, 1, 1, 0.5,		3 )

		p = self:AddScaledParticle( TEXTURES.WATER_LILY,			0.6, 0.6,		0.25, -0.5,		1, 1, 1, 1 )
		p = self:AddScaledParticle( TEXTURES.WATER_LILY_NEG,		0.6, 0.6,		0.25, -0.5,		1, 1, 1, 0.5,		3 )

		p = self:AddScaledParticle( TEXTURES.WATER_LILY,			0.6, 0.6,		0.5, 0.5,		1, 1, 1, 1 )
		p = self:AddScaledParticle( TEXTURES.WATER_LILY_NEG,		0.6, 0.6,		0.5, 0.5,		1, 1, 1, 0.5,		3 )

		self:SetSize( 300, 300, 300 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), math.pi, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Update = function( self )

		local heading = GetPlayerCameraHeading()
		local offsetX, offsetY = ( OFFX or 0.035 ) * math.sin( heading ), ( OFFY or 0.035 ) * math.cos( heading )
		local p, pn, ps = nil, nil, self.Particles
		local scaleX, scaleY

		for index = 1, #ps, 2 do
			p, pn = ps[index], ps[index + 1]
			scaleX, scaleY = p:GetScaleOffsets()
			pn:SetScaleOffsets( scaleX + offsetX, scaleY + offsetY )
		end

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 416, "Zelda, Master Sword", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.MASTER_SWORD,	0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false )
		p:SetTextureWrapping( false )
		p:SetTextureCoords( 0.3, 0.6, 0, 1 )

		local p = self:AddParticle( TEXTURES.MASTER_SWORD_NEG,	0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false )
		p:SetTextureWrapping( false )
		p:SetTextureCoords( 0.3, 0.6, 0, 1 )
		p:SetDodge( true )
		p:SetSampleProcessing( 20, 0 )

		self.NextSound = 0
		self:SetSize( 50, 165, 165 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 150 )

	end,

	Update = function( self )

		local p = self.Particles[2]
		local delayInterval, interval1, interval2 = GetEasedInterval( 8000, 2000 ), GetEasedInterval( 4000, 620 ), GetEasedInterval( 4000, 0 )
		local r, g, b = 0.75, 0.75, 0.75

		if 0 <= delayInterval then
			p.Texture:SetHidden( false )
			p:SetVertexColors( 1 + 2, r, g, b, 0.75 * interval1 )
			p:SetVertexColors( 4 + 8, r, g, b, 0.75 * interval2 )

			local ft = FrameTime
			if ft >= self.NextSound then
				self.NextSound = ft + 5000

				local x, y, z = self:GetPosition()
				if 550 >= zo_distance3D( CameraX, CameraY, CameraZ, x, y, z ) then
					zo_callLater( function() PlaySound( "Champion_ZoomIn" ) end, 1200 )
					zo_callLater( function() PlaySound( "Champion_ZoomOut" ) end, 3100 )
				end
			end
		else
			p.Texture:SetHidden( true )
		end

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 417, "Zelda, Spirit Stones", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.SPIRIT_STONE_1,	0, 0, -120,	0, math.rad( 90 ), 0,	1, 1, 1, 1,		0.065, 0.25,	true, false )
		p:SetTextureWrapping( false )

		local p = self:AddParticle( TEXTURES.SPIRIT_STONE_2,	0, 0, 0,	0, math.rad( 90 ), 0,	1, 1, 1, 1,		0.065, 0.25,	true, false )
		p:SetTextureWrapping( false )

		local p = self:AddParticle( TEXTURES.SPIRIT_STONE_3,	0, 0, 120,	0, math.rad( 90 ), 0,	1, 1, 1, 1,		0.065, 0.25,	true, false )
		p:SetTextureWrapping( false )

		self:SetSize( 360, 100, 100 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 250 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 418, "Rainbow", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p
		p = self:AddParticle( TEXTURES.RAINBOW_1,		0, 0, 0,		0, 0, 0,	1, 1, 1, 0.5,		1, 1,	true, false )
		p:SetTextureWrapping( false )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 250 )
		self:Update()

	end,

	Reset = function( self )

		self:SetColor( nil, nil, nil, 1 )
		self:Update()

	end,

} )

EHT.EffectType:New( 419, "Brick", {

	Category = CAT.BUILD,

	CanPitch = true,

	Init = function( self )

		local p

		self.TileX, self.TileY = 0, 0

		p = self:AddParticle( TEXTURES.BRICK_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		p = self:AddParticle( TEXTURES.BRICK_1, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 0.5, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )
		p:SetDodge( true )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 0.5, 0.25, 0.05, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 256 )

	end,

	Update = function( self )

		local offsetX, offsetY = 0.01 * math.sin( CameraHeading ), 0.01 * math.cos( CameraHeading )
		self.Particles[1]:SetTextureCoords( 0 + 0.2 * offsetX, self.TileX + 0.2 * offsetX, 0 + 0.2 * offsetY, self.TileY + 0.2 * offsetY )
		self.Particles[2]:SetTextureCoords( 0 + offsetX, self.TileX + offsetX, 0 + offsetY, self.TileY + offsetY )

	end,

	Reset = function( self )

		self:Tile( 256, 256 )
		self:Update()

	end,

} )

EHT.EffectType:New( 420, "Flames, Jet", {

	Category = CAT.ANIM,

	CanPitch = true,

	Init = function( self )

		self.IntervalDuration = 2500

		local textures = { TEXTURES.FLAME_1, TEXTURES.FLAME_1_NEG, TEXTURES.FLAME_2, TEXTURES.FLAME_2_NEG, TEXTURES.FLAME_3, TEXTURES.FLAME_3_NEG }
		local intervalOffset = 2400 * math.random()
		local numP = 18
		local c, p, texIndex

		for index = 1, numP do
			c = 0.5 + 0.5 * ( 1 / numP )
			texIndex = 1 + ( index % #textures )
			p = self:AddParticle( textures[ texIndex ],		0, 0, 0,	0, 0, 0,	c, c, c, 0,		1, 1,	true, true )
			p:SetTextureWrapping( false )
			p.IntervalOffset = intervalOffset + ( ( index * self.IntervalDuration ) % 1893 )
		end

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 100, 400, 400 )
		self:SpawnAtPlayer( 200 )
		self:SetOrientation( 0, 0, 0 )

	end,
	
	Update = function( self )

		local interval, p, p2
		local numP = #self.Particles
		local pitch, yaw = self:GetOrientation()
		local heading = 0 == pitch and CameraHeading or yaw
		local r, g, b = self:GetColor()

		for index = 1, numP, 2 do

			p = self.Particles[index]
			p2 = self.Particles[index + 1]
			interval = 2 * GetLinearInterval( self.IntervalDuration, p.IntervalOffset )

			p:SetOrientation( pitch, heading, 0 )
			p2:SetOrientation( pitch, heading, 0 )

			if 0.95 < interval and not p:GetHidden() then

				p:SetHidden( true )
				p2:SetHidden( true )

				p:SetAlpha( 0 )
				p2:SetAlpha( 0 )

				p:SetSampleProcessing( 0.8 + 0.4 * math.random(), 0.1 * math.random() )
				p2:SetSampleProcessing( 0.8 + 0.4 * math.random(), 0.1 * math.random() )
				
			elseif 0.95 >= interval then

				if 0 == ( index % 3 ) then
					p:SetTextureCoords( -0.1 + 0.01 * interval, 1.1 - 0.01 * interval, -1, 2.5 * interval )
					p2:SetTextureCoords( -0.1 + 0.01 * interval, 1.1 - 0.01 * interval, -1, 2.5 * interval )
				else
					p:SetTextureCoords( 1.1 - 0.01 * interval, -0.1 + 0.01 * interval, -1, 2.5 * interval )
					p2:SetTextureCoords( 1.1 - 0.01 * interval, -0.1 + 0.01 * interval, -1, 2.5 * interval )
				end

				p:SetAlpha( math.sin( 1.05 * interval * math.pi ) )
				p2:SetAlpha( math.sin( 1.05 * interval * math.pi ) )

				p:SetHidden( false )
				p2:SetHidden( false )

			end

		end

	end,

	Reset = function( self )
	
		self:Update()

	end,

} )

EHT.EffectType:New( 421, "God Rays", {

	Category = CAT.LIGHT,

	CanPitch = true,

	Init = function( self )

		local p

		self.IntervalOffset = 10000 * math.random()

		self:AddParticle( TEXTURES.LIGHT_RAYS_2,		0, 0, 0,	0, 0, 0,	0.9, 0.9, 0.9, 0.5,		1, 1,	true, true, false )
		self:AddParticle( TEXTURES.LIGHT_RAYS_2,		0, 0, 0,	0, 0, 0,	1, 0.7, 0.5, 0.5,		1, 1,	true, true, false )
		self:AddParticle( TEXTURES.LIGHT_RAYS_2,		0, 0, 0,	0, 0, 0,	1, 1, 1, 0.7,			1, 1,	true, true, false )

		p = self:AddParticle( TEXTURES.LIGHT_RAYS_2,	0, 0, 0,	0, 0, 0,	0, 1, 1, 1,				1, 1,	true, true, false )
		p:SetTextureCoords( 0, 1, -0.2, 1 )
		p:SetDodge( true )

		p = self:AddParticle( TEXTURES.LIGHT_RAYS_2,	0, 0, 0,	0, 0, 0,	1, 0, 1, 1,				1, 1,	true, true, false )
		p:SetTextureCoords( 0, 1, 0, 1.2 )
		p:SetDodge( true )

		self:SetColor( 0.65, 1, 0.4, 1 )
		self:SetSize( 1500, 1500, 1500 )
		self:SpawnAtPlayer( 500 )
		self:SetOrientation( 0, 0, 0 )

	end,
	
	Update = function( self )

		local interval1, interval2, interval3 = 0.5 + 0.5 * math.abs( GetEasedInterval( 9981, self.IntervalOffset ) ), 0.5 + 0.5 * math.abs( GetEasedInterval( 11313, self.IntervalOffset ) ), 0.5 + 0.5 * math.abs( GetEasedInterval( 13309, self.IntervalOffset ) )
		local alpha = self:GetViewingAngleAlpha()
		local r, g, b = self:GetColor()
		local p, tex

		p = self.Particles[1]
		p:SetTextureCoords( 0, 1 + 0.1 * interval2, -0.1 - 0.1 * interval2, 1 + 0.1 * interval2 )
		p:SetVertexColors( 1, r, g, b, 0 )
		p:SetVertexColors( 2 + 4 + 8, r * 0.9, g * 0.9, b * 0.9, 0.75 * interval1 * alpha )

		p = self.Particles[2]
		p:SetTextureCoords( 0.05, 1 - 0.1 * interval1, 0.1 * interval1, 1 - 0.1 * interval1 )
		p:SetVertexColors( 1, r, g, b, 0 )
		p:SetVertexColors( 2 + 4 + 8, r * 1, g * 0.7, b * 0.5, 0.75 * interval3 * alpha )

		p = self.Particles[3]
		p:SetTextureCoords( -0.05, 0.9 + 0.1 * interval3, 0.1 * interval3, 1.1 - 0.1 * interval3 )
		p:SetVertexColors( 1, r, g, b, 0 )
		p:SetVertexColors( 2 + 4 + 8, r * 1, g * 1, b * 1, 0.75 * interval2 * alpha )

		tex = self.Particles[4].Texture
		p:SetVertexColors( 2, r, g, b, interval2 * alpha )
		p:SetVertexColors( 4, r, g, b, interval3 * alpha )
		p:SetVertexColors( 8, r, g, b, 1 - interval1 * alpha )

		tex = self.Particles[5].Texture
		p:SetVertexColors( 2, r, g, b, interval3 * alpha )
		p:SetVertexColors( 4, r, g, b, interval2 * alpha )
		p:SetVertexColors( 8, r, g, b, interval1 * alpha )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 422, "Spotlight, Ring", {

	Category = CAT.LIGHT,

	CanPitch = true,

	Init = function( self )

		self:AddParticle( TEXTURES.CIRCLE_SOFT, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.4, 1, 1, true, true, false )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 0.8, 0.8, 0.6, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 423, "Guard, Silhouette", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.SILHOUETTE_GUARD, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetTextureCoords( 0.36, 0.64, 0, 1 )

		self.RelativeYaw = 0
		self:SetSize( 85, 250, 250 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 128 )

	end,

	Update = function( self )

		local x, y, z = self:GetPosition()
		local tilt = zo_clamp( math.atan( ( CameraY - y ) / math.sqrt( ( CameraX - x ) ^ 2 + ( CameraZ - z ) ^ 2 ) ), math.rad( -10 ), math.rad( 10 ) )
		self.Particles[1]:SetOrientation( -tilt, CameraHeading + self.RelativeYaw, 0 )

	end,

	Reset = function( self )

		local _, yaw = self:GetOrientation()
		self.RelativeYaw = yaw >= math.pi and math.pi or 0
		self:Update()

	end,

} )

do

	local batIndex = 0

	EHT.EffectType:New( 424, "Pet, Flying Bat", {

		Category = CAT.PET,

		CanPitch = true,

		Init = function( self )

			self.AnimationInterval = 500 + 300 * math.random()
			self.AnimationOffset = 0.3333 * batIndex * self.AnimationInterval
			batIndex = ( batIndex + 1 ) % 3

			local p
			p = self:AddParticle( TEXTURES.BAT_FLYING_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, true, false, false )
			p = self:AddParticle( TEXTURES.BAT_FLYING_2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, true, false, false )
			p = self:AddParticle( TEXTURES.BAT_FLYING_3, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, true, false, false )

			self.SwapX = false
			self.XCoord1, self.XCoord2 = 0, 1
			self:SetSize( 32, 32, 32 )
			self:SetColor( 1, 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 250 )

		end,

		Update = function( self )

			local x, y, z = self:GetPosition()
			local tilt = zo_clamp( math.atan( ( CameraY - y ) / math.sqrt( ( CameraX - x ) ^ 2 + ( CameraZ - z ) ^ 2 ) ), math.rad( -10 ), math.rad( 10 ) )
			local frame = round( 4 * GetLinearInterval( self.AnimationInterval, self.AnimationOffset ) )
			local frameIndex = zo_clamp( frame, 1, 4 )
			local p

			frameIndex = 4 > frameIndex and frameIndex or 2

			for index = 1, #self.Particles do
				p = self.Particles[index]
				p:SetOrientation( -tilt, CameraHeading, 0 )

				if frameIndex == index then

					if 3 == frameIndex then self.SwapX = true end

					if 1 == frameIndex and self.SwapX then
						self.SwapX = false

						if 0 == self.XCoord1 then
							self.XCoord1, self.XCoord2 = 1, 0
						else
							self.XCoord1, self.XCoord2 = 0, 1
						end
					end

					p:SetTextureCoords( self.XCoord1, self.XCoord2, 0, 1 )
					p:SetAlpha( 1 )

				else
					p:SetAlpha( 0 )
				end
			end

		end,

		Reset = function( self )

			self:Update()

		end,

	} )

end

do

	local numP, scaleX, scaleY = 5, 6, 3.5

	EHT.EffectType:New( 425, "Fish, School of Clownfish", {

		Category = CAT.PET,

		CanPitch = true,

		Init = function( self )

			local ft = FrameTime
			local p, oR, oX, oY, x, y

			self.RangeOffsetX, self.MinOffsetX, self.MaxOffsetX = 1 + 2 * scaleX, -scaleX, scaleX
			self.RangeOffsetY, self.MinOffsetY, self.MaxOffsetY = 1 + 2 * scaleY, -scaleY, scaleY

			for index = 1, numP do
				oR = ( 1 == index and 0.2 or 2 == index and 0.4 or 3 == index and -0.1 or 0 )
				oX, oY = ( ( -0.5 + index ) / numP ), ( ( -0.5 + index + oR ) / numP )
				p = self:AddParticle( TEXTURES.FISH_1,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
				p.tX, p.tY, p.dX, p.sX = oX, oY, ( 0 == index % 2 ) and ( index / 100 ) or -( index / 100 ), ft + index * 500

				x = self.MinOffsetX + p.tX * self.RangeOffsetX
				p.tY = self.MinOffsetY + p.tY * self.RangeOffsetY
				p:SetTextureCoords( self.MinOffsetX + x, self.MaxOffsetX + x, self.MinOffsetY + p.tY, self.MaxOffsetY + p.tY )
			end

			self:SetSize( 300, 150, 150 )
			self:SetColor( 1, 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 150 )

		end,

		Update = function( self )

			local ft = FrameTime
			local r, g, b, a = self:GetColor()
			local numP = #self.Particles
			local cInterval, p, x, y

			for index = 1, numP do
				p = self.Particles[index]

				if ft > p.sX then
					p.sX = ft + 2000 + 4000 * math.random()
					local sign = 0 < p.dX and -1 or 1
					p.dX = sign * 0.01 * ( 1 + ( 10 * math.random() ) )
				else
					cInterval = 0.05 * index * math.abs( GetEasedInterval( 1000 + 250 * index, index * 250 ) )
					p.tX = zo_clamp( p.tX + p.dX, self.MinOffsetX + 1, self.MaxOffsetX - 1 )
					y = 0.25 * cInterval + p.tY

					if 0 < p.dX then
						p:SetTextureCoords( self.MinOffsetX + p.tX, 1 + self.MaxOffsetX + p.tX + cInterval, self.MinOffsetY + y, self.MaxOffsetY + y )
					else
						p:SetTextureCoords( 1 + self.MaxOffsetX - p.tX + cInterval, self.MinOffsetX - p.tX, self.MinOffsetY + y, self.MaxOffsetY + y )
					end
				end
			end

		end,

		Reset = function( self )

			self:Update()

		end,

	} )

end

do

	local repeatDelayDuration = 20000
	local intervalDuration1 = 8 * 1000
	local intervalDuration2 = intervalDuration1 + ( 10 * 750 )
	local intervalDuration3 = intervalDuration2 + ( 12 * 500 )
	local intervalDuration4 = intervalDuration3 + ( 16 * 300 )

	local function PlaySoundFX() PlaySound( "Champion_SpinnerDown" ) end

	EHT.EffectType:New( 426, "Suspense", {

		Category = CAT.SOUND,

		Overlay = true,

		Init = function( self )

			self:SetAutoDrawLevelEnabled( false )
			self:AddParticle( "", 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, true, false )
			self:SetColor( 1, 1, 1, 1 )
			self:SetSize( 1000, 1000, 1000 )
			self.CurrentSize = self:GetSize()
			self.StartTimer, self.NextTimer = 0, 0
			self:SpawnAtPlayer( 0 )

		end,

		Update = function( self )

			local tex = self.Particles[1].Texture
			local cR, cG, cB, alpha = tex:GetColor()
			local size = self:GetSize()
			local x, y, z = self:GetPosition()

			if zo_distance3D( PlayerX, PlayerY, PlayerZ, x, y, z ) <= 0.5 * size then

				local ft = FrameTime

				if 0 >= self.StartTimer then
					self.NextTimer = ft + ( 0 == self.StartTimer and 1000 or repeatDelayDuration )
					self.StartTimer = ft
				end

				local interval = ft - self.NextTimer
				local totalDuration = ft - self.StartTimer
				local crescendo = 0

				if intervalDuration1 > totalDuration then
					crescendo = 1000
				elseif intervalDuration2 > totalDuration then
					crescendo = 750
				elseif intervalDuration3 > totalDuration then
					crescendo = 500
				elseif intervalDuration4 > totalDuration then
					crescendo = 300
				else
					crescendo, self.StartTimer, self.NextTimer = 0, -1, -1
				end

				if 0 < interval and 0 < crescendo then
					PlaySound( "Champion_SpinnerUp" )
					zo_callLater( PlaySoundFX, crescendo )
					self.NextTimer = ft + 2 * crescendo
				end

			else
				self.StartTimer, self.NextTimer = 0, 0
			end

			tex:SetAlpha( alpha )

		end,

		Reset = function( self )

			local newSize1, newSize2, newSize3 = self:GetSize()
			if self.CurrentSize ~= newSize1 then
				self:SetSize( newSize1, newSize1, newSize1 )
			elseif self.CurrentSize ~= newSize2 then
				self:SetSize( newSize2, newSize2, newSize2 )
			else
				self:SetSize( newSize3, newSize3, newSize3 )
			end
			self.CurrentSize = self:GetSize()
			self:Update()

			local tex = self.Particles[1].Texture
			tex:Destroy3DRenderSpace()
			tex:SetHidden( true )

		end,

	} )

end

EHT.EffectType:New( 427, "Window, Dual Side Hung", {

	Category = CAT.BUILD,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.WINDOW_GOTHIC_2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )

		self.RelativeYaw = 0
		self:SetSize( 256, 256, 256 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 128 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 428, "Door, Intricately Carved", {

	Category = CAT.BUILD,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.DOOR_GOTHIC_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )

		self.RelativeYaw = 0
		self:SetSize( 512, 512, 512 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 128 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 429, "Wax Figure, Breton Warrior", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.WARRIOR_BRETON, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )

		self.RelativeYaw = 0
		self:SetSize( 256, 256, 256 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 128 )

	end,

	Update = function( self )

		local x, y, z = self:GetPosition()
		local tilt = zo_clamp( math.atan( ( CameraY - y ) / math.sqrt( ( CameraX - x ) ^ 2 + ( CameraZ - z ) ^ 2 ) ), math.rad( -10 ), math.rad( 10 ) )
		self.Particles[1]:SetOrientation( -tilt, CameraHeading + self.RelativeYaw, 0 )

	end,

	Reset = function( self )

		local _, yaw = self:GetOrientation()
		self.RelativeYaw = yaw >= math.pi and math.pi or 0
		self:Update()

	end,

} )

EHT.EffectType:New( 430, "Wax Figure, Khajiit Warrior", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.WARRIOR_KHAJIIT, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )

		self.RelativeYaw = 0
		self:SetSize( 256, 256, 256 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 128 )

	end,

	Update = function( self )

		local x, y, z = self:GetPosition()
		local tilt = zo_clamp( math.atan( ( CameraY - y ) / math.sqrt( ( CameraX - x ) ^ 2 + ( CameraZ - z ) ^ 2 ) ), math.rad( -10 ), math.rad( 10 ) )
		self.Particles[1]:SetOrientation( -tilt, CameraHeading + self.RelativeYaw, 0 )

	end,

	Reset = function( self )

		local _, yaw = self:GetOrientation()
		self.RelativeYaw = yaw >= math.pi and math.pi or 0
		self:Update()

	end,

} )

EHT.EffectType:New( 431, "Water, Reflection", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		self:AddParticle( TEXTURES.SOLID, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 0.1, 1, 1, true, false, true )

		local p
		for index = 1, 4 do
			p = self:AddParticle( TEXTURES.WATER_REFLECTION_1, 0, 0, 0, math.rad( 90 ), 0, 0, 0.6 + 0.1 * index, 0.6 + 0.1 * index, 0.6 + 0.1 * index, 0.3, 1, 1, true, false, true )
			p:SetDesaturation( 1 )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 15 )

	end,

	Update = function( self )

		for index = 2, 5 do
			self.Particles[index]:SetSampleProcessing( 2 + 0.5 * GetEasedInterval( 2000, ( index - 2 ) * 500 ), 0 )
		end

		local offset = GetLinearInterval( 60000, 0 )
		local x, y = ( self.TileX or 1 ) + offset, ( self.TileY or 1 ) + 2 * offset

		self.Particles[2]:SetTextureCoords( x, offset, 2 * offset, y )
		self.Particles[5]:SetTextureCoords( offset, x, 2 * offset, y )
		self.Particles[3]:SetTextureCoords( offset, x, y, 2 * offset )
		self.Particles[4]:SetTextureCoords( x, offset, y, 2 * offset )

	end,

	Reset = function( self )

		self:Update()
		self:Tile( 4096, 4096 )

		for index = 1, 4 do
			self.Particles[index + 1]:SetColor( 0.6 + 0.1 * index, 0.6 + 0.1 * index, 0.6 + 0.1 * index, 0.3 )
		end

	end,

} )

AddWaterRipplesToEffect( EHT.EffectType:New( 432, "Water, Coldharbour", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		self:AddParticle( "art/fx/texture/modelfxtextures/solidblue.dds", 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 0.55, 1, 1, true, false, true )

		local p
		for index = 1, 4 do
			p = self:AddParticle( TEXTURES.WATER_REFLECTION_1, 0, 0, 0, math.rad( 90 ), 0, 0, 0.5, 0.25, 0.15, 1, 1, 1, true, false, true )
			p:SetDesaturation( 0.5 )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.7, 0.9, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 15 )

	end,

	Update = function( self )

		for index = 2, 5 do
			self.Particles[index]:SetSampleProcessing( 2 + 0.5 * GetEasedInterval( 2000, ( index - 2 ) * 500 ), 0 )
		end

		local offset = GetLinearInterval( 60000, 0 )
		local x, y = ( self.TileX or 1 ) + offset, ( self.TileY or 1 ) + 2 * offset

		self.Particles[2]:SetTextureCoords( x, offset, 2 * offset, y )
		self.Particles[5]:SetTextureCoords( offset, x, 2 * offset, y )
		self.Particles[3]:SetTextureCoords( offset, x, y, 2 * offset )
		self.Particles[4]:SetTextureCoords( x, offset, y, 2 * offset )

	end,

	Reset = function( self )
		self:Update()
		self:TileRange(4096, 4096, 1, 5)
	end,

} ), nil, 1, 0.5, 1 )

AddWaterRipplesToEffect( EHT.EffectType:New( 433, "Oil, Clockwork City", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		self:AddParticle( TEXTURES.SOLID, 0, 0, 0, math.rad( 90 ), 0, 0, 0.15, 0.15, 0.15, 1, 1, 1, true, false, true )

		local p
		for index = 1, 4 do
			p = self:AddParticle( TEXTURES.WATER_REFLECTION_1, 0, 0, 0, math.rad( 90 ), 0, 0, 0.65, 0.25, 0.15, 0.15, 1, 1, true, false, true )
			p:SetDesaturation( 0.75 )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 15 )

	end,

	Update = function( self )

		for index = 2, 5 do
			self.Particles[index]:SetSampleProcessing( 6 + 0.75 * GetEasedInterval( 2000, ( index - 2 ) * 500 ), 0 )
		end

		local x, y = self.TileX or 1, self.TileY or 1
		local offset = GetLinearInterval( 60000, 0 )
		x, y = x + offset, y + offset

		self.Particles[2]:SetTextureCoords( x, offset, offset, y )
		self.Particles[5]:SetTextureCoords( offset, x, offset, y )
		self.Particles[3]:SetTextureCoords( offset, x, y, offset )
		self.Particles[4]:SetTextureCoords( x, offset, y, offset )

	end,

	Reset = function( self )
		self:Update()
		self:TileRange(4096, 4096, 1, 5)
	end,

} ) )

local function AddAuroraSkyEffect( id, name, isNight )
	local maxAlpha = isNight and 0.5 or 0.5
	local maxRGB = isNight and 1 or 3
	local top = TEXTURES.TRANSPARENT
	local sides = {
		{ Texture = TEXTURES.AURORA_1, Stretch = true, Wrap = false, X1 = 0, X2 = 1, Y1 = 0, Y2 = 1, R = 1, G = 1, B = 1, A = 1, SampleRGB = 1.0, AddColor = true },
		{ Texture = TEXTURES.AURORA_1, Stretch = true, Wrap = false, X1 = 0, X2 = 1, Y1 = 0, Y2 = 1, R = 1, G = 1, B = 1, A = 1, SampleRGB = 1.0, AddColor = true },
		{ Texture = TEXTURES.AURORA_1, Stretch = true, Wrap = false, X1 = 0, X2 = 1, Y1 = 0, Y2 = 1, R = 1, G = 1, B = 1, A = 1, SampleRGB = 1.0, AddColor = true },
		--{ Texture = TEXTURES.AURORA_1, Stretch = true, Wrap = false, X1 = 0, X2 = 1, Y1 = 0, Y2 = 1, R = 1, G = 1, B = 1, A = 1, SampleRGB = 1.0, AddColor = true },
		--{ Texture = TEXTURES.AURORA_1, Stretch = true, Wrap = false, X1 = 0, X2 = 1, Y1 = 0, Y2 = 1, R = 1, G = 1, B = 1, A = 1, SampleRGB = 1.0, AddColor = true },
		--{ Texture = TEXTURES.AURORA_1, Stretch = true, Wrap = false, X1 = 0, X2 = 1, Y1 = 0, Y2 = 1, R = 1, G = 1, B = 1, A = 1, SampleRGB = 1.0, AddColor = true },
	}

	if isNight then
		table.insert( sides, { Texture = TEXTURES.BLACK, Stretch = true, R = 0, G = 0, B = 0, A = 1, CanModifyColor = false, } )
		top = TEXTURES.SOLID
	end

	return AddSkyEffect(
		id, name,
		-- Options
		{ CanModifyTopColor = false },
		-- Side Textures Table
		sides,
		-- Top Texture Filename
		top,
		-- Reset Handler
		function( self )
			local faces = self.TextureFaces

			local top = faces[1][1]
			top:SetCanModifyColor( true )
			top:SetColor( 0, 0, 0, isNight and 1 or 0 )
			top:SetCanModifyColor( false )

			self.FaceState = { }
			for index = 2, 4 do -- 7 do
				table.insert( self.FaceState, { faces[index], 0 } )
			end
		end,
		-- Update Handler
		function( self )
			local states = self.FaceState
			local ft = FrameTime
			local r, g, b = self:GetColor()
			local mr = math.random
			local maxModulo, rotationModulo = 8, 3

			for index, state in ipairs( states ) do
				local faces, nextMove = state[1], state[2]
				local numFaces = #faces

				if ft > nextMove then
					local modulo = ( ( self.FaceModulo or 0 ) + 1 ) % maxModulo
					self.FaceModulo = modulo
					local mod = modulo / maxModulo
					local y1, y2 = (C1 or 1) + mod, (C2 or 0.2) -1 + mod
					local x1, x2 = 0, 1 + 0.5 * mr()
					local interval = mr( 3000, 5000 )

					nextMove = ft + interval
					state[2], state[3] = nextMove, interval
					state[4], state[5], state[6] = r * ( 0.4 + 0.4 * mr() ), g * ( 0.4 + 0.4 * mr() ), b * ( 0.4 + 0.4 * mr() )

					ProjectCylinderTextureFaces( faces, 0, x1, x2, y1, y2, 0, ( ( modulo % rotationModulo ) / rotationModulo ) + 0.2 * mr() )
				end

				local interval = state[3]
				local progress = 1 - ( ( nextMove - ft ) / interval )
				local fr, fg, fb = state[4], state[5], state[6]
				local sinP = math.sin( math.pi * progress )
				local rgb = maxRGB * sinP
				local alphaMod = index % 4
				local alpha1, alpha2

				if 0 == alphaMod then
					alpha1 = maxAlpha * sinP
					alpha2 = maxAlpha * ( -1 + 2 * sinP )
				elseif 1 == alphaMod then
					alpha1 = maxAlpha * ( -1 + 2 * sinP )
					alpha2 = maxAlpha * sinP
				elseif 2 == alphaMod then
					alpha1 = maxAlpha * ( -1 + 2 * sinP )
					alpha2 = maxAlpha * ( -1 + 2 * sinP )
				else
					alpha1 = maxAlpha * sinP
					alpha2 = maxAlpha * sinP
				end

				for faceIndex = 1, numFaces do
					local face = faces[faceIndex]
					local p1, p2 = face.ProjectionX1, face.ProjectionX2

					face:SetVertexColors( 1 + 2, zo_lerp( 0.5 * fr, fr, p1 ), zo_lerp( 0.5 * fg, fg, p1 ), zo_lerp( 0.5 * fb, fb, p1 ), zo_lerp( alpha1, alpha2, p1 ) )
					face:SetVertexColors( 4 + 8, zo_lerp( 0.7 * fr, 1.2 * fr, p2 ), zo_lerp( 0.6 * fg, fg, p2 ), zo_lerp( 0.7 * fb, fb, p2 ), zo_lerp( alpha1, alpha2, p2 ) )
					face:SetSampleProcessing( rgb, 0 )
				end
			end
		end
	)
end

EHT.EffectType:SetDefaultDateAdded( 1572415295 )

AddAuroraSkyEffect( 434, "Aurora Borealis, Night", true )

EHT.EffectType:SetDefaultDateAdded( 1500000000 )

EHT.EffectType:New( 435, "Tree, Dense Maple (Auridon)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local c, p

		for index = 0, 11 do
			c = 1 - 0.1 * ( index % 7 )
			p = self:AddParticle( TEXTURES.TREE_MAPLE_1, 0, 0, 0, 0, math.rad( 15 * index ), 0, 1, 1, 1, 0.75, 1, 1, true, false, false )
			p:SetSampleProcessing( 1 + 0.1 * ( index % 3 ), 0 )
			p:SetColorOffsets( c, c, c, 0.75 )
			if 0 == index % 2 then p:SetTextureCoords( -0.06 * ( index % 6 ), 1 + 0.06 * ( index % 6 ), -0.09 * ( index % 4 ), 1 ) end
		end

		self.RelativeYaw = 0
		self:SetSize( 1500, 1500, 1500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 750 )

	end,

	Reset = function( self )

		self:Update()

		for index = 1, #self.Particles do
			self.Particles[index]:SetVertexColors( 4 + 8, 1, 1, 1, 1 )
		end

	end,

} )

EHT.EffectType:New( 436, "Tree, Maple (Summerset)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		for index = 0, 5 do
			c = 1 - 0.1 * ( index % 3 )
			p = self:AddParticle( TEXTURES.TREE_MAPLE_2, 0, 0, 0, 0, math.rad( 30 * index ), 0, 1, 1, 1, 0.75, 1, 1, true, false, false )
			p:SetSampleProcessing( 1 + 0.1 * ( index % 3 ), 0 )
			p:SetColorOffsets( c, c, c, 0.75 )
			if 0 == index % 2 then p:SetTextureCoords( -0.06 * ( index % 6 ), 1 + 0.06 * ( index % 6 ), -0.04 * ( index % 4 ), 1 ) end
		end

		self.RelativeYaw = 0
		self:SetSize( 1500, 1500, 1500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 750 )

	end,

	Reset = function( self )

		self:Update()

		for index = 1, #self.Particles do
			self.Particles[index]:SetVertexColors( 4 + 8, 1, 1, 1, 1 )
		end

	end,

} )

EHT.EffectType:New( 437, "Tree, Maple (Stormhaven)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		for index = 0, 5 do
			c = 1 - 0.1 * ( index % 3 )
			p = self:AddParticle( TEXTURES.TREE_MAPLE_3, 0, 0, 0, 0, math.rad( 30 * index ), 0, 1, 1, 1, 0.75, 1, 1, true, false, false )
			p:SetSampleProcessing( 1 + 0.1 * ( index % 3 ), 0 )
			p:SetColorOffsets( c, c, c, 0.75 )
			if 0 == index % 2 then p:SetTextureCoords( -0.06 * ( index % 6 ), 1 + 0.06 * ( index % 6 ), -0.09 * ( index % 4 ), 1 ) end
		end

		self.RelativeYaw = 0
		self:SetSize( 1500, 1500, 1500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 750 )

	end,

	Reset = function( self )

		self:Update()

		for index = 1, #self.Particles do
			self.Particles[index]:SetVertexColors( 4 + 8, 1, 1, 1, 1 )
		end

	end,

} )

EHT.EffectType:New( 438, "Sword, Ancient Elven", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SWORD_DAEDRIC_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetSize( 128, 128, 128 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

AddSkyEffect(

	439, "Galaxy",

	-- Options
	{ },

	-- Side Textures Table
	{
		{
			Texture = TEXTURES.SKY_STARS_2,
			Stretch = true, Wrap = true, X1 = 0, X2 = 2,
			MaxVertexAlphas = { 0, 0, 1, 1, },
		},
		{ Texture = TEXTURES.BLACK, Stretch = true, R = 0, G = 0, B = 0, A = 1, },
	},

	-- Top Texture Filename
	TEXTURES.SKY_STARS_1,

	-- Reset Handler
	nil,

	-- Update Handler
	nil

)

EHT.EffectType:New( 440, "Dragon Priest Mask, Nahkriin", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.MASK_NAHKRIIN, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 32, 32, 32 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 441, "Tree Bark", {

	Category = CAT.BUILD,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.BARK_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 512, 512, 512 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Reset = function( self )

		self:Tile( 512, 512 )
		self:Update()

	end,

} )

EHT.EffectType:New( 442, "Lily Pads, Cluster", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.LILY_PADS_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SetSize( 256, 256, 256 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 443, "Sword, Ebony", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SWORD_EBONY_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 128, 128, 128 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 444, "Mace, Redguard", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.MACE_REDGUARD_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 128, 128, 128 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 445, "Wabbajack, Wabbajack!", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.WABBAJACK_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 128, 128, 128 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 446, "Battle Axe, Glass", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.AXE_GLASS_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 128, 128, 128 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 447, "Axe, Glass", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.AXE_GLASS_2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 128, 96, 96 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 448, "Shield, Round", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SHIELD_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 128, 128, 128 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 449, "Shield, Ayleid", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SHIELD_AYLEID_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 128, 128, 128 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 450, "Sword, Daedric", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SWORD_DAEDRIC_2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 128, 128, 128 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 451, "Staff, Dragon", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.STAFF_DRAGON_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 128, 128, 128 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 452, "Bow, Daedric", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.BOW_DAEDRIC_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 128, 128, 128 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 453, "Sword, Iron", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SWORD_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetSampleProcessing( 1.1, 0 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 128, 128, 128 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 454, "Tree, Cherry Blossom (Pink)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local c, p

		for index = 0, 5 do
			c = 1 - 0.1 * ( index % 7 )
			p = self:AddParticle( TEXTURES.TREE_CHERRY_BLOSSOM_1, 0, 0, 0, 0, math.rad( 30 * index ), 0, 1, 1, 1, 0.75, 1, 1, true, false, false )
			p:SetSampleProcessing( 1 + 0.1 * ( index % 3 ), 0 )
			p:SetColorOffsets( c, c, c, 0.75 )
			if 0 == index % 2 then p:SetTextureCoords( -0.06 * ( index % 6 ), 1 + 0.06 * ( index % 6 ), -0.09 * ( index % 4 ), 1 ) end
		end

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 2500, 1700, 1700 )
		self:SpawnAtPlayer( 850, false )

	end,

	Reset = function( self )

		self:Update()

		for index = 1, #self.Particles do
			self.Particles[index]:SetVertexColors( 4 + 8, 1, 1, 1, 1 )
		end

	end,

} )

EHT.EffectType:New( 455, "Tree, Cherry Blossom (Purple)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local c, p

		for index = 0, 5 do
			c = 1 - 0.1 * ( index % 7 )
			p = self:AddParticle( TEXTURES.TREE_CHERRY_BLOSSOM_2, 0, 0, 0, 0, math.rad( 30 * index ), 0, 1, 1, 1, 0.75, 1, 1, true, false, false )
			p:SetSampleProcessing( 1 + 0.1 * ( index % 3 ), 0 )
			p:SetColorOffsets( c, c, c, 0.75 )
			if 0 == index % 2 then p:SetTextureCoords( -0.06 * ( index % 6 ), 1 + 0.06 * ( index % 6 ), -0.09 * ( index % 4 ), 1 ) end
		end

		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 1500, 1300, 1300 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

		for index = 1, #self.Particles do
			self.Particles[index]:SetVertexColors( 4 + 8, 1, 1, 1, 1 )
		end

	end,

} )

EHT.EffectType:New( 456, "Wisteria, Cluster", {
	Category = CAT.LAND,
	CanPitch = true,
	Init = function( self )
		self:AddParticle( TEXTURES.WISTERIA_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 256, 256, 256 )
		self:SpawnAtPlayer()
	end,
	Reset = function( self )
		self:Update()
	end,
} )

EHT.EffectType:New( 457, "Wisteria, Vines", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		self:AddParticle( TEXTURES.WISTERIA_2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 700, 500, 500 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 458, "Bush, Rose", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		self:AddParticle( TEXTURES.BUSH_ROSE_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 300, 300, 300 )
		self:SpawnAtPlayer()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 459, "Tree, Pink Trumpet", {
	Category = CAT.LAND,
	CanPitch = true,
	Init = function( self )
		local c, p
		for index = 0, 5 do
			c = 1 - 0.1 * ( index % 7 )
			p = self:AddParticle( TEXTURES.TREE_PINK_TRUMPET_1, 0, 0, 0, 0, math.rad( 30 * index ), 0, 1, 1, 1, 0.75, 1, 1, true, false, false )
			p:SetSampleProcessing( 1 + 0.1 * ( index % 3 ), 0 )
			p:SetColorOffsets( c, c, c, 0.75 )
			if 0 == index % 2 then p:SetTextureCoords( -0.06 * ( index % 6 ), 1 + 0.06 * ( index % 6 ), -0.09 * ( index % 4 ), 1 ) end
		end
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 900, 900, 900 )
		self:SpawnAtPlayer()
	end,
	Reset = function( self )
		self:Update()
		for index = 1, #self.Particles do
			self.Particles[index]:SetVertexColors( 4 + 8, 1, 1, 1, 1 )
		end
	end,
} )

EHT.EffectType:New( 460, "Smoke", {
	Category = CAT.ANIM,
	CanPitch = true,
	OrderDrawLevelByIndex = true,
	ResetOnScale = true,
	Init = function( self )
		self.Interval = 8000
		self:SetColor( 0.65, 0.65, 0.65, 1 )
		self:SetSize( 250, 500, 500 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer()

		local numP = 10
		for index = 1, numP do
			local c = 0.5 * ( ( index % 5 ) / 4 )
			local p = self:AddParticle( TEXTURES.SMOKE_3,	0, 0, 0,	0, 0, 0,	1, 1, 1, 0,		1, 1,	true, false, false )
			p:SetSampleProcessing( 0.65 + c )
			p.AlphaLevel = 0.65 + 0.35 * Ease2( index / ( 1 + numP ) )
		end
	end,
	Update = function( self )
		local ps = self.Particles
		local numP = #ps
		local interval = self.Interval
		local tcx, tcy = self.TCX, self.TCY

		for index, p in ipairs( ps ) do
			local ratio = ( index - 1 ) / numP
			local position = GetLinearInterval( interval, ratio * interval )
			local offset = VariableEaseIn( 1 - position, 1.4 ) * ( 0.5 + 0.5 * ratio ) * 1.5
			local x1, x2 = -tcx - offset, 1 + tcx + offset
			local y1, y2

			local mod = index % 4
			if 0 == mod or 2 == mod then
				local t = x1
				x1 = x2
				x2 = t
			end
			if 1 == mod or 2 == mod then
				y1, y2 = 1 + tcy - position * tcy, -position * tcy
			else
				y1, y2 = -tcy + position * tcy, 1 + position * tcy
			end

			p:SetTextureCoords( x1, x2, y1, y2 )
			p:SetColorOffsets( nil, nil, nil, p.AlphaLevel * VariableEase( position, 1.4 ) )
		end

		self:Update()
	end,
	Reset = function( self )
		local sizeX, sizeY, sizeZ = self:GetSize()
		self.TCX, self.TCY = 0, 0.5 * ( sizeY / sizeX )
		self.Interval = 8000 * zo_clamp( sizeY / sizeX, 1, 2 )
	end,
} )

AddTimeRiftEffect( 461, "Time Rift, Unstable", true )

AddWaterRipplesToEffect( EHT.EffectType:New( 462, "Water, Coldharbour (Round)", {

	Category = CAT.LAND,

	CanPitch = true,

	OrderDrawLevelByIndex = true,

	Init = function( self )

		self:AddParticle( TEXTURES.WATER_CIRCLE, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 0.55, 1, 1, true, false, true )

		local p
		for index = 1, 4 do
			p = self:AddParticle( TEXTURES.WATER_REFLECTION_1, 0, 0, 0, math.rad( 90 ), 0, 0, 0.5, 0.25, 0.15, 1, 1, 1, true, false, true )
			p:SetDesaturation( 0.5 )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.7, 0.9, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 15 )

	end,

	Update = function( self )

		for index = 2, 5 do
			self.Particles[index]:SetSampleProcessing( 2 + 0.5 * GetEasedInterval( 2000, ( index - 2 ) * 500 ), 0 )
		end

		local offset = GetLinearInterval( 60000, 0 )
		local x, y = ( self.TileX or 1 ) + offset, ( self.TileY or 1 ) + 2 * offset

		self.Particles[2]:SetTextureCoords( x, offset, 2 * offset, y )
		self.Particles[5]:SetTextureCoords( offset, x, 2 * offset, y )
		self.Particles[3]:SetTextureCoords( offset, x, y, 2 * offset )
		self.Particles[4]:SetTextureCoords( x, offset, y, 2 * offset )

	end,

	Reset = function( self )
		self:Update()
		self:TileRange(4096, 4096, 2, 5)
	end,

} ), nil, 1, 0.5, 1 )

AddWaterRipplesToEffect( EHT.EffectType:New( 463, "Water, Calm (Round)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.WATER_CIRCLE, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0, 0.3, 0.3, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 15 )

	end,

	Update = function( self )

		local waterInterval = GetEasedInterval( 10000, 0 )
		self.Particles[1]:SetColorOffsets( nil, nil, nil, 0.9 + 0.06 * waterInterval )
		self:Update()

	end,

	Reset = function( self )

		self:Update()

	end,

} ) )

EHT.EffectType:New( 464, "Water, Aquarium (Round)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.WATER_CIRCLE, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.5, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0, 0.3, 0.3, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 56 )

	end,

	Update = function( self )

		local waterInterval = GetEasedInterval( 10000, 0 )
		self.Particles[1]:SetColorOffsets( nil, nil, nil, 0.5 + 0.05 * waterInterval )
		self:Update()

	end,

	Reset = function( self )

		self:Update()

	end,

} )

AddWaterRipplesToEffect( EHT.EffectType:New( 465, "Water, Shallow (Round)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.WATER_CIRCLE, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 0.4, 1, 1, true, false )
		p:SetTextureWrapping( true )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0, 0.3, 0.3, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 60 )

	end,

	Update = function( self )

		local waterInterval = GetEasedInterval( 10000, 0 )
		self.Particles[1]:SetColorOffsets( nil, nil, nil, 0.4 + 0.1 * waterInterval )
		self:Update()

	end,

	Reset = function( self )

		self:Update()

	end,

} ) )

AddWaterRipplesToEffect( EHT.EffectType:New( 466, "Water, Gentle Current (Round)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local texWater, texWaves = TEXTURES.WATER_CIRCLE, TEXTURES.WATER_1
		local p

		p = self:AddParticle( texWater, 0, 0, 0, math.rad( 90 ), 0, 0, 0.8, 0.8, 0.8, 0.8, 1, 1, true, false )
		p:SetTextureWrapping( true )

		for index = 1, 2 do
			p = self:AddParticle( texWaves, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false, true )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.4, 0.6, 0.6, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 70 )

	end,

	Update = function( self )

		local colorInterval, sideInterval, waveInterval = 5000, 0.025 * GetEasedInterval( 18000, 0 ), GetLinearInterval( 28000, 0 )
		local p

		p = self.Particles[ 2 ]
		p:SetTextureCoords( sideInterval, 1 + sideInterval, 2 + waveInterval, waveInterval )
		p:SetIntervalVertexColors( 0.6, 0, 0.9, 0, 1, 0, 0.4, 0.2, colorInterval, 0.5 * colorInterval, 400, 200, 200 )

		p = self.Particles[ 3 ]
		p:SetTextureCoords( 0.5 + sideInterval, 2 + sideInterval, 2.5 + waveInterval, 0.5 + waveInterval )
		p:SetIntervalVertexColors( 0.5, 0, 1, 0, 1, 0, 0.4, 0.2, colorInterval, 0, 0, 200, 200 )

	end,

	Reset = function( self )

		self:Update()

	end,

} ) )

AddWaterRipplesToEffect( EHT.EffectType:New( 467, "Water, Mild Current (Round)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local texWater, texWaves = TEXTURES.WATER_CIRCLE, TEXTURES.WATER_1
		local p

		p = self:AddParticle( texWater, 0, 0, 0, math.rad( 90 ), 0, 0, 0.8, 0.8, 0.8, 0.9, 1, 1, true, false, false )

		for index = 1, 2 do
			p = self:AddParticle( texWaves, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false, true )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.4, 0.6, 0.6, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 70 )

	end,

	Update = function( self )

		local colorInterval, sideInterval, waveInterval = 4500, 0.05 * GetEasedInterval( 16000, 0 ), GetLinearInterval( 12000, 0 )
		local p

		p = self.Particles[ 2 ]
		p:SetTextureCoords( sideInterval, 1 + sideInterval, 2 + waveInterval, waveInterval )
		p:SetIntervalVertexColors( 0.6, 0, 0.9, 0, 1, 0, 0.4, 0.3, colorInterval, 0.5 * colorInterval, 400, 200, 200 )

		p = self.Particles[ 3 ]
		p:SetTextureCoords( 0.5 + sideInterval, 2 + sideInterval, 2.5 + waveInterval, 0.5 + waveInterval )
		p:SetIntervalVertexColors( 0.5, 0, 1, 0, 1, 0, 0.4, 0.3, colorInterval, 0, 0, 200, 200 )

	end,

	Reset = function( self )

		self:Update()

	end,

} ) )

AddWaterRipplesToEffect( EHT.EffectType:New( 468, "Water, Swift Current (Round)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local texWater, texWaves = TEXTURES.WATER_CIRCLE, TEXTURES.WATER_1
		local p

		p = self:AddParticle( texWater, 0, 0, 0, math.rad( 90 ), 0, 0, 0.8, 0.8, 0.8, 0.9, 1, 1, true, false )
		p:SetTextureWrapping( true )

		for index = 1, 2 do
			p = self:AddParticle( texWaves, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false, true )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.4, 0.6, 0.6, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 70 )

	end,

	Update = function( self )

		local colorInterval, sideInterval, waveInterval = 4000, 0.075 * GetEasedInterval( 14000, 0 ), GetLinearInterval( 6500, 0 )
		local p

		p = self.Particles[ 2 ]
		p:SetTextureCoords( sideInterval, 1 + sideInterval, 1.5 + waveInterval, waveInterval )
		p:SetIntervalVertexColors( 0.6, 0, 0.9, 0, 1, 0, 0.4, 0.3, colorInterval, 0.5 * colorInterval, 400, 200, 200 )

		p = self.Particles[ 3 ]
		p:SetTextureCoords( 0.5 + sideInterval, 2 + sideInterval, 2 + waveInterval, 0.5 + waveInterval )
		p:SetIntervalVertexColors( 0.5, 0, 1, 0, 1, 0, 0.4, 0.3, colorInterval, 0, 0, 200, 200 )

	end,

	Reset = function( self )

		self:Update()

	end,

} ) )

AddWaterRipplesToEffect( EHT.EffectType:New( 469, "Water, Rapids (Round)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local texWater, texWaves = TEXTURES.WATER_CIRCLE, TEXTURES.WATER_1
		local p

		p = self:AddParticle( texWater, 0, 0, 0, math.rad( 90 ), 0, 0, 0.8, 0.8, 0.8, 0.9, 1, 1, true, false )
		p:SetTextureWrapping( true )

		for index = 1, 2 do
			p = self:AddParticle( texWaves, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false, true )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.4, 0.6, 0.6, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 70 )

	end,

	Update = function( self )

		local colorInterval, sideInterval, waveInterval = 3000, 0.1 * GetEasedInterval( 13000, 0 ), GetLinearInterval( 3000, 0 )
		local p

		p = self.Particles[ 2 ]
		p:SetTextureCoords( sideInterval, 1 + sideInterval, 1 + waveInterval, waveInterval )
		p:SetIntervalVertexColors( 0.6, 0, 0.9, 0, 1, 0, 0.4, 0.3, colorInterval, 0.5 * colorInterval, 400, 200, 200 )

		p = self.Particles[ 3 ]
		p:SetTextureCoords( 0.5 + sideInterval, 2 + sideInterval, 1.5 + waveInterval, 0.5 + waveInterval )
		p:SetIntervalVertexColors( 0.5, 0, 1, 0, 1, 0, 0.4, 0.3, colorInterval, 0, 0, 200, 200 )

	end,

	Reset = function( self )

		self:Update()

	end,

} ) )

EHT.EffectType:New( 470, "Sigil, Sotha's Seal", {

	Category = CAT.SIGIL,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SIGIL_17, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p = self:AddParticle( TEXTURES.SIGIL_17, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetDodge( true )
		p:SetSampleProcessing( 6, 0 )

		self:SetSize( 200, 0, 200 )
		self:SetColor( 0.5, 0.25, 0.05, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Update = function( self )

		self.Particles[2]:SetIntervalVertexColors( 1, 0, 1, 0, 1, 0, 0, 1, 4000, 0, 1000, 2000, 3000 )

	end,

	Reset = function( self )

		local sx = self:GetSize()
		self:SetSize( sx, sx, sx )
		self:Update()

	end,

} )

EHT.EffectType:New( 471, "Rock, 2", {

	Category = CAT.LAND,

	Init = function( self )

		self:AddParticle( TEXTURES.ROCK_2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, true )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 10 )

	end,

	Reset = function( self )

		self:Tile( 1024, 1024 )
		self:Update()

	end,

} )

EHT.EffectType:New( 472, "Rock, Glowing", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		self:AddParticle( TEXTURES.ROCK_4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, true )

		local p = self:AddParticle( TEXTURES.ROCK_4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.5, 1, 1, true, false, true )
		p:SetDodge( true )
		p:SetSampleProcessing( 1.6, 0 )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 0.7, 0.5, 0.3, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 10 )

	end,

	Update = function( self )

		self.Particles[2]:SetIntervalVertexColors( 0, 0, 1, 0, 0, 0, 0, 1, 5000, 0, 250, 500, 750 )

	end,

	Reset = function( self )

		self:Tile( 1024, 1024 )
		self:Update()

	end,

} )

EHT.EffectType:New( 473, "Suit of Armor", {

	Category = CAT.DECO,

	CanPitch = true,

	Init = function( self )

		local p = self:AddParticle( TEXTURES.ARMOR_SUIT, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
		p:SetTextureCoords( 0.32, 0.68, 0, 1 )

		self:SetSize( 100, 234, 234 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 112 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 474, "Tree, Ethereal", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		self.GlowInterval = 5000
		self.GlowOffset = self.GlowInterval * math.random()

		local p

		for index = 0, 3 do
			p = self:AddParticle( TEXTURES.TREE_ETHEREAL, 0, 0, 0, 0, math.rad( 45 * index ), 0, 0.5 + 0.15 * ( index % 3 ), 0.5 + 0.15 * ( index % 3 ), 0.5 + 0.15 * ( index % 3 ), 0.35, 1, 1, true, false, false )
			if 0 == index % 2 then p:SetTextureCoords( -0.06 * ( index % 6 ), 1 + 0.06 * ( index % 6 ), -0.09 * ( index % 4 ), 1 ) end
		end

		self:SetColor( 0.2, 0.9, 0.95, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 768, 768, 768 )
		self:SpawnAtPlayer( 0.5 * 768, false )

	end,

	Update = function( self )

		for index = 1, #self.Particles do
			self.Particles[index]:SetIntervalVertexColors( 1, 0, 1, 0, 1, 0, 0.3, 0.1, self.GlowInterval, self.GlowOffset, self.GlowOffset + 250, self.GlowOffset + 500, self.GlowOffset + 750 )
		end

	end,

	Reset = function( self )

		self:Update()

		for index = 1, #self.Particles do
			self.Particles[index]:SetVertexColors( 4 + 8, 1, 1, 1, 1 )
		end

	end,

} )

AddWaterRipplesToEffect( EHT.EffectType:New( 475, "Oil, Clockwork City (Round)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		self:AddParticle( TEXTURES.WATER_CIRCLE, 0, 0, 0, math.rad( 90 ), 0, 0, 0.15, 0.15, 0.15, 1, 1, 1, true, false, true )

		local p
		for index = 1, 4 do
			p = self:AddParticle( TEXTURES.WATER_REFLECTION_1, 0, 0, 0, math.rad( 90 ), 0, 0, 0.65, 0.25, 0.15, 0.15, 1, 1, true, false, true )
			p:SetDesaturation( 0.75 )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 15 )

	end,

	Update = function( self )

		for index = 2, 5 do
			self.Particles[index]:SetSampleProcessing( 6 + 0.75 * GetEasedInterval( 2000, ( index - 2 ) * 500 ), 0 )
		end

		local x, y = self.TileX or 1, self.TileY or 1
		local offset = GetLinearInterval( 60000, 0 )
		x, y = x + offset, y + offset

		self.Particles[2]:SetTextureCoords( x, offset, offset, y )
		self.Particles[5]:SetTextureCoords( offset, x, offset, y )
		self.Particles[3]:SetTextureCoords( offset, x, y, offset )
		self.Particles[4]:SetTextureCoords( x, offset, y, offset )

	end,

	Reset = function( self )
		self:Update()
		self:TileRange(4096, 4096, 2, 5)
	end,

} ) )

AddShrubberyEffect( 476, "Bush, Petunia", TEXTURES.PETUNIA_1, 256, 256 )
AddShrubberyEffect( 477, "Flowers, Lavender", TEXTURES.LAVENDER_1 )
AddShrubberyEffect( 478, "Flowers, Lupin", TEXTURES.LUPIN_1 )
AddShrubberyEffect( 479, "Flowers, Salvia Divinorum", TEXTURES.SALVIA_1 )
AddShrubberyEffect( 480, "Flowers, Tulip", TEXTURES.TULIP_1 )
AddShrubberyEffect( 481, "Pumpkins, Cluster", TEXTURES.PUMPKINS_1, 200, 210, false )
AddCroppedEffect( 482, CAT.LAND, "Hist Bulb", TEXTURES.HIST_BULB_1, 118, 128, 0, 0.84, 0, 1 )

AddCroppedEffect( 483, CAT.BUILD, "Column, Marble", TEXTURES.COLUMN_1, 180, 1110, 0, 0.22, 0, 1 )
AddTiledScaledEffect( 484, CAT.BUILD, "Masonry, Framed", TEXTURES.WALL_1, 512, 512 )
AddTiledScaledEffect( 485, CAT.BUILD, "Stone Blocks, Sectional", TEXTURES.WALL_2, 366, 366 )
AddTiledScaledEffect( 486, CAT.BUILD, "Stone Blocks, Weathered", TEXTURES.WALL_3, 366, 366 )
AddCroppedEffect( 487, CAT.BUILD, "Gate, Ayleid", TEXTURES.GATE_1, 330, 500 )

AddCroppedEffect( 488, CAT.DECO, "Divider, Ornate", TEXTURES.DIVIDER_1, 158, 512, 0.352, 0.648, 0, 1 )
AddCroppedEffect( 489, CAT.DECO, "Instrument, Flute", TEXTURES.FLUTE, 6, 64, 0, 0.1, 0, 1 )
AddCroppedEffect( 490, CAT.DECO, "Instrument, Violin", TEXTURES.VIOLIN, 38, 116, 0, 0.34, 0, 1 )

AddCroppedEffect( 491, CAT.BUILD, "Door, Sliding", TEXTURES.DOOR_1, 112, 256, 0, 1, 0, 1 )
AddCroppedEffect( 492, CAT.BUILD, "Door, Weathered", TEXTURES.DOOR_2, 112, 256, 0, 1, 0, 1 )
AddCroppedEffect( 493, CAT.BUILD, "Door, Vertical Slat", TEXTURES.DOOR_3, 112, 256, 0, 1, 0, 1 )
AddCroppedEffect( 494, CAT.BUILD, "Arch, Khajiit", TEXTURES.ARCH_1, 870, 1110, 0, 0.67, 0, 1 )
AddCroppedEffect( 495, CAT.BUILD, "Ceiling, Vaulted", TEXTURES.CEILING_1, 512, 1024, 0, 1, 0, 1, nil, nil, nil, 0.5 * math.pi, nil, nil )
AddCroppedEffect( 496, CAT.BUILD, "Ceiling, Barrel Vaulted", TEXTURES.CEILING_2, 1024, 1024, 0, 1, 0, 1, nil, nil, nil, 0.5 * math.pi, nil, nil )

AddCroppedEffect( 497, CAT.DECO, "Chest, Reinforced", TEXTURES.CHEST_1, 176, 112, 0, 1, 0.38, 1 )
AddTiledScaledEffect( 498, CAT.DECO, "Rope, Braided", TEXTURES.ROPE_1, 28, 92 )

EHT.EffectType:New( 499, "Dust", {
	Category = CAT.ANIM,
	Init = function( self )
		self:SetCameraFacing( true )
		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 1, 1, 1 )
		self:SpawnAtPlayer( 500 )
	end,
	Update = function( self )
		if self.Emitter then self.Emitter:Update() end
	end,
	Reset = function( self )
		self:Update()

		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()
		local maxDim = math.max( sx, sy, sz )
		local ttl = 3000
		r, g, b = 0.9 * r, 0.9 * g, 0.9 * b

		local o = { }
		o.Texture = TEXTURES.CIRCLE_SOFT
		o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.CAMERA, yaw
		o.EmissionX, o.EmissionY, o.EmissionZ = x, y, z
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = -50 + 0.5 * sx, 500, -50 + 0.5 * sz
		o.MaxActiveEmissions, o.ReuseActiveEmissions = 40, false
		o.MinActiveEmissions = 0.5 * o.MaxActiveEmissions
		o.EmissionFrequency = ttl / o.MaxActiveEmissions
		o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.RANDOM, 2000, 0
		o.MaxOffset = 0.5 * math.max( sx, sy, sz )
		o.WindFactor = 0
		o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 4, 4, 0, 0
		o.MinTTL, o.MaxTTL = 0.8 * ttl, 1.2 * ttl
		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r - 0.04, g - 0.04, b - 0.04, 0
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r + 0.04, g + 0.04, b + 0.04, 0
		o.ColorShift, o.AlphaShift = 0, 0.5
		o.MinRotation, o.MaxRotation = 0, 0
		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RADIAL
		o.MinVectorX, o.MinVectorY, o.MinVectorZ = -8, -10, -8
		o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 8, 4, 8

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end
	end,
} )

local function AddWaterSpoutEffect( id, name, intermittent )

	local updateFunc

	if not intermittent then
		updateFunc = function( self )
			local em = self.Emitters

			if em then
				for index = 1, #em do
					em[index]:Update()
				end
			end
		end
	else
		updateFunc = function( self )

			local ft = FrameTime
			local em = self.Emitters

			if em then
				if ft >= self.NextStateChange then
					if 1 == self.State then
						self.State = 2 -- Erupting
						self.NextStateChange = ft + 5000 + 5000 * math.random()
						self.LastStateChange = ft

						for index = 1, #em do
							em[index]:Resume()
						end
					else
						self.State = 1 -- Dormant
						self.NextStateChange = ft + 6000 + 3000 * math.random()
						self.LastStateChange = ft

						for index = 1, #em do
							em[index]:Suspend()
						end
					end
				end

				for index = 1, #em do
					em[index]:Update()
				end

				if 2 == self.State and self.NextSound <= ft and self:IsNearPlayer( 2000 ) then
					self.NextSound = ft + 100

					if 100 > ( self.NextSound % 200 ) then
						PlaySound( "Console_Menu_Jump_Up" )
					else
						PlaySound( "Console_Menu_Jump_Down" )
					end
				end
			end

		end
	end

	return EHT.EffectType:New( id, name, {

		Category = CAT.ANIM,

		Init = function( self )

			self.State, self.NextStateChange, self.LastStateChange, self.NextSound = 1, 0, 0, 0
			self:SetSize( 400, 1000, 400 )
			self:SetColor( 0.2, 1, 1 )
			self:SpawnAtPlayer( 515 )

		end,

		Update = updateFunc,

		Reset = function( self )

			self.State, self.NextStateChange, self.LastStateChange, self.NextSound = 1, 0, 0, 0

			local x, y, z = self:GetPosition()
			local pitch, yaw, roll = self:GetOrientation()
			local r, g, b, a = self:GetColor()
			local sx, sy, sz = self:GetSize()
			local ttl = 1400
			local ttlYRatio = sy / ( ttl / 1000 )

			sy = math.max( sy, sz )
			r, g, b = 1 * r, 1 * g, 1 * b

			self.Emitters = { }

			local o = { }
			o.Texture = TEXTURES.SPLASH_3
			o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.NONE, yaw
			o.EmissionX, o.EmissionY, o.EmissionZ = x, y - 0.4 * sy, z
			o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = -20, 0, -20
			o.EmissionFrequency = 50
			o.MaxActiveEmissions, o.ReuseActiveEmissions = 1, false
			-- o.EmissionsPerMinute, o.MaxActiveEmissions, o.ReuseActiveEmissions = 200, 1, false
			o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.CYCLICAL, 0, 0
			o.MaxOffset = 2 * sy
			o.WindFactor = 0.1
			o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 0.5 * sx, sx, 0.5 * sx, sx
			o.MinSizeY, o.MaxSizeY = 0.33 * sy, 0.38 * sy
			o.MinTTL, o.MaxTTL = ttl, ttl
			o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r, g, b, 0
			o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r, g, b, 0
			o.Desaturation = 0.8
			o.ColorShift, o.AlphaShift = 0, 0.7
			o.MinRotation, o.MaxRotation = 0, 0
			o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
			o.MinVectorX, o.MinVectorY, o.MinVectorZ = -15, ttlYRatio, 0
			o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 15, ttlYRatio, 0
			table.insert( self.Emitters, EHT.ParticleEmitter:New( self, o ) )

			o = { }
			o.Texture = TEXTURES.SPLASH_2
			o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.NONE, yaw
			o.EmissionX, o.EmissionY, o.EmissionZ = x, y - 0.4 * sy, z
			o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = -10, 0, -10
			o.EmissionFrequency = 50
			o.MaxActiveEmissions, o.ReuseActiveEmissions = 1, false
			-- o.EmissionsPerMinute, o.MaxActiveEmissions, o.ReuseActiveEmissions = 200, 1, false
			o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.CYCLICAL, 0, 0
			o.MaxOffset = 2 * sy
			o.WindFactor = 0.1
			o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 0.5 * sx, sx, 0.5 * sx, sx
			o.MinSizeY, o.MaxSizeY = 0.33 * sy, 0.38 * sy
			o.MinTTL, o.MaxTTL = 0.5 * ttl, ttl
			o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r, g, b, 0
			o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r, g, b, 0
			o.Desaturation = 0.7
			o.ColorShift, o.AlphaShift = 0, 0.7
			o.MinRotation, o.MaxRotation = 0, 0
			o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
			o.MinVectorX, o.MinVectorY, o.MinVectorZ = -15, ttlYRatio, 0
			o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 15, ttlYRatio, 0
			table.insert( self.Emitters, EHT.ParticleEmitter:New( self, o ) )

			o = { }
			o.Texture = TEXTURES.SPLASH_1
			o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.NONE, yaw
			o.EmissionX, o.EmissionY, o.EmissionZ = x, y - 0.4 * sy, z
			o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0, 0, 0
			o.EmissionFrequency = 50
			o.MaxActiveEmissions, o.ReuseActiveEmissions = 1, false
			-- o.EmissionsPerMinute, o.MaxActiveEmissions, o.ReuseActiveEmissions = 200, 1, false
			o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.CYCLICAL, 0, 0
			o.MaxOffset = 2 * sy
			o.WindFactor = 0.1
			o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 0.2 * sx, 0.3 * sx, 0, 0.2 * sx
			o.MinSizeY, o.MaxSizeY = 0.33 * sy, 0.38 * sy
			o.MinTTL, o.MaxTTL = 0.5 * ttl, ttl
			o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r, g, b, 0
			o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r, g, b, 0
			o.Desaturation = 0.7
			o.ColorShift, o.AlphaShift = 0, 0.7
			o.MinRotation, o.MaxRotation = 0, 0
			o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
			o.MinVectorX, o.MinVectorY, o.MinVectorZ = -15, ttlYRatio, 0
			o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 15, ttlYRatio, 0
			table.insert( self.Emitters, EHT.ParticleEmitter:New( self, o ) )

			o = { }
			o.Texture = TEXTURES.STEAM_1
			o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.NONE, yaw
			o.EmissionX, o.EmissionY, o.EmissionZ = x, y + 0.5 * sy, z
			o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 10, 0, 10
			o.EmissionFrequency = 1000
			o.MaxActiveEmissions, o.ReuseActiveEmissions = 1, false
			-- o.EmissionsPerMinute, o.MaxActiveEmissions, o.ReuseActiveEmissions = 60, 1, false
			o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.CYCLICAL, 0, 0
			o.MaxOffset = 2 * sy
			o.WindFactor = 0.1
			o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 0.5 * sx, 0.5 * sx, 0.75 * sx, 0.85 * sx
			o.MinSizeY, o.MaxSizeY, o.MinGrowthY, o.MaxGrowthY = 0.7 * sy, 0.8 * sy, 0.1 * sy, 0.15 * sy
			o.MinTTL, o.MaxTTL = 1.5 * ttl, 2 * ttl
			o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r, g, b, 0
			o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r, g, b, 0
			o.Desaturation = 0.8
			o.ColorShift, o.AlphaShift = 0, 0.6
			o.MinRotation, o.MaxRotation = 0, 0
			o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
			o.MinVectorX, o.MinVectorY, o.MinVectorZ = 0, 4, 0
			o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 0, 6, 0
			table.insert( self.Emitters, EHT.ParticleEmitter:New( self, o ) )

			o = { }
			o.Texture = TEXTURES.STEAM_1
			o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.NONE, yaw
			o.EmissionX, o.EmissionY, o.EmissionZ = x, y - 0.4 * sy, z
			o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 20, 0, 20
			o.EmissionFrequency = 1000
			o.MaxActiveEmissions, o.ReuseActiveEmissions = 1, false
			-- o.EmissionsPerMinute, o.MaxActiveEmissions, o.ReuseActiveEmissions = 60, 3, false
			o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.CYCLICAL, 0, 0
			o.MaxOffset = 2 * sy
			o.WindFactor = 0.1
			o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 0.5 * sx, 0.5 * sx, 0.05 * sx, 0.1 * sx
			o.MinSizeY, o.MaxSizeY, o.MinGrowthY, o.MaxGrowthY = 0.3 * sy, 0.4 * sy, 0.1 * sy, 0.2 * sy
			o.MinTTL, o.MaxTTL = 0.5 * ttl, 1 * ttl
			o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r, g, b, 0
			o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r, g, b, 0
			o.Desaturation = 0.8
			o.ColorShift, o.AlphaShift = 0, 0.6
			o.MinRotation, o.MaxRotation = 0, 0
			o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
			o.MinVectorX, o.MinVectorY, o.MinVectorZ = 0, ttlYRatio * 0.5, 0
			o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 0, ttlYRatio * 0.5, 0
			table.insert( self.Emitters, EHT.ParticleEmitter:New( self, o ) )

			self:Update()

		end,

	} )

end

AddWaterSpoutEffect( 500, "Geyser", true )

AddCroppedEffect( 501, CAT.LAND, "Water Lilies and Pads", TEXTURES.LILY_PADS_2, 512, 512, 0, 1, 0, 0.723, nil, nil, nil, 0.5 * math.pi )
AddCroppedEffect( 502, CAT.DECO, "Instrument, Harp", TEXTURES.HARP, 60, 112, 0, 0.58, 0, 1 )
AddCroppedEffect( 503, CAT.DECO, "Instrument, Mandolin", TEXTURES.MANDOLIN, 49, 112, 0, 0.41, 0, 1 )
AddCroppedEffect( 504, CAT.BUILD, "Door, Ayleid", TEXTURES.DOOR_4, 400, 512, 0, 1, 0, 1 )
AddCroppedEffect( 505, CAT.BUILD, "Arch, Ayleid", TEXTURES.ARCH_2, 706, 1024, 0, 0.69, 0, 1 )
AddCroppedEffect( 506, CAT.DECO, "Geode, Amethyst", TEXTURES.GEODE_1, 128, 256, 0, 0.45, 0, 1 )
AddCroppedEffect( 507, CAT.DECO, "Geode, Emerald", TEXTURES.GEODE_2, 128, 256, 0, 0.45, 0, 1 )
AddCroppedEffect( 508, CAT.DECO, "Geode, Sapphire", TEXTURES.GEODE_3, 128, 256, 0, 0.45, 0, 1 )
AddCroppedEffect( 509, CAT.DECO, "Geode, Ruby", TEXTURES.GEODE_4, 128, 256, 0, 0.45, 0, 1 )

AddTiledScaledEffect( 510, CAT.DECO, "Books, Horizontal Stack", TEXTURES.BOOKS_1, 256, 155 )
AddCroppedEffect( 511, CAT.LAND, "Hedge, Single", TEXTURES.HEDGE_1, 1024, 512, 0, 1, 0, 0.53, nil, nil, nil, nil, nil, nil, nil, 0.917, 1, 0.651 )
AddTiledScaledEffect( 512, CAT.LAND, "Hedge, Wall", TEXTURES.HEDGE_2, 1024, 512, nil, nil, 0.53, 0.53, nil, true, 0.917, 1, 0.651 )

AddCroppedEffect( 513, CAT.DECO, "The Hand", TEXTURES.HAND_1, 128, 128, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 0, 0, 0, 0.6 )
AddCroppedEffect( 514, CAT.BUILD, "Door, Imperial", TEXTURES.DOOR_5, 512, 512 )
AddCroppedEffect( 515, CAT.LAND, "Tree, Withered", TEXTURES.TREE_WITHERED, 512, 512 )
AddCroppedEffect( 516, CAT.DECO, "Target", TEXTURES.TARGET, 128, 128 )

AddBubbleEffect( 517, "Bubbles, Falling", 60, 5, 10, -1 )
--[[
EHT.EffectType:New( 517, "Bubbles, Falling", {

	Category = CAT.ANIM,

	Init = function( self )

		self.MaxBubbles, self.MinSize, self.MaxSizeOffset, self.MinTravelTime, self.MaxTravelTime = 40, 0.04, 0.1, 1000, 7000
		self.MaxTravelTimeOffset = self.MaxTravelTime - self.MinTravelTime
		self:SetSize( 250, 250, 250 )
		self:SetColor( 0, 0.6, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetAutoSizeEnabled( false )
		self:SetAutoOrientationEnabled( false )

		local p
		for index = 1, self.MaxBubbles do
			p = self:AddParticle( "esoui/art/dye/gamepad/dye_circle.dds", 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.8, 0.1, 0.1, true, false )
			p:SetTextureWrapping( false )
			p:SetSampleProcessing( 1, 1 )
			p:SetAdditive( true )
		end

		self:SpawnAtPlayer( 200 )

	end,

	Update = function( self )

		local sizeX, sizeY = self:GetSize()
		local minX, maxY = -0.5 * sizeX, 0.5 * sizeY
		local ft = FrameTime
		local maxP = #self.Particles
		local color, p, interval, texSize

		for index = 1, maxP do
			p = self.Particles[index]
			p:SetOrientation( 0, CameraHeading, 0 )
			interval = GetLinearInterval( p.TravelTime, p.StartTime )

			if 1 > interval and 0 ~= interval then
				p:SetPositionOffsets( p.BaseX + p.WaveMagnitude * math.sin( interval * p.WaveFreq * math.pi ), maxY - ( interval * sizeY ) )
				p:SetColorOffsets( nil, nil, nil, p.BaseAlpha * math.min( 1, ( 1.2 - interval ) / 1 ) )
			else
				p.BaseX = minX + sizeX * math.random()
				p:SetPositionOffsets( p.BaseX, 0, minX + ( sizeX * ( index / maxP ) ) )

				texSize = sizeX * ( self.MinSize + self.MaxSizeOffset * math.random() )
				p:SetSize( texSize, texSize )

				color = 0.8 + 0.2 * math.random()
				p.BaseAlpha = 0.2 + 0.5 * math.random()
				p:SetColorOffsets( color, color, color, p.BaseAlpha )

				p.StartTime, p.TravelTime = ft, self.MinTravelTime + self.MaxTravelTimeOffset * math.random()
				p.WaveFreq = 4 * ( ( self.MaxTravelTime - p.TravelTime ) / self.MaxTravelTime )
				p.WaveMagnitude = 2 * p.WaveFreq * math.random()
			end
		end

		self:Update()

	end,

	Reset = function( self )

		local _, yaw = self:GetOrientation()
		local p

		for index = 1, #self.Particles do
			p = self.Particles[index]
			p.StartTime, p.TravelTime = 1, 1
		end

		self:SetOrientation( 0, yaw, 0 )
		self:Update()

	end,

} )
]]
AddCroppedEffect( 518, CAT.BUILD, "Door, Nedic", TEXTURES.DOOR_6, 1024, 910, nil, nil, 0, 0.887 )
AddCroppedEffect( 519, CAT.LAND, "Boulder, Cliff Face", TEXTURES.ROCK_3, 1024, 590, nil, nil, 0, 0.577 )

AddCroppedEffect( 520, CAT.BUILD, "Stone Pillar, Spiked", TEXTURES.PILLAR_1, 149, 512, 0, 0.291 )

EHT.EffectType:New( 521, "Fireflies, Sporadic", {

	Category = CAT.PET,

	Init = function( self )

		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 1, 1, 0, 1 )
		self:SpawnAtPlayer( 300 )

	end,

	Update = function( self )

		if self.Emitter then self.Emitter:Update() end

	end,

	Reset = function( self )

		self:Update()

		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()
		local maxDim, minDim = math.max( sx, sy, sz ), math.min( sx, sy, sz )
		local ttl = 2200
		r, g, b = 0.9 * r, 0.9 * g, 0.9 * b

		local o = { }
		o.Texture = TEXTURES.CIRCLE_SOFT
		o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.CAMERA, yaw
		o.EmissionX, o.EmissionY, o.EmissionZ = x, y, z
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0.5 * sx, 300, 0.5 * sz
		o.MaxActiveEmissions, o.ReuseActiveEmissions = zo_clamp( 0.04 * math.sqrt( sx * sz ), 12, 200 ), false
		o.MinActiveEmissions = 0.5 * o.MaxActiveEmissions
		o.EmissionFrequency = ttl / o.MaxActiveEmissions
		-- o.EmissionsPerMinute, o.MaxActiveEmissions, o.ReuseActiveEmissions = zo_clamp( maxDim, 300, 2000 ), zo_clamp( ( minDim / 70 ) * ( maxDim / 70 ), 12, 200 ), false
		o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.RANDOM, 2000, 0
		o.MaxOffset = 0.5 * math.max( sx, sy, sz )
		o.WindFactor = 0
		o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 7, 8, 0, 0
		o.MinTTL, o.MaxTTL = 0.5 * ttl, ttl
		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r - 0.04, g - 0.04, b - 0.04, 0
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r + 0.04, g + 0.04, b + 0.04, 0
		o.ColorShift, o.AlphaShift = 0.4, 2
		o.MinRotation, o.MaxRotation = 0, 0
		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
		o.MinVectorX, o.MinVectorY, o.MinVectorZ = 4, 5, 0
		o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 4, 5, 0
		o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = true, true, false, false
		o.UseTextureUVAnimation = true

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end
	end,

} )

AddShrubberyEffect( 522, "Ivy, Dense", TEXTURES.IVY_1, 512, 512 )
AddTiledScaledEffect( 523, CAT.BUILD, "Windows, Imperial", TEXTURES.WINDOW_1, 256, 256 )

EHT.EffectType:New( 524, "Gate, Ayleid (Inactive)", {
	Category = CAT.BUILD,
	CanPitch = true,
	OrderDrawLevelByIndex = true,

	Init = function( self )
		self.Interval, self.IntervalUnit = 4000, 400

		for index = 1, 5 do
			p = self:AddParticle( TEXTURES.WHIRLPOOL_1,		11, -115, 0,		0, 0, 0,	1, 1, 1, 1,		0.41, 0.77,		true, true, false )
			p:SetSampleProcessing( 1, 0 )
		end

		local p = self:AddParticle( TEXTURES.ARCH_3,	0, 0, 2,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
		p:SetTextureCoords( 0, 0.645, 0, 1 )

		local p = self:AddParticle( TEXTURES.ARCH_3,	0, 0, -2,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
		p:SetTextureCoords( 0, 0.645, 0, 1 )

		self:SetSize( 980, 1500, 1500 )
		self:SetColor( 0.035, 0.4, 0.4, 1 )
		self:SpawnAtPlayer( 512 )
	end,

	Update = function( self )
		local r, g, b = self:GetColor()
		local ps = self.Particles
		local p, i

		for index = 1, 5 do
			p = ps[index]
			i = GetLinearInterval( self.Interval, ( index - 1 ) * 2 * self.IntervalUnit )
			p:SetTextureCoords( 0.5 - i, 0.5 + i, 0.5 - i, 0.5 + i )
			i = GetEasedInterval( self.Interval, ( 1 + ( index - 1 ) * 2 ) * self.IntervalUnit )
			p:SetColor( r, g, b, i )
			p:SetSampleProcessing( 0.5, 0.2 * i )
		end
	end,

	Reset = function( self )
		local sizeX, sizeY = self:GetSize()
		local offsetX, offsetY = 0.01 * sizeX, -0.1045 * sizeY

		for index = 1, 5 do
			self.Particles[index]:SetPositionOffsets( offsetX, offsetY, 0 )
		end

		self:Update()

		for index = 6, 7 do
			self.Particles[index]:SetColor( 1, 1, 1, 1 )
		end
	end,
} )

EHT.EffectType:New( 525, "Faerie Dust", {

	Category = CAT.ANIM,

	Init = function( self )

		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0, 0.8, 1, 1 )
		self:SpawnAtPlayer( 300 )

	end,

	Update = function( self )

		if self.Emitter then self.Emitter:Update() end

	end,

	Reset = function( self )

		self:Update()

		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()
		local maxDim = math.max( sx, sy, sz )
		local ttl = 2600
		r, g, b = 0.9 * r, 0.9 * g, 0.9 * b

		local o = { }
		o.Texture = TEXTURES.CIRCLE_SOFT_4
		o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.CAMERA, yaw
		o.EmissionX, o.EmissionY, o.EmissionZ = x, y, z
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0.5 * sx, 300, 0.5 * sz
		o.ReuseActiveEmissions, o.MaxActiveEmissions = false, zo_clamp( 0.05 * math.sqrt( sx * sz ), 1, 500 )
		o.MinActiveEmissions = 0.8 * o.MaxActiveEmissions
		o.EmissionFrequency = ttl / o.MaxActiveEmissions
		o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.RANDOM, 2000, 0
		o.MaxOffset = 0.6 * math.max( sx, sy, sz )
		o.WindFactor = 0
		o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 30, 34, 0, 0
		o.MinTTL, o.MaxTTL = 0.6 * ttl, ttl
		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r - 0.01, g - 0.01, b - 0.01, 0
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r + 0.01, g + 0.01, b + 0.01, 0
		o.ColorShift, o.AlphaShift = 0, 2
		o.MinRotation, o.MaxRotation = 0, 0
		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
		o.MinVectorX, o.MinVectorY, o.MinVectorZ = 4, 5, 0
		o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 4, 5, 0
		o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = true, true, false, false
		o.UseTextureUVAnimation = true
		o.MinSampleRGB, o.MaxSampleRGB, o.MinSampleAlpha, o.MaxSampleAlpha = 1, 10, 0, 0

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end

	end,

} )

EHT.EffectType:New( 526, "Brightness, Global", {
	Category = CAT.LIGHT,
	Global = true,
	Overlay = true,
	ResetOnColor = true,
	UniqueClass = "Global Brightness",
	Init = function( self )
		self:SetAutoDrawLevelEnabled( false )
		self:SetColor( 0.5, 0.5, 0.5, 1 )
	end,
	Reset = function( self )
		if self:IsHidden() then
			return
		end

		local r, g, b = self:GetColor()
		local brightness = ( r + g + b ) / 3

		self.Brightness = brightness
		self:SetColor( brightness, brightness, brightness, 1 )
		self:Update()

		RequestBrightness( self, "Global", self.Brightness )
	end,
	Destroy = function( self )
		RequestBrightness( self, "Global", nil )
	end,
	OnVisibilityChanged = function( self, hidden )
		if hidden then
			RequestBrightness( self, "Global", nil )
		else
			RequestBrightness( self, "Global", self.Brightness )
		end
	end,
} )

AddTimeRiftEffect( 527, "Time Rift, Neutralized", false )
AddCroppedEffect( 528, CAT.PET, "Glow Worms", TEXTURES.GLOW_WORMS_1, 325, 512, 0, 325 / 512, nil, nil,  nil, nil, nil,  nil, nil, nil,  nil,  0.35, 0.75, 1, 1,  4, 0 )

AddCroppedEffect( 529, CAT.BUILD, "Door, Carved Ayleid", TEXTURES.DOOR_7, 365, 512, 0, 367 / 512, 0, 1, nil, nil, nil, nil, nil, nil, nil, 0.313, 0.745, 0.8 )
AddCroppedEffect( 530, CAT.BUILD, "Column, Ayleid", TEXTURES.COLUMN_2, 700, 2000, 0, 198 / 512, 0, 1 )

EHT.EffectType:New( 531, "Water, Reflection (Round)", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		self:AddParticle( TEXTURES.CIRCLE, 0, 0, 0, math.rad( 90 ), 0, 0, 1, 1, 1, 0.1, 1, 1, true, false, true )

		local p
		for index = 1, 4 do
			p = self:AddParticle( TEXTURES.WATER_REFLECTION_1, 0, 0, 0, math.rad( 90 ), 0, 0, 0.6 + 0.1 * index, 0.6 + 0.1 * index, 0.6 + 0.1 * index, 0.3, 1, 1, true, false, true )
			p:SetDesaturation( 1 )
			p:SetDodge( true )
		end

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 15 )

	end,

	Update = function( self )

		for index = 2, 5 do
			self.Particles[index]:SetSampleProcessing( 2 + 0.5 * GetEasedInterval( 2000, ( index - 2 ) * 500 ), 0 )
		end

		local offset = GetLinearInterval( 60000, 0 )
		local x, y = ( self.TileX or 1 ) + offset, ( self.TileY or 1 ) + 2 * offset

		self.Particles[2]:SetTextureCoords( x, offset, 2 * offset, y )
		self.Particles[5]:SetTextureCoords( offset, x, 2 * offset, y )
		self.Particles[3]:SetTextureCoords( offset, x, y, 2 * offset )
		self.Particles[4]:SetTextureCoords( x, offset, y, 2 * offset )

	end,

	Reset = function( self )

		self:Update()
		self:Tile( 4096, 4096, 1 )

		for index = 1, 4 do
			self.Particles[index + 1]:SetColor( 0.6 + 0.1 * index, 0.6 + 0.1 * index, 0.6 + 0.1 * index, 0.3 )
		end

	end,

} )

AddCroppedEffect( 532, CAT.BUILD, "Window, Redguard", TEXTURES.WINDOW_2, 488, 512, 0, 975 / 1024, 0, 1 )
AddSceneryEffect( 533, "Craglorn Cliffs", 0.5, 24, TEXTURES.ROCK_3, 0, 502/1024, TEXTURES.ROCK_6, 0, 502/1024 )

AddCroppedEffect( 534, CAT.BUILD, "Door, Orcish", TEXTURES.DOOR_8, 380, 512, 0, 760 / 1024, 0, 1 )
AddCroppedEffect( 535, CAT.LAND, "Tree Pair, Snowy", TEXTURES.TREE_1, 1288, 2048, 0, 645 / 1024, 0, 1 )
AddCroppedEffect( 536, CAT.LAND, "Tree, Snowy", TEXTURES.TREE_1, 888, 2700, 728 / 1024, 1, 0, 1 )
AddSceneryEffect( 537, "Wrothgar Mountains", 0.5, 24, TEXTURES.ROCK_7, 0, 845/1024, TEXTURES.ROCK_8, 0, 1 )
AddSceneryEffect( 538, "Wrothgar Forest, Dense", 0.5, 24, TEXTURES.TREE_CLUSTER_1, 0, 1, TEXTURES.TREE_CLUSTER_1, 0, 1 )
AddSceneryEffect( 539, "Wrothgar Forest, Sparse", 0.5, 16, TEXTURES.TREE_CLUSTER_1, 0, 1, TEXTURES.TREE_CLUSTER_1, 0, 1 )

AddEnergyBeamEffect( 540, "Energy Beam, Dissipating", CAT.ANIM, 0.45, 0.55, 1, nil, 4 + 8 )
AddEnergyBeamEffect( 541, "Energy Beam, Converging", CAT.ANIM, 0.45, 0.55, 1, nil, 1 + 2 + 4 + 8 )

EHT.EffectType:New( 542, "Leaves, Drifting", {

	Category = CAT.ANIM,

	MinSize = { 20, 20, 20 },

	Init = function( self )

		self:SetSize( 500, 1000, 500 )
		self:SetColor( 0.05, 0.6, 0.05, 1 )
		self:SpawnAtPlayer( 500 )

	end,

	Update = function( self )

		if self.Emitter then self.Emitter:Update() end

	end,

	Reset = function( self )

		self:Update()

		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()

		if sx < 50 or sy < 50 then
			self:SetSize( math.max( 50, sx ), math.max( 50, sy ) )
			sx, sy, sz = self:GetSize()
		end

		local maxDim = math.max( sx, sy, sz )
		local ttl = 15000
		r, g, b = 0.9 * r, 0.9 * g, 0.9 * b

		local o = { }
		o.Texture = TEXTURES.LEAVES
		o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.CAMERA, yaw
		o.EmissionX, o.EmissionY, o.EmissionZ = x, y + 0.5 * sy, z
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0.25 * sx, 0, 0.25 * sx
		o.ReuseActiveEmissions, o.MaxActiveEmissions = false, zo_clamp( 0.025 * math.sqrt( sx * sy ), 1, 200 )
		o.MinActiveEmissions = 1
		o.EmissionFrequency = ttl / o.MaxActiveEmissions
		-- o.MinActiveEmissions, o.EmissionsPerMinute = 0.5 * o.MaxActiveEmissions, ( 60000 / ttl ) * o.MaxActiveEmissions
		o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.RANDOM, 2000, 0
		o.MaxOffsetY, o.WindFactor = 0.51 * sy, zo_clamp( 0.1 * math.min( sx, sy ), 5, 20 )
		o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 8, 11, 0, 0
		o.MinTTL, o.MaxTTL = ttl, ttl
		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r - 0.15, g - 0.15, b - 0.15, 0
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r + 0.15, g + 0.15, b + 0.15, 0
		o.ColorShift, o.AlphaShift = 0.4, 2
		o.MinRotation, o.MaxRotation, o.MinAngularVelocity, o.MaxAngularVelocity = -math.pi, math.pi, -2 * math.pi, 2 * math.pi
		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
		o.MinVectorX, o.MinVectorY, o.MinVectorZ = -0.05 * sx, zo_clamp( -0.2 * sy, -120, -20 ), -0.05 * sx
		o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 0.05 * sx, zo_clamp( -0.1 * sy, -120, -20 ), 0.05 * sx
		o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = false, false, false, false
		o.UseCellAnimation, o.CellsStatic, o.CellsFPS, o.CellsX, o.CellsY = true, true, 4, 8, 2
		o.LockAtRange, o.RecycleAtRange = false, true

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end

	end,

} )

AddCroppedShadowedEffect( 543, CAT.DECO, "Weapon Rack, Swords", TEXTURES.WEAPON_RACK_1, 126, 264, 0, 466 / 1024, 0, 1 )

EHT.EffectType:New( 544, "Cinder Storm", {

	Category = CAT.WEATHER,
	MinSize = { 20, 20, 20 },

	Init = function( self )
		self:SetSize( 1200, 1200, 1200 )
		self:SetColor( 1, 0.5, 0.15, 1 )
		self:SpawnAtPlayer( 400 )
		self:SetCameraFacing( true )
	end,

	Update = function( self )
		if self.Emitter then self.Emitter:Update() end
	end,

	Reset = function( self )
		self:Update()

		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()
		local maxDim = math.max( sx, sy, sz )
		local ttl = 3000

		local o = { }
		o.Texture = TEXTURES.ASH_SEQ_1
		o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.CAMERA, yaw
		o.EmissionX, o.EmissionY, o.EmissionZ = x, y - 0.2 * sy, z
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0.5 * sx, 0.2 * sy, 0.5 * sx
		o.ReuseActiveEmissions, o.MaxActiveEmissions = false, 20
		o.MinActiveEmissions = 1
		o.EmissionFrequency = 250
		o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.RADIAL, 1500, 0
		o.MaxOffset, o.WindFactor = 2.5 * maxDim, 0
		o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = zo_clamp( 0.1 * sx, 4, 20 ), zo_clamp( 0.1 * sx, 10, 60 ), 0, -5
		o.MinTTL, o.MaxTTL = 0.33 * ttl, ttl
		o.MinSampleRGB, o.MaxSampleRGB = 2, 8
		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r, g, b, 0
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = 0.98 * r, 0.98 * g, 0.98 * b, 0
		o.ColorShift, o.AlphaShift = -1.2, 2
		o.MinRotation, o.MaxRotation, o.MinAngularVelocity, o.MaxAngularVelocity = -math.pi, math.pi, -1.5 * math.pi, 1.5 * math.pi
		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RADIAL
		o.MinVectorX, o.MinVectorY, o.MinVectorZ = 0.08 * sx, 0.1 * sy, 0.08 * sx
		o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 0.12 * sx, 0.6 * sy, 0.12 * sx
		o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = false, false, false, false
		o.UseCellAnimation, o.CellsStatic, o.CellsFPS, o.CellsX, o.CellsY = true, false, nil, 8, 8
		o.LockAtRange, o.RecycleAtRange = false, true

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end
	end,

} )

AddCroppedEffect( 545, CAT.DECO, "Wine Rack", TEXTURES.WINE_RACK_1, 122, 157, 0, 462 / 512, 0, 1 )

EHT.EffectType:New( 546, "Arrow, Directional", {

	Category = CAT.DECO,

	CanPitch = true,

	OrderDrawLevelByIndex = true,

	Init = function( self )

		p = self:AddParticle( TEXTURES.ARROW_2, 		0, 0, 0,		0, 0, 0,	0.25, 0.25, 0.25, 0.6,	1, 1,		true, false, false )

		local p = self:AddParticle( TEXTURES.ARROW_2, 	0, 0, 0,		0, 0, 0,	1, 1, 1, 1,				1, 1,		true, false, false )
		p:SetTextureCoords( -0.025, 1.025, -0.025, 1.025 )
		p:SetDodge( true )

		self:SetColor( 0, 1, 1, 1 )
		self:SetSize( 128, 128, 128 )
		self:SetOrientation( math.rad( 269.5 ), 0, 0 )
		self:SpawnAtPlayer( 10, true )

	end,

	Update = function( self )

		local r, g, b, a = self:GetColor()
		self.Particles[2]:SetIntervalVertexColors( r, 0, g, 0, b, 0, 1.2, 1, 1500, 0, 0, 250, 250 )

	end,

	Reset = function( self )

		local sizeX, sizeY, sizeZ = self:GetSize()
		self.Particles[2]:SetPositionOffsets( 0, 0, zo_clamp( 0.01 * math.max( sizeX, sizeY ), 2, 20 ) )
		self:Update()

	end,

} )

do
	local intervalOffset = 0

	function AddFlamesEffect(data)
		local maxParticles = data.maxParticles

		return EHT.EffectType:New(data.id, data.name, {
			Category = CAT.ANIM,
			ResetOnScale = true,

			Init = function(self)
				self:SetAutoPositionEnabled(false)
				self:SetAutoSizeEnabled(false)
				self:SetAutoOrientationEnabled(false)
				self:SetSize(unpack(data.defaultSize))
				self:SetColor(unpack(data.defaultColor))
				self:SetContrast(2)
				self:SetOrientation(0, 0, 0)
				self:SetCameraFacing(true)

				intervalOffset = (intervalOffset + 390) % data.maxInterval
				self.IntervalOffset = intervalOffset

				for index = 0, maxParticles - 1 do
					local p = self:AddParticle(TEXTURES.FLAME_4,	 0, 0, 0,	 0, 0, 0,	 1, 1, 1, data.maxParticleAlpha or 1, 	1, 1, 	true, false, false)
					local progress = index / (maxParticles - 1)
					local interval = 0.5 - progress

					p:SetSize(0, 0)
					p:SetSampleProcessing(0.5 + progress)

					p.OffsetXYZ = interval
					p.StartTime = 0
					p.Interval = zo_lerp(data.minInterval, data.maxInterval, progress)
					p.EasingFunction = ZO_GenerateCubicBezierEase(.3 + .3 * interval, .6 + .4 * interval, .2 + .2 * interval, 1.5 + .5 * interval)
				end

				self:SpawnAtPlayer(150)
			end,

			Update = function(self)
				local x, y, z = self:GetPosition()
				local ft = FrameTime + self.IntervalOffset
				local PI = RAD180
				local sine, cosine = math.sin(CameraHeading), math.cos(CameraHeading)
				local _, forward = EHT.World.GetCameraForward()
				forward = math.abs(forward)
				local dForward = 1 - forward
				local cameraDistance = 1 + zo_lerp(1, 20, math.min(1, self:GetCameraDistance() / 100000))
				forward, dForward = forward * cameraDistance, dForward * cameraDistance

				for index, p in ipairs(self.Particles) do
					local p = self.Particles[index]
					local interval = (ft % p.Interval) / p.Interval
					local cXZ = p.OffsetXYZ * dForward
					local cY = p.OffsetXYZ * forward
					p:SetPosition(x + sine * cXZ * 100, y + cY * 100, z + cosine * cXZ * 100)

					local easing = p.EasingFunction(1 - interval)
					local scaleX = zo_lerp(p.MinAspectRatioX, p.AspectRatioX, easing)
					local scaleY = zo_lerp(p.MinAspectRatioY, p.AspectRatioY, easing)
					local tcY = zo_lerp(0.25, 0.75, interval)
					p:RotateCoords(0, 0.5, tcY, scaleX, scaleY)

					p:SetAlpha(.5 * math.sin(interval * PI))
				end
			end,

			Reset = function(self)
				local x, y, z = self:GetPosition()
				local sizeX, sizeY, sizeZ = self:GetSize()
				sizeX, sizeY, sizeZ = math.max(20, sizeX), math.max(20, sizeY), math.max(20, sizeZ)

				local pSize = math.max(sizeX, sizeY)
				local aspectRatio = zo_clamp(math.min(sizeX, sizeY) / pSize, 0.1, 0.7)
				local aspectRatioX = sizeX == pSize and ((aspectRatio + 0.7) * 0.5) or 0.7
				local aspectRatioY = sizeY == pSize and ((aspectRatio + 0.7) * 0.5) or 0.7
				for index = 1, #self.Particles do
					p = self.Particles[index]
					p:SetSize(sizeX, sizeY)
					local heightCoeff = (0 == index % 3) and 0.65 or 1
					p.AspectRatioX, p.AspectRatioY = aspectRatioX * (index % 2 == 0 and 1 or -1), heightCoeff * aspectRatioY
					p.MinAspectRatioX, p.MinAspectRatioY = p.AspectRatioX * 0.3, p.AspectRatioY * 0.3
				end
			end,
		})
	end
end

AddFlamesEffect({id = 547, name = "Flames", maxParticles = 5, minInterval = 900, maxInterval = 1500, defaultSize = {250, 250, 250}, defaultColor = {1, 0.5, 0, 1}, })

AddRandomizedParticleEffect(
	548, "Aether Shower", CAT.WEATHER, TEXTURES.AETHER_RAIN,
	50000, 3000, 3000,
	1, 1, 1, 1,
	0, 0.48, 0,
	0.5, 0, 0.5,
	1, 1, 1,
	0.05, 40, 40,
	true,
	10000, 10000,
	2, 2, 0, 0,
	0.8, 2,
	0.95, 0.95, 0.95, 0,
	1, 1, 1, 0.2,
	0, 2,
	0, 0, 0, 0,
	-700, -1200, 0,
	-700, -1200, 0,
	0, EHT.ParticleEmitter.ORIENTATIONS.VECTOR, false,
	EHT.ParticleEmitter.PATTERNS.RANDOM, nil, 0,
	false, false, nil, nil, nil,
	nil, nil, nil, nil,
	nil, nil,
	nil,
	nil,
	function( self )
		local e = self.Emitter
		e.MinSizeY, e.MaxSizeY = 120, 140
		e.Pitch = -0.2 * math.pi
		e:Reset()
	end
)

AddRandomizedParticleEffect(
	549, "Sparks", CAT.ANIM, TEXTURES.SOLID,
	200, 500, 500,
	1, 0.9, 0, 1,
	0, 0.48, 0,
	0.1, 0, 0.1,
	nil, 1, nil,
	1, 0, 10,
	false,
	10000, 10000,
	1.1, 1.1, 0, 0,
	0.8, 2,
	1, 1, 1, 1.2,
	1, 1, 1, 1.2,
	2, -2,
	0, 0, 0, 0,
	50, -200, 50,
	200, -400, 200,
	0, EHT.ParticleEmitter.ORIENTATIONS.VECTOR, false,
	EHT.ParticleEmitter.PATTERNS.RANDOM, EHT.ParticleEmitter.PATTERNS.PERIMETER, 0,
	false, false, 0, 0, 0,
	false, false, false, false,
	true, true,
	nil,
	function( self, emitter )
		local ft = FrameTime
		if not self.NextFrequencyShift or ft >= self.NextFrequencyShift then
			emitter.MinActiveEmissions = math.random( 1, 4 )
			emitter.PerEmissionDelay = math.random( 30, 500 )
			self.NextFrequencyShift = ft + math.random( 2000, 4000 )
		end
	end,
	function( self, emitter )
		emitter.MinActiveEmissions = 4
		emitter.PerEmissionDelay = 40
		emitter.Roll = 0.5 * math.pi
		emitter.MinSizeY = 1.1
		emitter.RangeSizeY = 0
		self.NextFrequencyShift = FrameTime + 4000
	end
)

EHT.EffectType:New( 550, "Arched Panel, Transparent", {

	Category = CAT.BUILD,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SOLID_ARCH, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.5, 1, 1, true, false )
		p:SetTextureWrapping( false )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 250 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 551, "Arched Panel, Opaque", {

	Category = CAT.BUILD,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.SOLID_ARCH, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( false )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 250 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 552, "Round Panel, Transparent", {

	Category = CAT.BUILD,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.CIRCLE, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.5, 1, 1, true, false )
		p:SetTextureWrapping( false )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 250 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 553, "Round Panel, Opaque", {

	Category = CAT.BUILD,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.CIRCLE, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false )
		p:SetTextureWrapping( false )

		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 250 )

	end,

	Reset = function( self )

		self:Update()

	end,

} )

EHT.EffectType:New( 554, "Moss, Dense", {

	Category = CAT.LAND,

	CanPitch = true,

	Init = function( self )

		local p

		p = self:AddParticle( TEXTURES.MOSS_1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, true )
		self:SetSize( 512, 512, 512 )
		self:SetColor( 0, 0.8, 0.15, 1 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 30 )

	end,

	Reset = function( self )

		self:Tile( 1024, 1024 )
		self:Update()

	end,

} )

AddCroppedEffect( 555, CAT.DECO, "Plate, Floral (Round)", TEXTURES.PLATE_1B, 64, 64, 0, 1, 0, 1, 				0, 0, 0,	0.5 * math.pi, 0, 0,	TEXTURES.PLATE_1,	0.35, 0.65, 1, 1,		1, 0, 1, 0.1,	0.15 )
AddCroppedEffect( 556, CAT.DECO, "Plate, Floral (Oval)", TEXTURES.PLATE_2B, 96, 84 / 1.5, 0, 1, 0, 84 / 128,	0, 0, 0,	0.5 * math.pi, 0, 0,	TEXTURES.PLATE_2,	0.35, 0.65, 1, 1,		1, 0, 1, 0.1,	0.15 )

local function AddRainfallEffect( index, name, texture, minSizeX, maxSizeX, minSizeY, maxSizeY, density, velocity, alpha, windFactor, pitch )

	return AddRandomizedParticleEffect(
		index, name, CAT.WEATHER, texture,
		50000, 3000, 3000,
		0.8, 1, 1, 1,
		0, 0.48, 0,
		0.5, 0, 0.5,
		nil, 1, nil,
		2, density, density,
		true,
		10000, 10000,
		2, 2, 0, 0,
		1, 1.5,
		0.9, 0.9, 0.9, 0,
		1, 1, 1, 0,
		0, alpha,
		0, 0, 0, 0,
		0, -2200 * velocity, 0,
		0, -4000 * velocity, 0,
		windFactor, 0 == pitch and EHT.ParticleEmitter.ORIENTATIONS.CAMERA or EHT.ParticleEmitter.ORIENTATIONS.VECTOR, false,
		EHT.ParticleEmitter.PATTERNS.RANDOM, nil, 0,
		nil, nil, nil, nil, nil,
		nil, nil, nil, nil,
		nil, nil,
		nil,
		nil,
		function( self, emitter )
			emitter.MinActiveEmissions = 0.5 * density
			emitter.RangeActiveEmissions = density
			emitter.MinSize = minSizeX or 1
			emitter.MaxSize = maxSizeX or 2
			emitter.MinSizeY = minSizeY
			emitter.MaxSizeY = maxSizeY
			emitter.Pitch = pitch
			emitter:Reset()
		end
	)

end

AddRainfallEffect( 557, "Rainfall, Light", TEXTURES.RAIN_DROP_1,	1, 2,	32, 64,		20,		1,	0.5,	100,	0 )
AddRainfallEffect( 558, "Rainfall, Moderate", TEXTURES.RAIN_DROP_1,	2, 3,	48, 96,		80,		2,	0.5,	500,	0 )
AddRainfallEffect( 559, "Rainfall, Heavy", TEXTURES.RAIN_DROP_1,	2, 3,	96, 128,	120,	2,	0.5,	1000,	0 )

AddTiledEffect( 560, CAT.DECO, "Books, Orderly Row", TEXTURES.BOOKS_2, 110, 52 )
AddCroppedEffect( 561, CAT.DECO, "Books, Single Volume", TEXTURES.BOOKS_2, 110, 52, 0, 1, 166/512, 1 )

-- 03/01/2019
EHT.EffectType:SetDefaultDateAdded( 1551472983 )

Add3DCroppedEffect( 562, CAT.DECO, "Harvest Node, Enchanting", TEXTURES.NODE_ENCHANTING, 53, 120, 11, 0, (53/120), 0, 1, 				0, 0, 0,	0, 0, 0,	TEXTURES.NODE_ENCHANTING_C,		1, 0, 0, 1,		1, 0, 1, 0,		0, 1, true )
AddCroppedEffect( 563, CAT.PET, "Cat, Sleeping", TEXTURES.CAT_1, 90, 58, 0, 1, 0, (360/512) )
AddCroppedEffect( 564, CAT.PET, "Kittens, Sleeping", TEXTURES.CAT_2, 82, 56, 0, 1, 0, (312/512) )

AddCroppedEffect( 565, CAT.LAND, "Alpinia, Garlas", TEXTURES.ALPINIA_1, 256*(262/512), 256, 0, 262/512, 0, 1 )

AddCroppedEffect( 566, CAT.DECO, "Geode, Magna", TEXTURES.MAGNA_GEODE_1, 64, 64*(230/256), 0, 1, 0, 230/256, 0, 0, 0, 0, 0, 0, nil, 1, 0.79, 0.25, 0.9 )

-- 03/02/2019
EHT.EffectType:SetDefaultDateAdded( 1551559415 )

AddWaterSpoutEffect( 567, "Geyser, Constant", false )

AddCroppedEffect( 568, CAT.LAND, "Tree, Tall Maple (Auridon)", TEXTURES.TREE_MAPLE_4_S, 1024, 950, 0, 1, 0, 950/1024, 0, 0, 0, 0, 0, 0, TEXTURES.TREE_MAPLE_4_C, 1, 0.1, 0, 1, 1, 0, 1, 0 )

-- 03/03/2019
EHT.EffectType:SetDefaultDateAdded( 1551645826 )

do
	local et = AddSceneryEffect( 569, "Void Chamber",		0.5, 24,		TEXTURES.SOLID, 0, 1,		TEXTURES.SOLID, 0, 1,		0, 0, 0, 1 )

	local init = et.Init
	et.Init = function( self )
		self.NumSegments = 48
		init( self )
		local p = self:AddParticle( TEXTURES.SOLID,		0, 0.25, 0,		0.5 * math.pi, 0, 0,	0, 0, 0, 1,		5, 5,		true, false, false )
	end

	local reset = et.Reset
	et.Reset = function( self )
		local numP = #self.Particles
		self:Update()
		reset( self )
		for index = 1, #self.Particles do
			self.Particles[index]:SetColor( 0, 0, 0, 1 )
		end
	end
end

-- 03/05/2019
EHT.EffectType:SetDefaultDateAdded( 1551732257 )

AddCroppedEffect( 570, CAT.DECO, "Shadowmark, Cache", TEXTURES.SHADOWMARK_CACHE, 64, 64, 0, 1, 0, 1 )
AddCroppedEffect( 571, CAT.DECO, "Shadowmark, Danger", TEXTURES.SHADOWMARK_DANGER, 64, 64, 0, 1, 0, 1 )
AddCroppedEffect( 572, CAT.DECO, "Shadowmark, Empty", TEXTURES.SHADOWMARK_EMPTY, 64, 64, 0, 1, 0, 1 )
AddCroppedEffect( 573, CAT.DECO, "Shadowmark, Escape", TEXTURES.SHADOWMARK_ESCAPE, 64, 64, 0, 1, 0, 1 )
AddCroppedEffect( 574, CAT.DECO, "Shadowmark, Fence", TEXTURES.SHADOWMARK_FENCE, 64, 64, 0, 1, 0, 1 )
AddCroppedEffect( 575, CAT.DECO, "Shadowmark, Guild", TEXTURES.SHADOWMARK_GUILD, 64, 64, 0, 1, 0, 1 )
AddCroppedEffect( 576, CAT.DECO, "Shadowmark, Loot", TEXTURES.SHADOWMARK_LOOT, 64, 64, 0, 1, 0, 1 )
AddCroppedEffect( 577, CAT.DECO, "Shadowmark, Protected", TEXTURES.SHADOWMARK_PROTECTED, 64, 64, 0, 1, 0, 1 )
AddCroppedEffect( 578, CAT.DECO, "Shadowmark, Safe", TEXTURES.SHADOWMARK_SAFE, 64, 64, 0, 1, 0, 1 )
AddShrubberyEffect( 579, "Ivy, Typical", TEXTURES.IVY_1, 512, 512, false )

AddTiledScaledEffect( 580, CAT.DECO, "Hay, Scattered", TEXTURES.HAY_1, 1024, 1024, nil, nil, nil, nil, nil, nil, 1, 0.875, 0.59, 1 )

EHT.EffectType:New( 581, "Glass, Frosted", {
	Category = CAT.BUILD,
	CanPitch = true,
	Init = function( self )
		local p = self:AddParticle( TEXTURES.GLASS_2,		0, 0, 0,	0, 0, 0,	1, 1, 1, 0.7,		1, 1,	true, false, false )
		p:SetSampleProcessing( 0.5, 0 )
		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0.08, 0.46, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 500 )
	end,
	Reset = function( self )
		self:Update()
		local p = self.Particles[1]
		local sx, sy = self:GetSize()
		if sx > sy then
			local ratio = sy / sx
			p:SetTextureCoords( 0, 1, 0, ratio )
		elseif sy > sx then
			local ratio = sx / sy
			p:SetTextureCoords( 0, ratio, 0, 1 )
		else
			p:SetTextureCoords( 0, 1, 0, 1 )
		end
	end,
} )

do
	local numP, scaleX, scaleY = 3, 4, 2
	EHT.EffectType:New( 582, "Fish, School of Angelfish", {
		Category = CAT.PET,
		CanPitch = true,
		Init = function( self )
			local ft = FrameTime
			local p, oR, oX, oY, x, y

			self.RangeOffsetX, self.MinOffsetX, self.MaxOffsetX = 1 + 2 * scaleX, -scaleX, scaleX
			self.RangeOffsetY, self.MinOffsetY, self.MaxOffsetY = 1 + 2 * scaleY, -scaleY, scaleY

			for index = 1, numP do
				oR = ( 1 == index and 0.2 or 2 == index and 0.4 or 0 )
				oX, oY = ( ( -0.8 + index ) / numP ), ( ( -0.8 + index + oR ) / numP )
				p = self:AddParticle( TEXTURES.FISH_2,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
				p:SetSampleProcessing( 0.8 )
				p.tX, p.tY, p.dX, p.sX = oX, oY, ( 0 == index % 2 ) and ( index / 100 ) or -( index / 100 ), ft + index * 500

				x = self.MinOffsetX + p.tX * self.RangeOffsetX
				p.tY = self.MinOffsetY + p.tY * self.RangeOffsetY
				p:SetTextureCoords( self.MinOffsetX + x, self.MaxOffsetX + x, self.MinOffsetY + p.tY, self.MaxOffsetY + p.tY )
			end

			self:SetSize( 300, 150, 150 )
			self:SetColor( 1, 1, 0, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 150 )
		end,
		Update = function( self )
			local ft = FrameTime
			local r, g, b, a = self:GetColor()
			local numP = #self.Particles
			local cInterval, p, x, y

			for index = 1, numP do
				p = self.Particles[index]

				if ft > p.sX then
					p.sX = ft + 2000 + 4000 * math.random()
					local sign = 0 < p.dX and -1 or 1
					p.dX = sign * 0.01 * ( 1 + ( 10 * math.random() ) )
				else
					cInterval = 0.05 * index * math.abs( GetEasedInterval( 1000 + 250 * index, index * 250 ) )
					p.tX = zo_clamp( p.tX + p.dX, self.MinOffsetX + 1, self.MaxOffsetX - 1 )
					y = 0.25 * cInterval + p.tY

					if 0 < p.dX then
						p:SetTextureCoords( self.MinOffsetX + p.tX, 1 + self.MaxOffsetX + p.tX + cInterval, self.MinOffsetY + y, self.MaxOffsetY + y )
					else
						p:SetTextureCoords( 1 + self.MaxOffsetX - p.tX + cInterval, self.MinOffsetX - p.tX, self.MinOffsetY + y, self.MaxOffsetY + y )
					end
				end
			end
		end,
		Reset = function( self )
			self:Update()
		end,
	} )
end

-- 03/07/2019
EHT.EffectType:SetDefaultDateAdded( 1551727134 )

AddTiledEffect( 583, CAT.LAND, "Flowers, Delphinium", TEXTURES.DELPHINIUM_1_N, 200, 180, 0.4, 0.4, 1, 1 )
AddCroppedEffect( 584, CAT.PET, "Pet, White Rabbit", TEXTURES.RABBIT_1_C, 64, 64, 0, 1, 0, 1 )

-- 03/08/2019
EHT.EffectType:SetDefaultDateAdded( 1551766627 )

AddCroppedEffect( 585, CAT.DECO, "Statue, Dibella", TEXTURES.STATUE_DIBELLA_1, 1250, 1380, 0, (905/1024), 0, 1 )

local function AddWindowDivineEffect( id, deity, column, row )
	AddCroppedEffect( id, CAT.BUILD, string.format( "Window, Divine %s", deity ), TEXTURES.WINDOW_DIVINES, 384, 1024, ( column - 1 ) * ( 400 / 2048 ), ( column - 1 ) * ( 400 / 2048 ) + ( 384 / 2048 ), ( row - 1 ) * 0.5, 0.5 + ( row - 1 ) * 0.5 )
end

-- 03/09/2019
EHT.EffectType:SetDefaultDateAdded( 1551896802 )

AddWindowDivineEffect( 586, "Kynareth", 1, 1 )
AddWindowDivineEffect( 587, "Mara", 2, 1 )
AddWindowDivineEffect( 588, "Zenithar", 3, 1 )
AddWindowDivineEffect( 589, "Stendarr", 4, 1 )
AddWindowDivineEffect( 590, "Dibella", 5, 1 )
AddWindowDivineEffect( 591, "Arkay", 1, 2 )
AddWindowDivineEffect( 592, "Akatosh", 2, 2 )
AddWindowDivineEffect( 593, "Julianos", 3, 2 )

-- 03/13/2019
EHT.EffectType:SetDefaultDateAdded( 1552194379 )

do
	local TexWidth, TexHeight = 2048, 2048
	local CellWidth, CellHeight = 341, 1024
	local LocalWidth, LocalHeight = 341, 960
	local CellsX, CellsY, CellInterval = 6, 1, 12000

	local function Say( name, msg )
		EHT.Subtitles:QueueMessages( name or "", msg )
	end

	EHT.EffectType:New( 594, "Cardinal05, NPC", {
		Category = CAT.NPC,
		CanPitch = true,
		ResetOnColor = true,

		MetaParams = {
			{
				Name = "Name",
				Deserializer = EHT.EffectDeserializers.StringVar,
				Serializer = EHT.EffectSerializers.StringVar,
			},
			{
				Name = "Message",
				Deserializer = EHT.EffectDeserializers.StringVar,
				Serializer = EHT.EffectSerializers.StringVar,
			},
		},

		Init = function( self )
			for index = 1, CellsX do
				local x1, x2 = ( index - 1 ) * ( CellWidth / TexWidth ), ( index - 1 ) * ( CellWidth / TexWidth ) + ( LocalWidth / TexWidth )

				local p = self:AddParticle( TEXTURES.NPC_CARDINAL,		0, 0, 0,	0, 0, 0,	1, 1, 1, 0,		1, 1,	true, false, false )
				local y1, y2 = 0, ( LocalHeight / TexHeight )
				p:SetTextureCoords( x1, x2, y1, y2 )
				p:SetAutoColorEnabled( false )

				local p = self:AddParticle( TEXTURES.NPC_CARDINAL,		0, 0, 0,	0, 0, 0,	1, 1, 1, 0,		1, 1,	true, false, false )
				local y1, y2 = ( CellHeight / TexHeight ), ( CellHeight / TexHeight ) + ( LocalHeight / TexHeight )
				p:SetTextureCoords( x1, x2, y1, y2 )
			end

			self:SetMetaData( "Name", self:GetMetaData( "Name" ) or "Cardinal05" )
			self:SetSize( 90, 235, 235 )
			self:SetColor( 1, 0.8, 0.2, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 118 )
		end,

		Update = function( self )
			local interval = GetLinearInterval( CellInterval )
			local numCells = CellsX
			local cellUnit = 1 / numCells
			local totalInterval = numCells * interval

			for index = 1, numCells do
				local cellInterval = zo_clamp( 1 + totalInterval - index, 0, 1 )
				local alpha = ( 0 < cellInterval and 1 > cellInterval ) and 1 or 0
				local p1, p2 = self.Particles[ 2 * index ], self.Particles[ 2 * index - 1 ]

				p1:SetAlpha( alpha )
				p2:SetAlpha( alpha )
				p1:SetDrawLevel( p2:GetDrawLevel() + 1 )
			end

			if EHT.Housing.IsHUDMode() then
				local inRange = 1000 > zo_distance3D( self.X, self.Y, self.Z, PlayerX, PlayerY, PlayerZ )
				if inRange and not self.Greeted then
					self.Greeted = true

					local message = self:GetMetaData( "Message" )
					if not message or "" == message then message = string.format( "Hello, %s. Edit me to configure a greeting for you and your guests.", GetDisplayName() ) end

					Say( self:GetMetaData( "Name" ), message )
				end
			end
		end,

		Reset = function( self )
			self.Greeted = false
			self:Update()
		end,
	} )
end

do

	EHT.EffectType:New( 595, "Custom Home Title", {

		Category = CAT.CUSTOM,

		Environmental = true,

		Global = true,

		MetaParams = {
			{
				Name = "Title",
				Deserializer = EHT.EffectDeserializers.StringVar,
				Serializer = EHT.EffectSerializers.StringVar,
			},
		},

		UniqueClass = "Home Title",

		Init = function( self )

			self:SetSize( 100, 100, 100 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 100 )

			local currentTitle = self:GetMetaData( "Title" )
			if not currentTitle or "" == currentTitle then
				local houseId, owner, isOwner, houseName, houseNickname, customHouseName = EHT.Housing.GetHouseInfo()
				self:SetMetaData( "Title", houseNickname or "" )
			end

		end,

		Reset = function( self )

			local currentTitle = self:GetMetaData( "Title" )
			if currentTitle and "" ~= currentTitle then
				EHT.UI.SetCustomHouseName( currentTitle )
			end

			self:Update()

		end,

		Destroy = function( self )

			EHT.UI.SetCustomHouseName( nil )

		end,

	} )

end

-- 03/15/2019
EHT.EffectType:SetDefaultDateAdded( 1552381010 )

do
	local et = AddCroppedEffect( 596, CAT.DECO, "Rug, Flying Dragon", TEXTURES.RUG_1, 256, 256*(352/512), 0, 1, 0, 1 )
	et.Submitter = "Catsmoke"
end

-- 03/16/2019
EHT.EffectType:SetDefaultDateAdded( 1552499422 )

do
	local et

	et = AddCroppedEffect( 597, CAT.DECO, "Book, Ornate, Clasped, Open", TEXTURES.BOOK_1_N, 50, 50*(997/1470), 0, 1, 0, 1,	0, 0, 0, 0, 0, 0,	TEXTURES.BOOK_1,	1, 1, 1, 1,		1, 0, 1, 0,		0.2 )
	et.Submitter = "Chryseia"

	et = AddCroppedEffect( 598, CAT.DECO, "Parchment, Scroll", TEXTURES.PARCHMENT_1, 50, 50*(879/685), 0, 1, 0, 1 )
	et.Submitter = "Chryseia"

	et = AddCroppedEffect( 599, CAT.DECO, "Parchment, Fancy", TEXTURES.PARCHMENT_2, 50, 50*(1000/824), 0, 1, 0, 1 )
	et.Submitter = "Chryseia"

	et = AddCroppedEffect( 600, CAT.DECO, "Parchment, Bound", TEXTURES.PARCHMENT_3, 50, 50*(1000/680), 0, 1, 0, 1 )
	et.Submitter = "Chryseia"
end

-- 03/17/2019
EHT.EffectType:SetDefaultDateAdded( 1552611870 )

AddCroppedEffect( 601, CAT.DECO, "Ship, Schooner", TEXTURES.SHIP_1, 10000, 10000*(1048/1225), 0, 1, 0, 1 )
AddCroppedEffect( 602, CAT.DECO, "Hay, Pile", TEXTURES.HAY_2, 500, 500*(445/768), 0, 1, 0, 1 )
AddCroppedEffect( 603, CAT.DECO, "Statue, Altmer Archer", TEXTURES.STATUE_1,	 500, 500*(1353/906),	 0, 1, 0, 1,	 0, 0, 0, 0, 0, 0,		TEXTURES.STATUE_1_C,	0.7, 0.7, 0.7, 1,		0.5, 0, 1, 0,		0.1 )
AddCroppedEffect( 604, CAT.DECO, "Statue, Altmer Warrior", TEXTURES.STATUE_2,	 365, 365*(1165/682),	 0, 1, 0, 1,	 0, 0, 0, 0, 0, 0,		TEXTURES.STATUE_2_C,	0.7, 0.7, 0.7, 1,		0.5, 0, 1, 0,		0.1 )

-- 03/26/2019
EHT.EffectType:SetDefaultDateAdded( 1553325125 )

do

	EHT.EffectType:New( 605, "Light of Meridia", {

		Category = CAT.LIGHT,
		CanPitch = true,

		Init = function( self )

			local p, off, x, y, z

			for index = 1, 3 do
				-- 0 + ( 1 == index and 0 or 2 * math.floor( index / 2 ) * ( 0 == index % 2 and -1 or 1 ) )
				p = self:AddParticle( TEXTURES.SMOKE_2,		0, 0, 16 - 10 * index,	0, 0, 0,	1 + 0.2 * index, 1 + 0.2 * index, 1 + 0.2 * index, 1,		1 - 0.05 * index, 1,		true, false, false )
				p:SetSampleProcessing( 0, 0 )
			end

			self.Duration = 10000
			self.DurationSlice = self.Duration / #self.Particles
			self.DurationOffset = math.random( 1, self.Duration )

			self:SetSize( 200, 200, 2000 )
			self:SetColor( 0.25, 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer()
			x, y, z = self:GetPosition()
			self:SetPosition( x, y + 920, z )

		end,

		Update = function( self )

			local alpha = 1 - math.sin( ( 1 - self:GetViewingAngleAlpha() ) * 0.5 * math.pi )
			local ps, np = self.Particles, #self.Particles
			local ii = 1 / np
			local c, i, p

			for index = 1, np do
				i = GetLinearInterval( 0.8 * self.Duration, self.DurationOffset + index * self.DurationSlice  ) -- 0.1 * self.Duration * index )
				i = ( 0 == index % 2 ) and i or 1 - i
				p = ps[index]
				c = i * index * ii

				if 0 == index % 2 then
					p:SetTextureCoords( -c, 0.95 + c, 0, 0.25 + 0.25 * i )
				else
					p:SetTextureCoords( 0.95 + c, -c, 0, 0.25 + 0.25 * i )
				end

				p:SetAlpha( alpha * 0.5 * math.sin( i * math.pi ) )
				p:SetSampleProcessing( 5, 5 * c )
			end

		end,

	} )

end

EHT.EffectType:New( 606, "Candle, Single", {

	Category = CAT.LIGHT,

	OrderDrawLevelByIndex = true,

	ResetOnScale = true,

	Init = function( self )

		self.IntervalOffset = math.random( 1, 20000 )

		local p = self:AddParticle( TEXTURES.CANDLES_1,	0, 0, 0,		0, 0, 0,	1, 1, 1, 1,			1, 1,		true, false, false )
		p:SetTextureCoords( -2, 3, -1, 1 )

		p = self:AddParticle( TEXTURES.FLAME_7,			0, 0, 0,		0, 0, 0,	1, 1, 1, 0.7,		1, 1,		true, false, false )
		p:SetTextureCoords( -( 1 / 0.08 ), 1 + ( 1 / 0.08 ), -( 1 / 0.25 ), 1 + ( 1 / 0.2 ) )
		p:SetAutoColorEnabled( false )
		p:SetColor( 1, 1, 1, 0.7 )

		p = self:AddParticle( TEXTURES.CIRCLE_SOFT,		0, 0, 0,		0, 0, 0,	1, 1, 0.5, 0.2,		1, 1,		true, true, false )
		p.Coords = {  }
		p:SetTextureCoords( -0.3, 1.3, -0.3, 1.3 )
		p:SetAutoColorEnabled( false )
		p:SetColor( 1, 1, 0.5, 0.2 )

		p = self:AddParticle( TEXTURES.CIRCLE_SOFT,		0, 0, 0,		0, 0, 0,	1, 1, 0.5, 0.2,		1, 1,		true, true, false )
		p:SetTextureCoords( 0, 1, 0, 1 )
		p:SetAutoColorEnabled( false )
		p:SetColor( 1, 1, 0.5, 0.2 )

		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 32, 32, 32 )
		self:Update()
		self:SpawnAtPlayer( 100 )

	end,

	Update = function( self )

		local fo = 0.1 * math.abs( GetEasedInterval( 2900, self.IntervalOffset ) ) + 0.1 * math.abs( GetEasedInterval( 4130, self.IntervalOffset ) ) + 0.1 * math.abs( GetEasedInterval( 6102, self.IntervalOffset ) )
		local x1, x2, y1, y2, p

		p = self.Particles[2]
		x1, x2, y1, y2 = -( 1 / 0.08 ), 1 + ( 1 / 0.08 ), -( 1 / 0.25 ), 1 + ( 1 / 0.2 )
		p:SetTextureCoords( x1, x2, y1 - 2.5 * fo, y2 + 2 * fo )

		fo = fo * 0.5

		p = self.Particles[3]
		x1, x2, y1, y2 = -0.3, 1.3, -0.3, 1.3
		p:SetTextureCoords( x1 - fo, x2 + fo, y1 - fo, y2 + fo )

		fo = fo * 0.1

		p = self.Particles[4]
		x1, x2, y1, y2 = 0, 1, 0, 1
		p:SetTextureCoords( x1 - fo, x2 + fo, y1 - fo, y2 + fo )

	end,

	Reset = function( self )

		local sx, sy, sz = self:GetSize()

		if sx ~= sy and sx ~= sz then
			self:SetSize( sx, sx, sx )
		elseif sy ~= sx and sy ~= sz then
			self:SetSize( sy, sy, sy )
		else
			self:SetSize( sz, sz, sz )
		end

		self:Update()

	end

} )

AddCroppedEffect( 607, CAT.LAND, "Icicles, Cavern", TEXTURES.ICICLE_1,				 500*(555/1024), 500,	 0, 1 )
AddCroppedEffect( 608, CAT.DECO, "Spider Web, Motionless", TEXTURES.SPIDERWEB_1,	 500, 500,	 0, 1 )

EHT.EffectType:New( 609, "Spider Web, Billowing", {
	Category = CAT.DECO,
	CanPitch = true,
	Init = function( self )
		self.Interval = 8000
		self.IntervalOffset = 1800
		self.IntervalRandom = math.random( 1, self.Interval )

		self:AddParticle( TEXTURES.SPIDERWEB_1,	0, 0, 0,		0, 0, 0,	1, 1, 1, 1,			1, 1,		true, false, false )
		self:SetColor( 1, 1, 1, 1 )
		self:SetSize( 500, 500, 500 )
		self:SpawnAtPlayer( 250 )
		self:Update()
	end,
	Update = function( self )
		local i, i2 = GetEasedInterval( self.Interval, self.IntervalRandom ), GetEasedInterval( self.Interval, self.IntervalRandom + self.IntervalOffset )
		local uv1, uv2, uv3, uv4 = 0.005 * i, 0.005 * i2, 0.01 * i, 0.01 * i2
		local p = self.Particles[1]
		local tex = p.Texture
		local r, g, b, a = self:GetColor()
		a = a * math.min( 1, 1 + 0.25 * i )

		tex:SetVertexUV( 1, -0.05 + uv1, -0.05 - uv3 )
		tex:SetVertexUV( 2, 1.05 + uv2, -0.05 - uv4 )
		tex:SetVertexUV( 4, -0.05 + uv1, 1.05 + uv3 )
		tex:SetVertexUV( 8, 1.05 + uv2, 1.05 + uv4 )
		p:SetVertexColors( 1, r, g, b, a )
		p:SetVertexColors( 2, r, g, b, a )
		p:SetVertexColors( 4, r, g, b, a )
		p:SetVertexColors( 8, r, g, b, a )
	end,
} )

AddCroppedEffect( 610, CAT.LAND, "Dirt (Round)", TEXTURES.DIRT_1_ROUND,	 500, 500,	 0, 1 )

-- 03/29/2019
EHT.EffectType:SetDefaultDateAdded( 1553588565 )

EHT.EffectType:New( 611, "Coins, Piled", {

	Category = CAT.DECO,
	CanPitch = true,
	OrderDrawLevelByIndex = true,
	ResetOnOrient = true,
	ResetOnPosition = true,
	ResetOnScale = true,
	MaxSize = { 90 * 10, 90 * 10, 90 * 10 },

	Init = function( self )

		self.TexSize = 90
		self:SetColor( 0.8, 0.6, 0, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 30 )
		self:SetSize( 90 * 5, 90 * 5, 90 * 5 )

	end,

	Reset = function( self )

		local r, g, b, a = self:GetColor()
		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local sizeX, sizeY, sizeZ = self:GetSize()

		sizeX, sizeY, sizeZ = sizeX or 1, sizeY or 1, sizeZ or 1
		pitch, yaw, roll = pitch or 0, yaw or 0, roll or 0

		local pNumX, pNumZ = sizeX / self.TexSize, sizeZ / self.TexSize
		local pScaleX, pScaleZ = 1 / pNumX, 1 / pNumZ
		local ps = self.Particles
		local pIndex, indexY, offsetX, startX = 1, 0, 0, 0
		local color, pM

		for indexZ = 0.5, pNumZ - 0.5, 0.25 do
			for indexX = 0.5 + startX, pNumX - 0.5 + startX, 1 do
				offsetX = ( indexZ % 1 ) * ( 1 / pNumX )
				color = 0.1 + 0.5 * math.sin( ( indexX / pNumX ) * math.pi ) + 0.5 * math.sin( ( indexZ / pNumZ ) * math.pi )

				if pIndex > #ps then
					p = self:AddParticle( TEXTURES.COINS_1,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,		true, false, false )
				else
					p = ps[pIndex]
				end

				p:SetSizeOffsets( pScaleX, pScaleZ )
				p:SetPositionOffsets( -0.5 + offsetX + ( indexX / pNumX ), indexY, -0.5 + ( indexZ / pNumZ ) )
				p:SetOrientationOffsets( math.rad( -87 ), 0, 0 )
				p:SetColorOffsets( color, color, color, 1 )

				pM = pIndex % 4
				if 0 == pM then
					p:SetTextureCoords( 0, 1, 0, 1 )
				elseif 1 == pM then
					p:SetTextureCoords( 1, 0, 0, 1 )
				elseif 2 == pM then
					p:SetTextureCoords( 0, 0, 1, 0 )
				elseif 3 == pM then
					p:SetTextureCoords( 1, 0, 1, 0 )
				end

				pIndex = pIndex + 1
			end
		end

		local excess = #ps - pIndex
		if 0 < excess then
			for index = #ps, pIndex, -1 do
				self:DeleteParticle(index)
			end
		end

		self:Update()

	end,

} )

-- 03/31/2019
EHT.EffectType:SetDefaultDateAdded( 1553819765 )

do
	local et = AddMultilayeredEffect( 612, CAT.DECO, "Pinwheel (Striped)", TEXTURES.MINT,	 128, 128,	1, 0, 0, 1,
	{
		{ X1 = 0.0, X2 = 0.5, Y1 = 0.0, Y2 = 0.5, Colored = false },
		{ X1 = 0.0, X2 = 0.5, Y1 = 0.5, Y2 = 1.0, Colored = true },
		{ X1 = 0.5, X2 = 1.0, Y1 = 0.0, Y2 = 0.5, Colored = false },
	} )
	et.Submitter = "StabbityDoom"
end

-- 04/02/2019
EHT.EffectType:SetDefaultDateAdded( 1554219365 )

local AddMusicEffect

do
	local activeMusic = { }
	local activeMusicMode = OVERRIDE_MUSIC_MODE_NONE
	local hasMusicReset = false

	local function OnMusicChanging()
		if hasMusicReset then
			EVENT_MANAGER:UnregisterForUpdate("EHT.OnMusicChanging")
			SetOverrideMusicMode(activeMusicMode)
		else
			hasMusicReset = true
			SetOverrideMusicMode(OVERRIDE_MUSIC_MODE_NONE)
		end
	end

	local function SetMusicState( musicMode, effect, enabled )
		if not musicMode then
			return
		end

		local music = activeMusic[musicMode]
		if not music then
			music = {}
			activeMusic[musicMode] = music
		end

		local changed = false
		if enabled then
			if not music[effect] then
				music[effect] = true
				changed = true
			end
		else
			if music[effect] then
				music[effect] = nil
				changed = true
			end
		end

		if not changed then
			return
		end

		local dominantMusicMode = OVERRIDE_MUSIC_MODE_NONE
		local dominantMusicModeCount = 0
		for musicModeElement, music in pairs(activeMusic) do
			local modeCount = 0
			for _, _ in pairs(music) do
				modeCount = modeCount + 1
			end
			if modeCount > dominantMusicModeCount then
				dominantMusicMode = musicModeElement
				dominantMusicModeCount = modeCount
			end
		end

		if activeMusicMode ~= dominantMusicMode then
			-- Champion music appears to clear the current sound track regardless of which sound track is currently playing.
			SetOverrideMusicMode(OVERRIDE_MUSIC_MODE_CHAMPION)
			hasMusicReset = false
			activeMusicMode = dominantMusicMode
			EVENT_MANAGER:UnregisterForUpdate("EHT.OnMusicChanging")
			EVENT_MANAGER:RegisterForUpdate("EHT.OnMusicChanging", 200, OnMusicChanging)
		end
	end

	AddMusicEffect = function( effectIndex, effectName, musicMode )
		local et = EHT.EffectType:New( effectIndex, effectName, {
			Category = CAT.SOUND,
			CanPitch = false,
			Global = true,
			ResetOnScale = true,
			ResetOnPosition = true,
			ResetOnOrient = false,

			Init = function( self )
				self:SetAutoColorEnabled( false )
				self:SetSize( 1000, 1000, 1000 )
				self:SpawnAtPlayer( 0 )

				local p1 = self:AddParticle( TEXTURES.CIRCLE_NEGATIVE,		0, 0, 0,	0, 0, 0,		0, 0, 0, 0,		1, 1,		false, false, false )
				p1:SetCameraFacing( true )
				p1:SetHidden( true )

				local p2 = self:AddParticle( TEXTURES.CIRCLE_SOFT_3,		0, 0, 0,	0, 0, 0,		0, 0, 0, 0,		1, 1,		false, false, false )
				p2:SetCameraFacing( true )
				p2:SetHidden( true )
				p2:RotateCoords( 0, 0.5, 0.5, 0.8, 0.8 )
			end,

			Update = function( self )
				if not self.Radius then return end

				local inRange = self:GetPlayerDistance() <= self.Radius
				SetMusicState( musicMode, self, inRange )

				local p1 = self.Particles[1]
				local p2 = self.Particles[2]

				if CurrentEditorEffect == self then
					local interval = GetLinearInterval( 2000 )
					local radians = 2 * math.pi * interval
					local sine = math.sin( radians )
					local sample = math.sin( math.pi * interval )
					local r, g, b = 0, inRange and 0.95 or 0, inRange and 0.95 or 0

					p1:SetVertexColors( 1, r, g, b, sine )
					p1:SetVertexColors( 2, r, g, b, math.sin( radians - 3 ) )
					p1:SetVertexColors( 8, r, g, b, math.sin( radians - 2 ) )
					p1:SetVertexColors( 4, r, g, b, math.sin( radians - 1 ) )
					p1:SetSampleProcessing( 0.5 + sample, inRange and 0 or 0.4 )
					p1:SetHidden( false )

					p2:SetColor( r, g, b, inRange and 0.65 or 1 )
					p2:SetSampleProcessing( sample, 0 )
					p2:SetHidden( false )
				else
					p1:SetHidden( true )
					p2:SetHidden( true )
				end
			end,

			Reset = function( self )
				local x, y, z = self:GetSize()
				if x ~= y and x ~= z then
					y, z = x, x
				else
					x, z = y, y
				end

				self:SetSize( x, y, z )
				self.Radius = 0.5 * x
			end,

			Destroy = function( self )
				SetMusicState( musicMode, self, false )
			end,
		} )

		return et
	end
end

AddMusicEffect( 613, "Music, Hymn of the Stars", OVERRIDE_MUSIC_MODE_CHAMPION )

-- 04/04/2019
EHT.EffectType:SetDefaultDateAdded( 1554367060 )

EHT.EffectType:New( 614, "Hide Grass", {
	Category = CAT.CUSTOM,
	Global = true,
	Environmental = true,
	UniqueClass = "Hide Grass",
	Init = function( self )
		self:SetAutoDrawLevelEnabled( false )
		EHT.Util.ModifySetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_CLUTTER_2D_QUALITY, 0 )
		self:SetColor( 0.5, 0.5, 0.5, 1 )
	end,
	Destroy = function( self )
		EHT.Util.RestoreSetting( SETTING_TYPE_GRAPHICS, GRAPHICS_SETTING_CLUTTER_2D_QUALITY )
	end,
} )

-- 04/06/2019
EHT.EffectType:SetDefaultDateAdded( 1554538880 )

AddMultilayeredEffect( 615, CAT.DECO, "Cake, Anniversary 2019", TEXTURES.CAKE_1,	 137, 196,	1, 1, 1, 1,		{ { X1 = 0.0, X2 = 380/512, Y1 = 0, Y2 = 1, Colored = true } } )
AddMultilayeredEffect( 616, CAT.DECO, "Cheese, Wedge", TEXTURES.CHEESE_1,	 24, 24*(105/128),	1, 1, 1, 1,		{ { X1 = 0.0, X2 = 1, Y1 = 0, Y2 = 105/128, Colored = true } } )
AddMultilayeredEffect( 617, CAT.DECO, "Cheese, Slice", TEXTURES.CHEESE_2,	 24, 24*(108/128),	1, 1, 1, 1,		{ { X1 = 0.0, X2 = 1, Y1 = 0, Y2 = 108/128, Colored = true } } )
AddMultilayeredEffect( 618, CAT.DECO, "Cheese, Wheel", TEXTURES.CHEESE_3,	 50, 50*(79/128),	1, 1, 1, 1,		{ { X1 = 0.0, X2 = 1, Y1 = 0, Y2 = 79/128, Colored = true } } )

-- 04/07/2019
EHT.EffectType:SetDefaultDateAdded( 1554619139 )

do

	EHT.EffectType:New( 619, "Frog, Hopping", {

		Category = CAT.PET,
		Submitter = "Scarlet-Ibis",

		Init = function( self )

			local ft = FrameTime
			local p

			self.NextHop = ft + math.random( 1, 5000 )
			self.Forward = true

			p = self:AddParticle( TEXTURES.FROG_HOP,	-0.5, 0, 0,			0, 0, 0,	1, 1, 1, 1,		0.15, 0.15,		true, false, false )
			p:SetTextureCoords( 0, 68/256, 0, 0.33 )
			p:SetHidden( false )

			p = self:AddParticle( TEXTURES.FROG_HOP,	-0.25, 0.15, 0,		0, 0, 0,	1, 1, 1, 1,		0.3, 0.15,		true, false, false )
			p:SetTextureCoords( 0, 0.65, 0.34, 0.66 )
			p:SetHidden( true )

			p = self:AddParticle( TEXTURES.FROG_HOP,	0, 0.3, 0,			0, 0, 0,	1, 1, 1, 1,		0.3, 0.15,		true, false, false )
			p:SetTextureCoords( 0.5, 1, 0, 0.33 )
			p:SetHidden( true )

			p = self:AddParticle( TEXTURES.FROG_HOP,	0.25, 0.15, 0,		0, 0, 0,	1, 1, 1, 1,		0.3, 0.15,		true, false, false )
			p:SetTextureCoords( 0, 0.65, 0.67, 1 )
			p:SetHidden( true )

			p = self:AddParticle( TEXTURES.FROG_HOP,	0.5, 0, 0,			0, 0, 0,	1, 1, 1, 1,		0.15, 0.15,		true, false, false )
			p:SetTextureCoords( 0, 68/256, 0, 0.33 )
			p:SetHidden( true )

			self:SetSize( 160, 180, 180 )
			self:SetColor( 0.3, 0.75, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 90 )

		end,

		Update = function( self )

			local ft = FrameTime

			if not self.NextHop then
				self.NextHop = ft
			end

			if self.NextHop and ft < self.NextHop then
				return
			end

			local interval = ( ft - self.NextHop ) / 2000
			local ps = self.Particles
			local visibleIndex = 1
			local yaw

			if interval <= 0.05 then
				visibleIndex = self.Forward and 2 or 4
			elseif interval <= 0.1 then
				visibleIndex = 3
			elseif interval <= 0.15 then
				visibleIndex = self.Forward and 4 or 2
			elseif interval <= 1 then
				visibleIndex = self.Forward and 5 or 1
			else
				visibleIndex = self.Forward and 5 or 1
				self.NextHop = ft + 5000 + math.random( 0, 5000 )
				self.Forward = not self.Forward

				for index = 1, 5 do
					_, yaw = ps[index]:GetOrientation()
					ps[index]:SetOrientationOffsets( nil, self.Forward and 0 or math.pi )
				end

				self:Update()
			end

			for index = 1, 5 do
				ps[index]:SetHidden( index ~= visibleIndex )
			end

		end,

		Reset = function( self )

			self:Update()

		end,

	} )

end

-- 04/08/2019
EHT.EffectType:SetDefaultDateAdded( 1554698920 )

do
	local function AddEffect( index, name, r, g, b, coords )

		local et = AddMultilayeredEffect( index, CAT.SIGIL, name, TEXTURES.RUNES_2,	 250, 250,		1, 1, 1, 0.05,		coords )
		local initFunc, updateFunc = et.Init, et.Update

		et.Init = function( self )
			self.Interval, self.IntervalOffset = math.random( 8000, 10000 ), math.random( 0, 10000 )
			if initFunc then initFunc( self ) end
			self:SetColor( r, g, b )
		end

		et.Update = function( self )
			if updateFunc then updateFunc( self ) end

			local interval = GetLoopInterval( self.Interval, self.IntervalOffset )
			local p = self.Particles[ 1 ]

			p:SetAlpha( zo_lerp( 0.2, 0.3, EaseInOut2( interval ) ) )
			p:SetSampleProcessing( 1, 1 + 18 * interval )
		end

	end

	AddEffect( 620, "Sigil, Fire",		1, 0.25, 0,		{ { X1 = 0,			X2 = 292/1024, Y1 = 0,			Y2 = 294/1024 } } )
	AddEffect( 621, "Sigil, Shock",		0, 1, 1,		{ { X1 = 293/1024,	X2 = 586/1024, Y1 = 0,			Y2 = 294/1024 } } )
	AddEffect( 622, "Sigil, Frost",		0, 0, 1,		{ { X1 = 587/1024,	X2 = 879/1024, Y1 = 0,			Y2 = 300/1024 } } )
	AddEffect( 623, "Sigil, Poison",	0, 0.5, 0,		{ { X1 = 0,			X2 = 292/1024, Y1 = 301/1024,	Y2 = 593/1024 } } )
	AddEffect( 624, "Sigil, Ash",		0.4, 0.4, 0.4,	{ { X1 = 294/1024,	X2 = 586/1024, Y1 = 301/1024,	Y2 = 602/1024 } } )
	AddEffect( 625, "Sigil, Frenzy",	1, 0.75, 0,		{ { X1 = 590/1024,	X2 = 886/1024, Y1 = 301/1024,	Y2 = 604/1024 } } )
end

do

	local et = AddTiledScaledEffect( 626, CAT.BUILD, "Wainscoting, Alinor Ornate", TEXTURES.WAINSCOTING_1, 48, 256, 1, 1 )
	et.ResetOnColor = true

	local resetFunc = et.Reset
	et.Reset = function( self )
		if resetFunc then resetFunc( self ) end

		self:Update()
		local r, g, b, a = self:GetColor()
		self.Particles[1]:SetColor( 0.8 + 0.2 * r, 0.8 + 0.2 * g, 0.8 + 0.2 * b, a )
	end

end

EHT.EffectType:New( 627, "Fountain, Alinor Recessed", {

	Category = CAT.BUILD,
	CanPitch = true,
	OrderDrawLevelByIndex = true,
	ResetOnColor = true,

	Init = function( self )

		self.Interval, self.IntervalOffset = math.random( 3800, 4400 ), math.random( 0, 4400 )
		local p

		p = self:AddParticle( TEXTURES.FOUNTAIN_1,	0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,		true, false, false )
		p:SetTextureCoords( 0, 0.5, 0, 1 )

		p = self:AddParticle( TEXTURES.FOUNTAIN_1,	0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,		true, false, false )
		p:SetTextureCoords( 0.5, 1, 0, 1 )
		p:SetSampleProcessing( 1, 1 )

		p = self:AddParticle( TEXTURES.FOUNTAIN_1,	0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,		true, false, false )
		p:SetTextureCoords( 1, 0.495, 0, 1 )
		p:SetSampleProcessing( 1, 0.4 )

		self:SetSize( 105, 256, 256 )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 128 )

	end,

	Update = function( self )

		local interval = GetLoopInterval( self.Interval, self.IntervalOffset )
		local p

		p = self.Particles[2]
		p:SetColor( 0.5, 1, 1, 0.4 * interval )

		p = self.Particles[3]
		p:SetColor( 0.5, 1, 1, 0.4 * ( 1 - interval ) )

	end,

	Reset = function( self )

		self:Update()
		local r, g, b, a = self:GetColor()
		self.Particles[1]:SetColor( 0.8 + 0.2 * r, 0.8 + 0.2 * g, 0.8 + 0.2 * b, a )

	end,

} )

-- 04/11/2019
EHT.EffectType:SetDefaultDateAdded( 1555000933 )

AddMultilayeredEffect( 628, CAT.DECO, "Sword, Glass", TEXTURES.SWORDS_1,	 40, 140,		0, 0.4, 0, 1,		{ { X1 = 0, X2 = 206/1024, Y1 = 0, Y2 = 1, Colored = false }, { X1 = 207/1024, X2 = 412/1024, Y1 = 0, Y2 = 1, A = 0.1, SampleRGB = 3, SampleAlpha = 3, Colored = true }, } )

do
	local et

	et = AddMultilayeredEffect( 629, CAT.DECO, "Candy Cane", GetCustomTemplateTexture( 5029 ),	 128*(410/1024), 128,		1, 0, 0, 1,		{
		{ X1 = 2/1024, X2 = 408/1024, Y1 = 2/1024, Y2 = 1022/1024, Colored = false },
		{ X1 = 502/1024, X2 = 908/1024, Y1 = 2/1024, Y2 = 1022/1024, Colored = true },
	} )
	et.OrderDrawLevelByIndex = true
	et.Submitter = "StabbityDoom"

	et = AddMultilayeredEffect( 630, CAT.DECO, "Heart", GetCustomTemplateTexture( 5030 ),	 128, 128,		1, 0, 0, 1,		{ { X1 = 0, X2 = 1, Y1 = 0, Y2 = 1, Colored = true }, } )
	et.Submitter = "StabbityDoom"
end

AddMultilayeredEffect( 631, CAT.DECO, "Spade", TEXTURES.SPADE,	 128, 128,		0, 0, 0, 1,		{ { X1 = 0, X2 = 1, Y1 = 0, Y2 = 1, Colored = true } } )

EHT.EffectType:New( 632, "Chilled Air", {
	Category = CAT.WEATHER, CanPitch = true, OrderDrawLevelByIndex = true,
	Init = function( self )
		self.IntervalOffset = math.random( 10000 )
		for index = 1, 2 do
			local p = self:AddParticle( TEXTURES.SMOKE_3,		0, 0, 0,	0, 0, 0,		1.35, 1.35, 1.35, 0.35,		1, 1,		true, true, false )
			p:SetTextureCoords( 0, 0, 0, 0 )
		end
		self:SetSize( 500, 500, 500 )
		self:SetColor( 1, 1, 1, 1 )
		self:SpawnAtPlayer( 0 )
	end,
	Update = function( self )
		local interval, p
		local x, y, z = self:GetPosition()
		local pitch, _, roll = self:GetOrientation()

		p = self.Particles[1]
		interval = GetLinearInterval( self.Interval, self.IntervalOffset )
		p:SetTextureCoords( -0.2, 1, interval - 1, interval + 1 )
		p:SetAlpha( 0.5 > interval and interval or ( 1 - interval ) )

		p = self.Particles[2]
		interval = GetLinearInterval( self.Interval, self.IntervalOffset + 0.4 * self.Interval )
		p:SetTextureCoords( 1, -0.1, interval - 1, interval + 1 )
		p:SetAlpha( 0.5 > interval and interval or ( 1 - interval ) )
	end,
	Reset = function( self )
		self:Update()
		local sx, sy, sz = self:GetSize()
		self.Interval = ( sy / 120 ) * 1000
	end,
} )

do
	local blurActive

	local function SetBlur( enabled )
		blurActive = enabled

		if blurActive then
			SetFullscreenEffect( FULLSCREEN_EFFECT_UNIFORM_BLUR, nil, nil, false )
		else
			SetFullscreenEffect( FULLSCREEN_EFFECT_NONE, nil, nil, false )
		end
	end

	EHT.EffectType:New( 633, "Blurred Vision", {

		Category = CAT.CUSTOM,
		CanPitch = false,
		Global = false,
		ResetOnScale = true,
		ResetOnPosition = false,
		ResetOnOrient = false,

		Init = function( self )
			self:SetAutoColorEnabled( false )
			self:AddParticle( TEXTURES.CIRCLE_SOFT,		0, 0, 0,	0, 0, 0,		0.5, 1, 1, 0.35,		1, 1,		false, false, true ):SetColor( 0.5, 1, 1, 0.35 )
			self:AddParticle( TEXTURES.CIRCLE_SOFT,		0, 0, 0,	RAD90, 0, 0,	0.5, 1, 1, 0.35,		1, 1,		false, false, true ):SetColor( 0.5, 1, 1, 0.35 )

			self:SetSize( 1000, 1000, 1000 )
			self:SpawnAtPlayer( 0 )
		end,

		Update = function( self )
			if not self.Radius then return end

			local distance = self:GetPlayerDistance()
			local inRange = distance <= self.Radius

			if self:IsHidden() or ( inRange and not blurActive ) then
				SetBlur( true )
			elseif not inRange and blurActive then
				SetBlur( false )
			end

			if CurrentEditorEffect == self then
				self.Particles[1].Texture:Set3DRenderSpaceOrientation( 0, CameraHeading, 0 )

				if inRange then
					local si = GetLoopInterval( 4000, 0 )

					self.Particles[1]:SetSampleProcessing( 1, si )
					self.Particles[1]:SetHidden( false )

					self.Particles[2]:SetSampleProcessing( 1, si )
					self.Particles[2]:SetHidden( false )
				else
					self.Particles[1]:SetSampleProcessing( 1, 0 )
					self.Particles[1]:SetHidden( false )

					self.Particles[2]:SetSampleProcessing( 1, 0 )
					self.Particles[2]:SetHidden( false )
				end
			elseif not self.Particles[1]:GetHidden() then
				self.Particles[1]:SetHidden( true )
				self.Particles[2]:SetHidden( true )
			end
		end,

		Reset = function( self )
			local x, y, z = self:GetSize()

			self:SetSize( x, x, x )
			self.Radius = 0.5 * x

			SetBlur( false )
		end,

		Destroy = function( self )
			SetBlur( false )
		end,

	} )
end

-- 04/13/2019
EHT.EffectType:SetDefaultDateAdded( 1555167923 )

AddMultilayeredEffect( 634, CAT.LAND, "Ice Sheet (Round)", TEXTURES.ICE_2_ROUND,	 500, 500,		1, 1, 1, 1,	{
	{ X1 = 0, X2 = 1, Y1 = 0, Y2 = 1, R = 1, G = 0.9, B = 1, A = 0.35, Colored = true },
	{ X1 = 1, X2 = 0, Y1 = 1, Y2 = 0, R = 0.9, G = 1, B = 1, A = 0.35, Colored = true },
} )

AddSkyEffect(

	635, "Icy Prison",

	-- Options
	{ },

	-- Side Textures Table
	{

		{
			Texture = TEXTURES.ICE_WALL_1,
			Stretch = true, AddColor = false, Wrap = true,
			R = 0.6, G = 1, B = 1, A = 0.1,
			X1 = 0, X2 = 4, Y1 = 0, Y2 = 1,
			SampleRGB = 1, SampleAlpha = 0,
		},

	},

	-- Top Texture Filename
	TEXTURES.SOLID,

	-- Reset Handler
	function( self )
		self.TopTexture:SetHidden( true )
	end,

	-- Update Handler
	nil

)

-- 04/15/2019
EHT.EffectType:SetDefaultDateAdded( 1555349131 )

AddMultilayeredEffect( 636, CAT.BUILD, "Book Shelves, Wall Unit 1", TEXTURES.BOOKSHELVES_1,	 903, 744,		1, 1, 1, 1,	{ { Colored = true }, } )
AddMultilayeredEffect( 637, CAT.BUILD, "Book Shelves, Wall Unit 2", TEXTURES.BOOKSHELVES_2,	 903, 744,		1, 1, 1, 1,	{ { Colored = true }, } )

-- 04/23/2019
EHT.EffectType:SetDefaultDateAdded( 1556058905 )

AddSkyEffect(

	638, "Virtual Reality",

	-- Options
	{ R = 0.25, G = 0.6, B = 0.7, },

	-- Side Textures Table
	{
		{
			Texture = TEXTURES.GRID_1,
			Stretch = true, DodgeColor = true, Wrap = true,
			R = 0.5, G = 0.5, B = 0.5, A = 0,
			X1 = 0, X2 = 72, Y1 = 0, Y2 = 20,
			SampleRGB = 1, SampleAlpha = 0,
		},
		{
			Texture = TEXTURES.SMOKE_1_TILE,
			Stretch = true, AddColor = true, Wrap = true,
			R = 1, G = 1, B = 1, A = 0.2,
			X1 = 0, X2 = 1, Y1 = 0, Y2 = 1,
			SampleRGB = 1, SampleAlpha = 0,
		},
	},

	-- Top Texture Filename
	TEXTURES.SOLID,

	-- Reset Handler
	function( self )
		self.IntervalOffset = FrameTime
		self.TopTexture:SetHidden( true )
	end,

	-- Update Handler
	function( self )

		if not self.TextureFaces then return end

		local sc = 25 + 25 * GetLoopInterval( 1800, ( self.IntervalOffset or 0 ) )
		local r, g, b, a = self:GetColor()
		local faces, faces2 = self.TextureFaces[2], self.TextureFaces[3]
		local numFaces = #faces
		local perFace = 1 / numFaces
		local a11, a12, a21, a22, face, interval

		for index = 1, numFaces do

			interval = GetLinearInterval( 6000, ( self.IntervalOffset or 0 ) + 2500 * ( index / numFaces ) )

			if 0.25 > interval then
				interval = interval * 4
				a11 = zo_clamp( math.sin( 2 * math.pi * interval ), 0, 1 )
				a21 = zo_clamp( math.sin( 2 * math.pi * ( interval - perFace ) ), 0, 1 )
			else
				a11, a21 = 0, 0
			end

			interval = GetLinearInterval( 6000, ( self.IntervalOffset or 0 ) + 2500 - 2500 * ( index / numFaces ) )

			if 0.25 > interval then
				interval = ( interval - 0 ) * 4
				a22 = zo_clamp( math.sin( 2 * math.pi * interval ), 0, 1 )
				a12 = zo_clamp( math.sin( 2 * math.pi * ( interval - perFace ) ), 0, 1 )
			else
				a12, a22 = 0, 0
			end

			a11, a21 = zo_clamp( a11 + a12, 0, 1 ), zo_clamp( a21 + a22, 0, 1 )

			face = faces[index]
			face:SetVertexColors( 1 + 4, r, g, b, a * a11 )
			face:SetVertexColors( 2 + 8, r, g, b, a * a21 )
			face:SetSampleProcessing( 1, sc )

			face = faces2[index]
			face:SetVertexColors( 1 + 4, r, g, b, a * 0.15 + 0.2 * a11 )
			face:SetVertexColors( 2 + 8, r, g, b, a * 0.15 + 0.2 * a21 )

		end

	end

)

-- 04/30/2019
EHT.EffectType:SetDefaultDateAdded( 1556645304 )

do
	local et = AddMultilayeredEffect( 639, CAT.BUILD, "Window, Clockwork", TEXTURES.WINDOW_CLOCKWORK,	 640, 760,		1, 1, 1, 1,	{
		{ X1 = 0, X2 = 0.5, Y1 = 0, Y2 = 1, R = 1, G = 1, B = 1, A = 1, Colored = false },
		{ X1 = 0.5, X2 = 1, Y1 = 0, Y2 = 1, R = 1, G = 1, B = 1, A = 1, Colored = true },
	} )
	et.Submitter = "Divine Design Alliance"
end

EHT.EffectType:New( 640, "Leaves, Spiraling", {
	Category = CAT.ANIM,
	MinSize = { 20, 20, 20 },

	Init = function( self )
		self:SetSize( 500, 1000, 500 )
		self:SetColor( 0.05, 0.6, 0.05, 1 )
		self:SpawnAtPlayer( 500 )
	end,

	Update = function( self )
		if self.Emitter then self.Emitter:Update() end
	end,

	Reset = function( self )
		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()

		if sx < 50 or sy < 50 then
			self:SetSize( math.max( 50, sx ), math.max( 50, sy ) )
			sx, sy, sz = self:GetSize()
		end

		local maxDim = math.max( sx, sy, sz )
		local ttl = 60000
		r, g, b = 0.9 * r, 0.9 * g, 0.9 * b

		local o = { }
		o.Texture = TEXTURES.LEAVES
		o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.CAMERA, yaw
		o.EmissionX, o.EmissionY, o.EmissionZ = x, y + 0.5 * sy, z
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0.5 * sx, 0, 0.5 * sx
		o.ReuseActiveEmissions = false
		o.MinActiveEmissions = 1
		o.MaxActiveEmissions = 10
		o.EmissionFrequency = zo_clamp( sy / 12, 500, 4000 )
		o.EmissionPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
		o.EmissionMinRadius = 0.35
		o.EmissionMaxRadius = 0.8
		o.EmissionInterval = 24000
		o.EmissionIntervalOffset = math.random() * 10000
		o.WindFactor = 0
		o.MaxOffsetY = 0.51 * sy
		o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 8, 11, 0, 0
		o.MinTTL, o.MaxTTL = ttl, ttl
		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r - 0.15, g - 0.15, b - 0.15, 0
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r + 0.15, g + 0.15, b + 0.15, 0
		o.ColorShift, o.AlphaShift = 0.4, 4
		o.MinRotation, o.MaxRotation, o.MinAngularVelocity, o.MaxAngularVelocity = -math.pi, math.pi, -1 * math.pi, 1 * math.pi
		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.SPIRAL
		o.MinVectorX, o.MinVectorY, o.MinVectorZ = -0.05 * sx, zo_clamp( -0.1 * sy, -100, -80 ), -0.05 * sx
		o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 0.05 * sx, zo_clamp( -0.05 * sy, -50, -40 ), 0.05 * sx
		o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = false, false, false, false
		o.UseCellAnimation, o.CellsStatic, o.CellsFPS, o.CellsX, o.CellsY = true, false, 8, 8, 2
		o.LockAtRange, o.RecycleAtRange = false, true

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end
	end,
} )

-- 5/2/2019
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1556820418 )

do
	local ALPHA_COEFF = 0.1
	local ALPHA_INTERVAL = 4000

	local et = AddMultilayeredEffect( 641, CAT.LIGHT, "God Rays, Dense", TEXTURES.LIGHT_RAYS_3,	 500, 500,	0.8, 0.7, 0, 1,	{ { Additive = true, Colored = true }, { Additive = true, Colored = true }, { Additive = true, Colored = true }, { Additive = true, Colored = true }, } )
	et.OrderDrawLevelByIndex = true

	local reset = et.Reset
	et.Reset = function( self )
		if reset then reset( self ) end

		local r, g, b = self:GetColor()
		local numP = #self.Particles
		local p

		self.AlphaInterval = ALPHA_INTERVAL
		self.AlphaOpacity = 6
		self.IntervalOffset = math.random( 1, 10000 )

		p = self.Particles[1]
		p:SetTextureCoords( -0.2, 1, 0, 1.2 )
		p:SetSampleProcessing( 1, 10 )
		p:SetVertexColors( 1, r, g, b, 0 )
		p:SetVertexColors( 2 + 4 + 8, r, g, b, 0.1 )

		p = self.Particles[2]
		p:SetTextureCoords( 0, 1.2, -0.2, 1 )
		p:SetSampleProcessing( 1, 10 )
		p:SetVertexColors( 2, 0.5 * r, 0.5 * g, 0.5 * b, 0 )
		p:SetVertexColors( 1 + 4 + 8, 0.5 * r, 0.5 * g, 0.5 * b, 0.1 )

		p = self.Particles[3]
		p:SetTextureCoords( 0, 1.2, 0, 1.2 )
		p:SetSampleProcessing( 1, 10 )
		p:SetVertexColors( 4, 0.5 * r, 0.5 * g, 0.5 * b, 0 )
		p:SetVertexColors( 1 + 2 + 8, 0.5 * r, 0.5 * g, 0.5 * b, 0.1 )

		p = self.Particles[4]
		p:SetTextureCoords( -0.2, 1, -0.2, 1 )
		p:SetSampleProcessing( 1, 10 )
		p:SetVertexColors( 8, r, g, b, 0 )
		p:SetVertexColors( 1 + 2 + 4, r, g, b, 0.1 )
	end

	local update = et.Update
	et.Update = function( self )
		if update then update( self ) end

		local r, g, b = self:GetColor()
		local ai = self.AlphaInterval
		local a = 0.2 * self:GetViewingAngleAlpha()
		local cc = 0.5 + 0.5 * GetLoopInterval( 1.3 * ai, self.IntervalOffset )
		local c = self.AlphaOpacity
		local interval, p

		i = GetLoopInterval( ai, self.IntervalOffset )
		p = self.Particles[1]
		p:SetVertexColors( 2 + 4 + 8, cc * r, g, b, a )
		p:SetSampleProcessing( 1, c * i )

		i = GetLoopInterval( 1.2 * ai, 0.25 * ai + self.IntervalOffset )
		p = self.Particles[2]
		-- cc = 1 - cc
		p:SetVertexColors( 1 + 2 + 8, r, cc * g, cc * b, a )
		p:SetSampleProcessing( 1.5, c * i )

		i = GetLoopInterval( 1.6 * ai, 0.5 * ai + self.IntervalOffset )
		p = self.Particles[3]
		-- cc = ( cc + 0.25 ) % 1
		p:SetVertexColors( 1 + 2 + 8, cc * r, cc * g, b, a )
		p:SetSampleProcessing( 0.5, c * i )

		i = GetLoopInterval( 1.4 * ai, 0.75 * ai + self.IntervalOffset )
		p = self.Particles[4]
		-- cc = ( cc - 0.5 ) % 1
		p:SetVertexColors( 1 + 2 + 4, cc * r, g, cc * b, a )
		p:SetSampleProcessing( 2, c * i )
	end
end

do
	local et = AddMultilayeredEffect( 642, CAT.LAND, "Rose, Long-stemmed", TEXTURES.ROSE_1,	 9, 40,		1, 0.15, 0.33, 1,	{
		{ X1 = 0, X2 = 0.5, Y1 = 0, Y2 = 1, R = 1, G = 1, B = 1, A = 1, Colored = false },
		{ X1 = 0.5, X2 = 1, Y1 = 0, Y2 = 1, R = 1, G = 1, B = 1, A = 1, Colored = true },
	} )
	et.Submitter = "StabbityDoom"
end

do
	local et = AddMultilayeredEffect( 643, CAT.LAND, "Rose, Short-stemmed", TEXTURES.ROSE_1,	 9, 20,		1, 0.15, 0.33, 1,	{
		{ X1 = 0.5, X2 = 0, Y1 = 0, Y2 = 0.5, R = 1, G = 1, B = 1, A = 1, Colored = false },
		{ X1 = 1, X2 = 0.5, Y1 = 0, Y2 = 0.5, R = 1, G = 1, B = 1, A = 1, Colored = true },
	} )
	et.Submitter = "StabbityDoom"
end

-- 5/8/2019
EHT.EffectType:SetDefaultDateAdded( 1557358170 )

EHT.EffectType:New( 644, "Waterfall, New", {

	Category = CAT.LAND,

	CanPitch = true,

	OrderDrawLevelByIndex = true,

	Init = function( self )

		self.Interval, self.IntervalOffset = 4000, math.random( 0, 4000 )
		local p

		for index = 1, 10 do
			p = self:AddParticle( TEXTURES.WATERFALL_3,		0, 0, 0,	0, 0, 0,	0.6 + 0.1 * index, 0.6 + 0.1 * index, 0.6 + 0.1 * index, 1,		1, 1,	true, true, true )
			p:SetSampleProcessing( 1, 0.005 )
			p:SetTextureCoords( ( 0 == index % 2 ) and 1 or 0, ( 0 == index % 2 ) and 0 or 1, 0 + 0.1 * ( index - 1 ), 1 )
		end

		self:SetSize( 500, 1000, 500 )
		self:SetColor( 0.3, 0.3, 0.3, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 500 )

	end,

	Update = function( self )

		local intervalSlice = self.Interval / #self.Particles
		local r, g, b = self:GetColor()
		local interval, p, x, y

		for index = 1, #self.Particles do
			interval = GetLinearInterval( self.Interval, self.IntervalOffset + index * intervalSlice )
			p = self.Particles[index]
			if 0 == index % 2 then x, y = 0, 1 else x, y = 1, 0 end
			p:SetTextureCoords( x, y, interval, interval - 1 )
			p:SetVertexColors( 1 + 2, r, g, b, 0.5 )
			p:SetVertexColors( 4 + 8, r, g, b, 0 )
		end

	end,

	Reset = function( self )
	end,

} )

-- 5/24/2019
EHT.EffectType:SetDefaultDateAdded( 1558694856 )

local function AddVortexEffect( index, name, cDirection )
	return EHT.EffectType:New( index, name, {
		Category = CAT.ANIM,
		CanPitch = true,
		OrderDrawLevelByIndex = true,
		Init = function( self )
			self.SampleInterval = 8000
			--self.RotationInterval1 = 500
			--self.RotationInterval2 = 1000
			self.RotationOffset = math.random(0, 10000)

			self:AddParticle(TEXTURES.WHIRLPOOL_2,		0, 0, 0,		0, 0, 0,		1.0, 1.0, 1.0, 0.95,	1.0, 1.0,	true, false, false)
			self:AddParticle(TEXTURES.WHIRLPOOL_2,		0, 0, 3,		0, 0, 0,		0.6, 0.6, 0.6, 0.8,		0.7, 0.7,	true, false, false)

			self:SetSize(500, 0, 500)
			self:SetOrientation(math.rad(-90), 0, 0)
			self:SpawnAtPlayer(50)
		end,
		Update = function( self )
			local offset = self.RotationOffset
			local sampleInterval = GetLinearInterval(self.SampleInterval, offset)
			local sample = 0.5 * math.sin(sampleInterval * RAD360)
			local i1 = (sampleInterval * 8) % 1
			local i2 = (i1 * 2) % 1
			if 0 > cDirection then
				i1, i2 = 1 - i1, 1 - i2
			end

			local p = self.Particles[1]
			p:SetTextureRotation(RAD360 * i1)
			p:SetSampleProcessing(1 - sample, 0)

			p = self.Particles[2]
			p:SetTextureRotation(RAD360 * i2)
			p:SetSampleProcessing(1 + math.abs(sample), sample)
		end,
		Reset = function( self )
			local _, yaw = self:GetOrientation()
			local width = self:GetSize()
			if width then
				self:SetSize( width, width, width )
			end
			local offset = zo_clamp(0.005 * width, 3, 2000)

			self.Particles[2]:SetPositionOffsets(0, 0, offset)
			self.SampleInterval = 8 * math.max(500, math.log(width) * 500)
			self:Update()
		end,
	} )
end

AddVortexEffect( 645, "Vortex", 1 )
AddVortexEffect( 646, "Vortex (Reverse)", -1 )

-- 5/28/2019
EHT.EffectType:SetDefaultDateAdded( 1559090213 )

local function AddGuildHeraldryEffect( id, effectName, isAnimated )

	local et = EHT.EffectType:New( id, effectName, {

		Category = CAT.HERALDRY,
		CanPitch = true,
		OrderDrawLevelByIndex = true,
		ResetOnColor = true,
		ResetOnScale = true,
		ResetOnOrient = true,
		ResetOnPosition = true,

		MetaParams = {
			{
				Name = "GuildId",
				Deserializer = EHT.EffectDeserializers.Int8,
				Serializer = EHT.EffectSerializers.Int8,
			},
			{
				Name = "HeraldryBkgCat",
				Deserializer = EHT.EffectDeserializers.Int5,
				Serializer = EHT.EffectSerializers.Int5,
			},
			{
				Name = "HeraldryBkgStyle",
				Deserializer = EHT.EffectDeserializers.Int5,
				Serializer = EHT.EffectSerializers.Int5,
			},
			{
				Name = "HeraldryBkgColor1",
				Deserializer = EHT.EffectDeserializers.Int5,
				Serializer = EHT.EffectSerializers.Int5,
			},
			{
				Name = "HeraldryBkgColor2",
				Deserializer = EHT.EffectDeserializers.Int5,
				Serializer = EHT.EffectSerializers.Int5,
			},
			{
				Name = "HeraldryCrestCat",
				Deserializer = EHT.EffectDeserializers.Int5,
				Serializer = EHT.EffectSerializers.Int5,
			},
			{
				Name = "HeraldryCrestStyle",
				Deserializer = EHT.EffectDeserializers.Int5,
				Serializer = EHT.EffectSerializers.Int5,
			},
			{
				Name = "HeraldryCrestColor",
				Deserializer = EHT.EffectDeserializers.Int5,
				Serializer = EHT.EffectSerializers.Int5,
			},
		},

		Init = function( self )
			self.Interval1 = 4000
			self.Interval2 = self.Interval1 * 2
			self.IntervalRandom = math.random( 1, math.max( self.Interval1, self.Interval2 ) )

			for index = 1, 3 do
				self:AddParticle( TEXTURES.SOLID,	0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
			end

			self:SetSize( 1000, 1000, 1000 )
			self:SetOrientation( 0, 0, 0 )
			self:SetColor( 1, 1, 1, 1 )
			self:SpawnAtPlayer( 500 )
		end,

		Reset = function( self )
			local bkgCat, bkgStyle, bkgColor1, bkgColor2, crestCat, crestStyle, crestColor = tonumber( self:GetMetaData( "HeraldryBkgCat" ) ), tonumber( self:GetMetaData( "HeraldryBkgStyle" ) ), tonumber( self:GetMetaData( "HeraldryBkgColor1" ) ), tonumber( self:GetMetaData( "HeraldryBkgColor2" ) ), tonumber( self:GetMetaData( "HeraldryCrestCat" ) ), tonumber( self:GetMetaData( "HeraldryCrestStyle" ) ), tonumber( self:GetMetaData( "HeraldryCrestColor" ) )
			local textures = EHT.Guilds:GetHeraldryTextures( bkgCat, bkgStyle, bkgColor1, bkgColor2, crestCat, crestStyle, crestColor )
			local spacing = zo_clamp( math.max( self:GetSize() ) / 250, 3, 40 )
			local p

			if "table" == type( textures ) and 0 < #textures then
				for index, texture in ipairs( textures ) do
					p = self.Particles[index]
					p:SetTextureFile( texture.TextureFile )
					p:SetPositionOffsets( 0.25, -0.25, spacing * ( index - 1 ) )
					p:SetColorOffsets( texture.Color.R or 1, texture.Color.G or 1, texture.Color.B or 1, texture.Color.A or 1 )
					p:SetSizeOffsets( texture.ScaleX or texture.Scale or 1, texture.ScaleY or texture.Scale or 1 )
					p:SetTextureWrapping( true == texture.Wrap )
					p:SetAdditive( true == texture.Add )
					if texture.Dodge then p:SetDodge( true ) end
				end
			end

			if not isAnimated then
				self.Particles[2]:SetSampleProcessing( 1.3, 0.1 )
				self.Particles[3]:SetSampleProcessing( 1.3, 0.1 )
			end

			self:Update()
		end,

	} )

	if isAnimated then

		et.Update = function( self )
			local i, i2 = GetEasedInterval( self.Interval1, self.IntervalRandom ), GetEasedInterval( self.Interval2, -0.25 * self.Interval1 + self.IntervalRandom )
			local tcY = 1.03 + 0.03 * i
			local ps = self.Particles
			local p

			for index = 1, 3 do
				p = ps[index].Texture
				p:SetVertexUV( 4, 0, tcY )
				p:SetVertexUV( 8, 1, tcY )
			end

			ps[2]:SetSampleProcessing( 0.8 + 0.5 * i2, 0.05 + 0.05 * i2 )
			ps[3]:SetSampleProcessing( 1 + 0.3 * i2, 0.05 + 0.05 * i2 )
		end

	end

	return et

end

AddGuildHeraldryEffect( 647, "Guild Heraldry, Banner, Animated", true )
AddCappedHorizontallyTiledEffect( 648, CAT.BUILD, "Wall, Altmer", 0.6, 0.58, 0.5, 1, 299, TEXTURES.WALL_ALTMER_BOTTOM, 300, TEXTURES.WALL_ALTMER_CENTER, 462, TEXTURES.WALL_ALTMER_TOP, 73 )

-- 5/29/2019
EHT.EffectType:SetDefaultDateAdded( 1559182626 )

AddGuildHeraldryEffect( 649, "Guild Heraldry, Banner", false )

-- 5/30/2019
EHT.EffectType:SetDefaultDateAdded( 1559230821 )

do
	local Spheres = {
		[AUDIO_SETTING_AMBIENT_VOLUME] = { },
		[AUDIO_SETTING_VO_VOLUME] = { },
		[AUDIO_SETTING_SFX_VOLUME] = { },
		[AUDIO_SETTING_FOOTSTEPS_VOLUME] = { },
		[AUDIO_SETTING_UI_VOLUME] = { },
		[AUDIO_SETTING_MUSIC_VOLUME] = { },
		[AUDIO_SETTING_AUDIO_VOLUME] = { },
	}

	local Volumes = {
		[AUDIO_SETTING_AMBIENT_VOLUME] = 1,
		[AUDIO_SETTING_VO_VOLUME] = 1,
		[AUDIO_SETTING_SFX_VOLUME] = 1,
		[AUDIO_SETTING_FOOTSTEPS_VOLUME] = 1,
		[AUDIO_SETTING_UI_VOLUME] = 1,
		[AUDIO_SETTING_MUSIC_VOLUME] = 1,
		[AUDIO_SETTING_AUDIO_VOLUME] = 1,
	}

	local function GetRequestedVolume(sphere)
		local distance = sphere:GetPlayerDistance()
		if distance > sphere.RadiusBuffer then
			return 1
		elseif distance > sphere.Radius then
			return 1 - (1 - ((distance - sphere.Radius) / (sphere.RadiusBuffer - sphere.Radius)) ^ 1.5)
		else
			return 0
		end
	end

	local function ApplySilence()
		local count = 0

		for volume in pairs( Volumes ) do
			Volumes[ volume ] = 1
		end

		for volume, spheres in pairs( Spheres ) do
			local minVolume = 1
			for sphere in pairs(spheres) do
				local value = GetRequestedVolume(sphere)
				minVolume = math.min(minVolume, value)
				count = count + 1
			end
			Volumes[volume] = math.sqrt(minVolume)
		end

		local originalValue

		for volume, value in pairs( Volumes ) do
			if 1 > value then
				originalValue = EHT.Util.GetPreservedSetting( SETTING_TYPE_AUDIO, volume ) or EHT.Util.GetCurrentSetting( SETTING_TYPE_AUDIO, volume ) or 0.5
				value = value * originalValue
				EHT.Util.ModifySetting( SETTING_TYPE_AUDIO, volume, value )
			else
				EHT.Util.RestoreSetting( SETTING_TYPE_AUDIO, volume )
			end
		end

		if 0 == count then
			EVENT_MANAGER:UnregisterForUpdate( "EHT.ApplySilence" )
		end
	end

	local function AddSphereOfSilence( id, effectName, settingId )
		return EHT.EffectType:New( id, effectName, {
			AutoPreview = false,
			Category = CAT.SOUND,
			CanPitch = false,
			ResetOnScale = true,
			ResetOnPosition = true,
			ResetOnOrient = false,

			Init = function( self )
				self:SetAutoColorEnabled( false )
				self:SetAutoDrawLevelEnabled( false )
				self:SetColor( 0.5, 0.5, 0.5, 1 )

				local p = self:AddParticle( TEXTURES.SPHERE,		0, 0, 0,	0, 0, 0,	0, 0, 0, 0.7,		1, 1,		false, false, false )
				p:SetHidden( true )
				p:SetCameraFacing( true )

				self:SetSize( 1000, 1000, 1000 )
				self:SpawnAtPlayer( 0 )

				local size = math.max(self:GetSize())
				self.Radius = 0.5 * size
				self.RadiusBuffer = self.Radius + zo_clamp(0.5 * self.Radius, 350, 1000)
				Spheres[ settingId ][ self ] = true

				EVENT_MANAGER:RegisterForUpdate( "EHT.ApplySilence", 100, ApplySilence )
			end,

			Update = function( self )
				local p = self.Particles[1]

				if self ~= CurrentEditorEffect or EHT.Housing.IsHUDMode() then
					p:SetHidden( true )
				else
					p:FaceCamera()
					p:SetColor(0, 0, 0, 0.5 + GetRequestedVolume(self))
					p:SetHidden( false )
				end
			end,

			Reset = function( self )
				local sx, sy, sz = self:GetSize()
				local size
				if sx ~= self.Radius then
					size = sx
				else
					size = sz
				end
				self.Radius = 0.5 * size
				self.RadiusBuffer = self.Radius + zo_clamp(0.5 * self.Radius, 350, 1000)
				self:SetSize(size, size, size)
				self:Update()
			end,

			Destroy = function( self )
				Spheres[ settingId ][ self ] = nil
			end,
		} )
	end

	AddSphereOfSilence( 650, "Sphere of Silence, Ambient", AUDIO_SETTING_AMBIENT_VOLUME )
	AddSphereOfSilence( 651, "Sphere of Silence, Dialogue", AUDIO_SETTING_VO_VOLUME )
	AddSphereOfSilence( 652, "Sphere of Silence, Effects", AUDIO_SETTING_SFX_VOLUME )
	AddSphereOfSilence( 653, "Sphere of Silence, Footsteps", AUDIO_SETTING_FOOTSTEPS_VOLUME )
	AddSphereOfSilence( 654, "Sphere of Silence, Interface", AUDIO_SETTING_UI_VOLUME )
	AddSphereOfSilence( 655, "Sphere of Silence, Music", AUDIO_SETTING_MUSIC_VOLUME )
	AddSphereOfSilence( 656, "Sphere of Silence, Nothingness", AUDIO_SETTING_AUDIO_VOLUME )
end

-- 6/2/2019
EHT.EffectType:SetDefaultDateAdded( 1559518237 )

AddMultilayeredEffect( 657, CAT.DECO, "Leaf, Maple", TEXTURES.LEAF_MAPLE,	 252, 276,	1, 1, 1, 1,	{
	{ X1 = 0, X2 = 1, Y1 = 0, Y2 = 1, R = 1, G = 1, B = 1, A = 1, Colored = true },
} )

-- 6/8/2019
EHT.EffectType:SetDefaultDateAdded( 1560031927 )

do
	local index = 658
	AddPaintingEffect( true, index, "The Scab", "esoui/art/loadingscreens/loadscreen_thescab_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Load Screen 11", "esoui/art/loadingscreens/charload_11.dds")  index = index + 1
	AddPaintingEffect( true, index, "Blackrose Prison", "esoui/art/loadingscreens/loadscreen_blackrose_prison_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Boat Cove", "esoui/art/loadingscreens/loadscreen_boatcove_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Load Screen 8", "esoui/art/loadingscreens/charload_08.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_blackrose_prison_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, "Nocturnal's Faithful", "esoui/art/loadingscreens/loadscreen_nocturnalsfaithful_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Depths of Malatar", "esoui/art/loadingscreens/loadscreen_depthsofmalatar_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Load Screen 6", "esoui/art/loadingscreens/charload_06.dds")  index = index + 1
	AddPaintingEffect( true, index, "Rimmen Necropolis", "esoui/art/loadingscreens/loadscreen_rimmen_necropolis_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Orc Rest", "esoui/art/loadingscreens/loadscreen_orcrest_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Predator Rise", "esoui/art/loadingscreens/loadscreen_predator_rise_01.dds")  index = index + 1
	AddPaintingEffect( false, index, "Artaeum's Old Vault", "esoui/art/loadingscreens/loadscreen_artaeumoldvault_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_tempest_island_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_city_of_ash_veteran_02.dds")  index = index + 1
	AddPaintingEffect( true, index, "Illumination Academy", "esoui/art/loadingscreens/loadscreen_illuminationacademystacks_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_dailysacrament2_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Murkmire Manor", "esoui/art/loadingscreens/loadscreen_murkmiremanor_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Dragonguard Outpost", "esoui/art/loadingscreens/loadscreen_dragonguard_outpost_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Daily Sacrament", "esoui/art/loadingscreens/loadscreen_dailysacrament1_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Cloudrest", "esoui/art/loadingscreens/loadscreen_cloudrest_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Tsofeer Cavern", "esoui/art/loadingscreens/loadscreen_tsofeer_cavern_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Scalecaller", "esoui/art/loadingscreens/loadscreen_scalecaller_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_banishedcell_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_twistgutarena_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Rimmen Castle Interior", "esoui/art/loadingscreens/loadscreen_rimmencastle_interior_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Load Screen 9", "esoui/art/loadingscreens/charload_09.dds")  index = index + 1
	AddPaintingEffect( true, index, "Princely Dawnlight Palace", "esoui/art/loadingscreens/loadscreen_princelydawnlightpalace_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Ceremonial Chamber", "esoui/art/loadingscreens/loadscreen_ceremonial_chamber_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_cloudrest_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_volenfell_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Moonhunter Keep", "esoui/art/loadingscreens/loadscreen_moonhunterkeep_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_crypt_of_hearts_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_maw_of_lorkaj_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Summerset Inn", "esoui/art/loadingscreens/loadscreen_summersetinn_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Morkhazgur", "esoui/art/loadingscreens/loadscreen_battleground_morkhazgur_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Deeping Drome", "esoui/art/loadingscreens/loadscreen_battleground_deepingdrome_01.dds")  index = index + 1
	AddPaintingEffect( false, index, "Russafeld", "esoui/art/loadingscreens/loadscreen_russafeld_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Sunken Xanmeer", "esoui/art/loadingscreens/loadscreen_sunken_xanmeer_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_bloodrootforge_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Rellenfeld Sinkhole", "esoui/art/loadingscreens/loadscreen_rellenfeldsinkhole_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Jode's Embrace", "esoui/art/loadingscreens/loadscreen_jodesembraceade_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "King's Haven Pass", "esoui/art/loadingscreens/loadscreen_kingshavenpass_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_arx_corinium_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_veteran_crypt_of_hearts_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_whitegoldtower_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_wrathstone_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Fanglair", "esoui/art/loadingscreens/loadscreen_fanglair_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Whitegold Tower Throne Room", "esoui/art/loadingscreens/loadscreen_wgt_throneroom_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_crypt_of_hearts_veteran_02.dds")  index = index + 1
	AddPaintingEffect( true, index, "Sunless Hollow", "esoui/art/loadingscreens/loadscreen_sunlesshollow_ep_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Mine, 2", "esoui/art/loadingscreens/loadscreen_mine_02.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_dragonfirecathedral_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Eld Angavar", "esoui/art/loadingscreens/loadscreen_battleground_eld_angavar_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_sugarslingersden_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Artaeum", "esoui/art/loadingscreens/loadscreen_artaeum_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_marchofsacrifices_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, "Alinor Royal Palace", "esoui/art/loadingscreens/loadscreen_alinorroyalpalace_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Shimmerene Aqueduct", "esoui/art/loadingscreens/loadscreen_shimmereneaqueduct_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Summerset", "esoui/art/loadingscreens/loadscreen_summerset_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Mine, 1", "esoui/art/loadingscreens/loadscreen_mine_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Mine, 3", "esoui/art/loadingscreens/loadscreen_mine_03.dds")  index = index + 1
	AddPaintingEffect( true, index, "Sunhold", "esoui/art/loadingscreens/loadscreen_sunhold_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Load Screen 4", "esoui/art/loadingscreens/charload_04.dds")  index = index + 1
	AddPaintingEffect( true, index, "Elinhir Arena", "esoui/art/loadingscreens/loadscreen_elinhirarena_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Etonnir", "esoui/art/loadingscreens/loadscreen_etonnir_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Load Screen 2", "esoui/art/loadingscreens/charload_02.dds")  index = index + 1
	AddPaintingEffect( true, index, "Frostvault", "esoui/art/loadingscreens/loadscreen_frostvault_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Crystal Tower", "esoui/art/loadingscreens/loadscreen_thecrystaltower_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Outlaw Refuge, Rimmen", "esoui/art/loadingscreens/loadscreen_outlaw_refuge_rimmen_01.dds")  index = index + 1
	AddPaintingEffect( false, index, "Traitor's Vault", "esoui/art/loadingscreens/loadscreen_traitorsvault_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Two Moon's Reflection", "esoui/art/loadingscreens/loadscreen_twomoons_reflection_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Riverhold", "esoui/art/loadingscreens/loadscreen_riverhold_instance_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Snowglobe", "esoui/art/loadingscreens/loadscreen_snowglobe_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Corgrad Wastes", "esoui/art/loadingscreens/loadscreen_corgradwastes_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_vaults_of_madness_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_mazzatun_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_sunspire_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Khasdas Keep", "esoui/art/loadingscreens/loadscreen_khasdas_keep_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Deeproot", "esoui/art/loadingscreens/loadscreen_deeproot_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_city_of_ash_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Murkmire", "esoui/art/loadingscreens/loadscreen_murkmire_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_splittusksden_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Elsweyr Cave", "esoui/art/loadingscreens/loadscreen_elsweyr_cave_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_spiderdaedra_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_depthsofmalatar_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Hakoshae Crypts", "esoui/art/loadingscreens/loadscreen_hakoshae_crypts_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_moonhunterkeep_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "The Tangle", "esoui/art/loadingscreens/loadscreen_thetangle_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Load Screen 7", "esoui/art/loadingscreens/charload_07.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_clockworkcityvaults_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Xalvakka Temple", "esoui/art/loadingscreens/loadscreen_xalvakkatemple_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_imperialcity_prison_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_scalecaller_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_evergloam_02.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_fungal_grotto_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Blighted Bog Caverns", "esoui/art/loadingscreens/loadscreen_blightedbog_caverns_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Load Screen 5", "esoui/art/loadingscreens/charload_05.dds")  index = index + 1
	AddPaintingEffect( true, index, "Halls of Khunzarri", "esoui/art/loadingscreens/loadscreen_hallsofkhunzarri_01.dds")  index = index + 1
	AddPaintingEffect( false, index, "Fear Frost Depths", "esoui/art/loadingscreens/loadscreen_fearfrostdepths_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Load Screen 10", "esoui/art/loadingscreens/charload_10.dds")  index = index + 1
	AddPaintingEffect( true, index, "Wrathstone", "esoui/art/loadingscreens/loadscreen_wrathstone_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Deepmire Cavern", "esoui/art/loadingscreens/loadscreen_deepmire_cavern_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Halls of Colossus", "esoui/art/loadingscreens/loadscreen_hallsofcolossus_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Kandar Watch", "esoui/art/loadingscreens/loadscreen_kandarwatch_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Sunspire", "esoui/art/loadingscreens/loadscreen_sunspire_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Ebonstadmont", "esoui/art/loadingscreens/loadscreen_ebonstadmont_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_helracitadel_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Artaeum Manor", "esoui/art/loadingscreens/loadscreen_artaeummanor_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Swallowed Grove", "esoui/art/loadingscreens/loadscreen_swallowed_grove_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Teeth of Sithis", "esoui/art/loadingscreens/loadscreen_teethofsithis_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "March of Sacrifices", "esoui/art/loadingscreens/loadscreen_marchofsacrifices_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Spiral Skein", "esoui/art/loadingscreens/loadscreen_thespiralskein_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_wayrestsewers_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_dailysacrament3_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_hallsoffabrication_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Istirus Outpost", "esoui/art/loadingscreens/loadscreen_battleground_istirusoutpost_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_selenes_web_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Outlaw Refuge, Lilmoth", "esoui/art/loadingscreens/loadscreen_outlaw_refuge_lilmoth_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_dragonstararena_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_cradleofshadows_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_asylumsanctorium_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Minscape", "esoui/art/loadingscreens/loadscreen_mindscape_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/charload_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Elsweyr Zone", "esoui/art/loadingscreens/loadscreen_elsweyr_zone_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Ceytarn Keep Cave", "esoui/art/loadingscreens/loadscreen_ceytarnkeepcave_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_kingandqueenstavern_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Wasten Coraldale", "esoui/art/loadingscreens/loadscreen_wastencoraldale_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Karnwasten", "esoui/art/loadingscreens/loadscreen_karnwasten_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Erstwhile Sanctuary", "esoui/art/loadingscreens/loadscreen_theerstwhilesanctuary_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Moon Gate", "esoui/art/loadingscreens/loadscreen_moon_gate_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_darkshade_caverns_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_veteran_city_of_ash_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_serpenttrial_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Seaside Cave", "esoui/art/loadingscreens/loadscreen_seasidecave_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Hunter's Glade", "esoui/art/loadingscreens/loadscreen_huntersglade_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_maelstromarena_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, "Torhamekhard", "esoui/art/loadingscreens/loadscreen_torhamekhard_01.dds")  index = index + 1
	AddPaintingEffect( false, index, "Sload Ruins", "esoui/art/loadingscreens/loadscreen_sloadruins_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Sunless Hollow, 2", "esoui/art/loadingscreens/loadscreen_sunlesshollow_ad_dc_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_falkreathsdemise_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Load Screen 3", "esoui/art/loadingscreens/charload_03.dds")  index = index + 1
	AddPaintingEffect( true, index, "Alinor Townhome", "esoui/art/loadingscreens/loadscreen_alinortownhome_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Level 3", "esoui/art/loadingscreens/loadscreen_level3_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "The Remnant of Argon", "esoui/art/loadingscreens/loadscreen_theremnantofargon_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Quarnirnion Enchantry", "esoui/art/loadingscreens/loadscreen_quarnirnionenchantry_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_blackheart_haven_veteran_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_fanglair_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Dreaming Cave", "esoui/art/loadingscreens/loadscreen_dreamingcave_mephala_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Shimmerene Monastery", "esoui/art/loadingscreens/loadscreen_shimmerenemonastery_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Ceytarn Keep Grounds", "esoui/art/loadingscreens/loadscreen_ceytarnkeepgrounds_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_toestinkruins_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Seakeep", "esoui/art/loadingscreens/loadscreen_seakeep_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Outlaw Refuge, Alinor", "esoui/art/loadingscreens/loadscreen_alinoroutlawrefuge_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Elsweyr Tutorial", "esoui/art/loadingscreens/loadscreen_elsweyr_tutorial_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Norg Tzel", "esoui/art/loadingscreens/loadscreen_norg_tzel_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_aetherianarchive_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Archon's Grove", "esoui/art/loadingscreens/loadscreen_archonsgrove_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_elden_hollow_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Elsweyr Inn", "esoui/art/loadingscreens/loadscreen_elswyer_inn_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_direfrost_keep_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Elsweyr Dungeons", "esoui/art/loadingscreens/loadscreen_elsweyr_dungeons_01.dds")  index = index + 1
	AddPaintingEffect( false, index, tostring(index), "esoui/art/loadingscreens/loadscreen_blessed_crucible_veteran_01.dds")  index = index + 1
	AddPaintingEffect( true, index, "Tomb of Many Spears", "esoui/art/loadingscreens/loadscreen_tombofmanyspears_01.dds")  index = index + 1
end

-- 6/10/2019
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1560147903 )

local function AddHakoshaeLanternsEffect( id, name, lit )
	local et = EHT.EffectType:New( id, name, {
		Category = CAT.LIGHT,
		OrderDrawLevelByIndex = true,

		Init = function( self )
			self.Interval, self.IntervalOffset = 3200 + math.random( 1, 600 ), math.random( 1, 3400 )
			self.SpotlightRGB, self.SpotlightAlpha, self.MaxGlow, self.RangeGlow = 1, 0, 1.5, 1
			self:SetAutoColorEnabled( false )
			self:SetAutoSizeEnabled( false )

			local p

			if lit then
				p = self:AddParticle( TEXTURES.LANTERNS_1_A,	 0, -0.5, 0,		0.5 * math.pi, 0, 0,	1, 1, 1, 1,		1, 1,	true, true, false )
				p:SetTextureCoords( 0, 1, 0, 0.5 )
				self.LightIndex, self.LanternStartIndex, self.LanternEndIndex = 1, 2, 9
			else
				self.LightIndex, self.LanternStartIndex, self.LanternEndIndex = nil, 1, 8
			end

			for index = 1, 4 do
				p = self:AddParticle( TEXTURES.LANTERNS_1,	 0, 0, 0,		0, 0, 0,	1, 1, 1, 0,		1, 1,	true, false, false )
				p:SetTextureCoords( 0, 1, ( ( index - 1 ) * 253 ) / 1024, ( index * 253 ) / 1024 )
			end

			local cIndex = #self.Particles

			for index = 1, 4 do
				self:CloneParticle( self.Particles[cIndex] )
				cIndex = cIndex - 1
			end

			if lit then
				p = self:AddParticle( TEXTURES.LANTERNS_1_A,	 0, 0, 0,		0, 0, 0,	1, 1, 1, 0.5,	1, 1,	true, true, false )
				p:SetTextureCoords( 0, 1, 0.5, 1 )
			end

			self:SetSize( 1024, 512, 512 )
			self:SetColor( 1, 1, 1, 1 )
			self:SpawnAtPlayer( 256 )
		end,

		Update = function( self )
			local lIndex, numP = 1, 8
			local interval

			for index = self.LanternStartIndex, self.LanternEndIndex do
				interval = GetLoopInterval( self.Interval, self.IntervalOffset + ( ( lIndex / numP ) * self.Interval ) )
				self.Particles[index]:SetAlpha( -0.75 + 1.5 * interval )
				lIndex = lIndex + 1
			end

			if self.LightIndex then
				self.Particles[1]:SetSampleProcessing( self.SpotlightRGB * ( 1.5 - 0.5 * interval ), self.SpotlightAlpha * ( 1.2 - 0.8 * interval ) )
				self.Particles[#self.Particles]:SetSampleProcessing( self.MaxGlow - self.RangeGlow * interval, 0 )
			end
		end,

		Reset = function( self )
			local sx, sy, sz = self:GetSize()
			local height = ( (253/1024) * sx )
			local p

			sy = math.max( sy, height * 1.1 )
			sz = sy

			self:SetSize( sx, sy, sz )

			local r, g, b, a = self:GetColor()
			r, g, b = 0.8 + 0.2 * r, 0.8 + 0.2 * g, 0.8 + 0.2 * b

			for index = 1, #self.Particles do
				self.Particles[index]:SetColor( r, g, b, a )
			end

			for index = self.LanternStartIndex, #self.Particles do
				p = self.Particles[index]
				p:SetSize( sx, height )
				p:SetPositionOffsets( 0, 0.5 - ( 0.25 * ( height / sy ) ), 0 )
			end

			local distanceRatio = zo_clamp( sy / ( 1.1 * height ), 1, 2 )

			if self.LightIndex then
				p = self.Particles[self.LightIndex]
				p:SetSize( ( 1 + ( distanceRatio - 1 ) * 0.5 ) * sx, distanceRatio * height )
				p:SetPositionOffsets( 0, -0.5, 0 )

				self.SpotlightRGB, self.SpotlightAlpha = 1.5 - 0.5 * distanceRatio, 0.5 - zo_clamp( distanceRatio, 0, 0.5 )
				p:SetSampleProcessing( self.SpotlightRGB, self.SpotlightAlpha )
			end

			self:Update()
		end,
	} )
	return et
end

AddHakoshaeLanternsEffect( 822, "Lanterns, Hakoshae", false )
AddHakoshaeLanternsEffect( 823, "Lanterns, Hakoshae (Lit)", true )

AddCroppedEffect( 824, CAT.LAND, "Ivy, Dragon's Breath", TEXTURES.IVY_2, 955, 1045, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, 1, 0.2, 0.11, 1 )

-- 6/15/2019
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1560539007 )

local AddFadeToEffect = function( category, id, effectName, cR, cG, cB, textureFile )
	return EHT.EffectType:New( id, effectName, {
		AutoPreview = false,
		Category = category or CAT.LIGHT,
		CanPitch = false,
		ResetOnColor = true,
		ResetOnScale = true,
		ResetOnPosition = true,
		ResetOnOrient = false,

		Init = function( self )
			self:SetAutoDrawLevelEnabled( false )

			local p
			textureFile = textureFile or TEXTURES.SOLID

			p = self:AddParticle( TEXTURES.SPHERE,		0, 0, 0,	0, 0, 0,		1, 1, 1, 0,		1, 1,		false, false, false )
			p:SetHidden( true )

			p = self:AddParticle( textureFile,			0, 0, 0,	0, 0, 0,		1, 1, 1, 0,		1, 1,		false, false, false )
			p:SetHidden( true )

			self:SetColor( cR, cG, cB, 1 )
			self:SetSize( 1000, 1000, 1000 )
			self:SpawnAtPlayer( 0 )
		end,

		Update = function( self )
			local p, p2 = self.Particles[1], self.Particles[2]
			local maxPerimeter = math.min( self.Radius, 300 )
			local perimeterDistance = zo_clamp( self.Radius - self:GetPlayerDistance(), 0, maxPerimeter ) / maxPerimeter
			local alpha = 2 * self:GetAlpha() * perimeterDistance

			p2:SetAlpha( alpha )

			if self ~= CurrentEditorEffect or EHT.Housing.IsHUDMode() then
				p:SetHidden( true )
			else
				p:FaceCamera()
				if 0 < alpha then
					p:SetColor( 0, 1, 1, 0.8 )
				else
					p:SetColor( 1, 1, 1, 0.5 )
				end
				p:SetHidden( false )
			end
		end,

		Reset = function( self )
			local r = self:GetSize()
			self.Radius = 0.5 * r
			self:SetSize( r, r, r )
			self:Update()
			self.Particles[2]:SetHidden( true )

			zo_callLater( function()
				if not self.Active or self.Deleted then
					return
				end

				local p = self.Particles[2].Texture
				p:Destroy3DRenderSpace()
				p:ClearAnchors()
				p:SetAnchorFill( GuiRoot )
				p:SetDrawLevel( 210000 )
				p:SetHidden( false )
			end, 1000 )
		end,
	} )
end

AddFadeToEffect( CAT.LIGHT, 825, "Fade To Black", 0, 0, 0 )
AddFadeToEffect( CAT.LIGHT, 826, "Fade To White", 1, 1, 1 )

AddSkyEffect(
	827, "Stars, 2",
	-- Options
	{ },
	-- Side Textures Table
	{
		{
			Texture = TEXTURES.SKY_STARS_5,
			Stretch = true, Wrap = true, SampleRGB = 1, SampleAlpha = 0,
			R = 1, G = 1, B = 1, A = 1,
			X1 = 0, X2 = 2, Y1 = 0, Y2 = 1,
			MaxVertexAlphas = { 0.15, 0.15, 0.5, 0.5 },
		},
		{
			Texture = TEXTURES.BLACK, Stretch = true, R = 0, G = 0, B = 0, A = 1, 
		},
	},
	-- Top Texture Filename
	TEXTURES.SKY_STARS_5_C,
	-- Reset Handler
	nil,
	-- Update Handler
	nil
)

do
	local numP, scaleX, scaleY = 3, 4, 4

	EHT.EffectType:New( 828, "Fish, School of Damselfish", {
		Category = CAT.PET,
		CanPitch = true,
		OrderDrawLevelByIndex = true,
		Init = function( self )
			local ft = FrameTime
			local p, oR, oX, oY, x, y

			self.RangeOffsetX, self.MinOffsetX, self.MaxOffsetX = 1 + 2 * scaleX, -scaleX, scaleX
			self.RangeOffsetY, self.MinOffsetY, self.MaxOffsetY = 1 + 2 * scaleY, -scaleY, scaleY

			for index = 1, numP do
				for layer = 1, 2 do
					oR = ( 1 == index and 0.2 or 2 == index and 0.4 or 0 )
					oX, oY = ( ( -0.8 + index ) / numP ), ( ( -0.8 + index + oR ) / numP )
					p = self:AddParticle( 1 == layer and TEXTURES.FISH_3 or TEXTURES.FISH_3_A,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
					p:SetSampleProcessing( 1 == layer and 0.8 or 2 )
					p.tX, p.tY, p.dX, p.sX = oX, oY, ( 0 == index % 2 ) and ( index / 100 ) or -( index / 100 ), ft + index * 500

					x = self.MinOffsetX + p.tX * self.RangeOffsetX
					p.tY = self.MinOffsetY + p.tY * self.RangeOffsetY
					p:SetTextureCoords( self.MinOffsetX + x, self.MaxOffsetX + x, self.MinOffsetY + p.tY, self.MaxOffsetY + p.tY )
				end
			end

			self:SetSize( 300, 150, 150 )
			self:SetColor( 0.08, 0.55, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 150 )
		end,

		Update = function( self )
			local ft = FrameTime
			local r, g, b, a = self:GetColor()
			local cInterval, p, x, y
			local pIndex = 1

			for index = 1, numP do
				p = self.Particles[pIndex]
				pIndex = pIndex + 1

				if ft > p.sX then
					p.sX = ft + 2000 + 4000 * math.random()
					local sign = 0 < p.dX and -1 or 1
					p.dX = sign * 0.01 * ( 1 + ( 10 * math.random() ) )
					pIndex = pIndex + 1
				else
					cInterval = 0.05 * index * math.abs( GetEasedInterval( 1000 + 250 * index, index * 250 ) )
					p.tX = zo_clamp( p.tX + p.dX, self.MinOffsetX + 1, self.MaxOffsetX - 1 )
					y = 0.25 * cInterval + p.tY
					local x1, x2, y1, y2

					if 0 < p.dX then
						x1, x2, y1, y2 = self.MinOffsetX + p.tX, 1 + self.MaxOffsetX + p.tX + cInterval, self.MinOffsetY + y, self.MaxOffsetY + y
						p:SetTextureCoords( x1, x2, y1, y2 )
					else
						x1, x2, y1, y2 = 1 + self.MaxOffsetX - p.tX + cInterval, self.MinOffsetX - p.tX, self.MinOffsetY + y, self.MaxOffsetY + y
						p:SetTextureCoords( x1, x2, y1, y2 )
					end

					p = self.Particles[pIndex]
					p:SetTextureCoords( x1, x2, y1, y2 )
					p:SetSampleProcessing( 2 + cInterval, 0 )
					pIndex = pIndex + 1
				end
			end
		end,

		Reset = function( self )
			self:Update()
		end,
	} )
end

local function AddAetherEffect( id, name,	np, pitch, speedFactor, density, luminosity,	maskTexture, repeatMaskTexture,		alpha1, alpha2, alpha4, alpha8 )
	EHT.EffectType:New( id, name, {
		Category = CAT.ANIM, CanPitch = true, ResetOnColor = true, ResetOnOrient = true, ResetOnPosition = true, ResetOnScale = true,

		Init = function( self )
			self:SetAutoColorEnabled( false )
			self.DynamicDensity = 0 == density
			self.Density = density
			self.AnimInterval, self.CycleInterval = (1/speedFactor) * 120000, 6000
			self.IntervalOffset = math.random( math.max( self.AnimInterval, self.CycleInterval ) )
			self.RatioX, self.RatioY = 1, 1
			self.Luminosity = luminosity or 1
			self.Alpha1, self.Alpha2, self.Alpha4, self.Alpha8 = alpha1 or 1, alpha2 or 1, alpha4 or 1, alpha8 or 1
			self.MaskStartIndex, self.MaskEndIndex = 0, 0
			self.NumP = np or 6

			local numP = self.NumP
			local minZ, maxZ = -density * numP, density * numP
			local dodge = nil ~= maskTexture
			local p

			if maskTexture then
				if repeatMaskTexture then
					for index = 1, numP do
						self:AddParticle( maskTexture,		0, 0, zo_lerp( minZ, maxZ, ( index - 0.5 ) / numP ),	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
					end

					self.MaskStartIndex, self.MaskEndIndex = 1, numP
				else
					self:AddParticle( maskTexture,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
					self.MaskStartIndex, self.MaskEndIndex = 1, 1
				end

				self.IndexOffset = self.MaskEndIndex
			else
				self.IndexOffset = 0
			end

			for index = 1, numP do
				p = self:AddParticle( TEXTURES.NOISE_1,		0, 0, zo_lerp( minZ, maxZ, ( index - 0.5 ) / numP ),	0, 0, 0,	1, 1, 1, 0,		1, 1,	true, false, true )
				p:SetSampleProcessing( 4 + ( index / numP ), 0 )
				if dodge then p:SetDodge( true ) end
			end

			self:SetSize( 1000, 1000, 1000 )
			self:SetColor( 0, 0.8, 1, 1 )
			self:SetOrientation( pitch, 0, 0 )
			self:SpawnAtPlayer( ( not pitch or 0 == pitch ) and 500 or 20 )
		end,

		Update = function( self )
			local a = GetLinearInterval( self.AnimInterval, self.IntervalOffset )
			local c = GetLinearInterval( self.CycleInterval, self.IntervalOffset )
			local rx, ry = self.RatioX or 1, self.RatioY or 1
			local indexOffset = self.IndexOffset
			local r, g, b = self:GetColor()
			local lum = self.Luminosity
			local ps = self.Particles
			local numP = self.NumP
			local cc = 2 * math.abs( 1 - ( 2 * c ) )
			local c1, c2, c3, c4, inumP, m, p, pr, pg, pb
			local a360 = a * RAD360
			local c360 = math.cos( c * RAD360 )
			local s360 = math.sin( c * RAD360 )
			local a1, a2, a4, a8 = self.Alpha1, self.Alpha2, self.Alpha4, self.Alpha8

			if self.DynamicDensity then
				local distance = self:GetPlayerDistance()
				local currentD = self.Density
				local targetD = zo_clamp( math.floor( distance / 2000 ), 0, 10 )

				if 1 < math.abs( currentD - targetD ) then
					self.Density = targetD

					local minZ, maxZ = -targetD * numP, targetD * numP
					for index = 1, #ps do
						ps[index]:SetPositionOffsets( 0, 0, zo_lerp( minZ, maxZ, ( index - 0.5 ) / numP ) )
					end

					self:Update()
				end
			end

			for index = 1, numP do
				p = ps[ indexOffset + index ]
				m = index % 2

				inumP = 1 + ( index / numP )
				cc = inumP * RAD180
				c1 = 0.6 * inumP * math.sin( a360 + cc )
				c2 = 0.6 * inumP * math.cos( a360 + cc )
				p:SetTextureCoords( c1, rx + c1, c2, ry + c2 )

				p = p.Texture
				c1 = index * ( 0 == m and s360 or 1 - s360 )
				c2 = -c1
				c3 = index * ( 3 < index and c360 or 1 - c360 )
				c4 = -c3

				p:SetVertexColors( 1, r, g, b, ( 0.07 - 0.01 * c1 ) * a1 )
				p:SetVertexColors( 2, r, g, b, ( 0.07 - 0.01 * c2 ) * a2 )
				p:SetVertexColors( 8, r, g, b, ( 0.07 - 0.01 * c3 ) * a8 )
				p:SetVertexColors( 4, r, g, b, ( 0.07 - 0.01 * c4 ) * a4 )
			end

			local maskStart, maskEnd = self.MaskStartIndex, self.MaskEndIndex

			if 1 < maskEnd then
				local distance, c, sx, sy --, x, y, z
				sx, sy = ps[1]:GetSize()
				local maxDim = math.max( 0.5 * sx, 0.5 * sy )
				local viewing = math.abs( ps[1]:GetCameraNormal() )
				viewing = 0.75 < viewing and 1 or ( 1.333 * viewing )

				for index = maskStart, maskEnd do
					p = ps[ index ]
					
					distance = p:GetCameraDistance() - maxDim
					c = viewing * zo_clamp( distance / 200, 0, 1 )
					p = p.Texture

					p:SetVertexColors( 1, r, g, b, c * self.Alpha1 )
					p:SetVertexColors( 2, r, g, b, c * self.Alpha2 )
					p:SetVertexColors( 8, r, g, b, c * self.Alpha8 )
					p:SetVertexColors( 4, r, g, b, c * self.Alpha4 )
				end
			end
		end,

		Reset = function( self )
			self:Update()

			if 0 < self.MaskStartIndex then
				local r, g, b = self:GetColor()
				for index = self.MaskStartIndex, self.MaskEndIndex do
					local p = self.Particles[index]
					if p then
						p = p.Texture
						if p then
							p:SetVertexColors(1, r, g, b, self.Alpha1)
							p:SetVertexColors(2, r, g, b, self.Alpha2)
							p:SetVertexColors(4, r, g, b, self.Alpha4)
							p:SetVertexColors(8, r, g, b, self.Alpha8)
						end
					end
				end
			end

			local sx, sy, sz = self:GetSize()
			if sx then
				self.RatioX = zo_clamp( sx / 1000, 1, 2 )
				self.RatioY = ( sz / sx ) * self.RatioX
			end
		end,
	} )
end

-- 6/28/2019
EHT.EffectType:SetDefaultDateAdded( 1561728545 )

AddAetherEffect( 829, "Aether, Pool",					6,	RAD90,	1,		0,		1,		TEXTURES.CIRCLE_SOFT_3,	false )
AddAetherEffect( 830, "Aether, Pool (Turbulent)",		6,	RAD90,	4,		0,		1,		TEXTURES.CIRCLE_SOFT_3,	false )
AddAetherEffect( 831, "Aether, Barrier",				6,	0,		1,		0,		1,		TEXTURES.FIELD_1,		false,	0, 0, 1, 1 )
AddAetherEffect( 832, "Aether, Barrier (Turbulent)",	6,	0,		4,		0,		1,		TEXTURES.FIELD_1,		false,	0, 0, 1, 1 )
AddAetherEffect( 833, "Aether, Mists",					24,	0,		1,		0.04,	1,		TEXTURES.FIELD_1,		true,	0, 0, 0.4, 0.4 )
AddAetherEffect( 834, "Aether, Mists (Turbulent)",		24,	0,		4,		0.04,	1,		TEXTURES.FIELD_1,		true,	0, 0, 0.4, 0.4 )

do
	local et

	AddTile( 835, CAT.BUILD, "Tile, Gold and Marble",						TEXTURES.TILE_1,	100, 100*(1584/1600),	"Chryseia" )
	AddTile( 836, CAT.BUILD, "Parquet, Elegant",							TEXTURES.TILE_2,	100, 100,				"Chryseia" )
	AddTile( 837, CAT.BUILD, "Tile, Ceramic, Fleur de Lis",					TEXTURES.TILE_3,	100, 100,				"Chryseia" )
	AddTile( 838, CAT.BUILD, "Tile, Fish Scale",							TEXTURES.TILE_4,	100, 100*(1600/1337),	"Chryseia" )
	AddTile( 839, CAT.BUILD, "Velvet",										TEXTURES.TILE_5,	200, 200*(437/575),		"Chryseia" )
	AddTile( 840, CAT.BUILD, "Leather, Tufted",								TEXTURES.TILE_6,	200, 200,				"Chryseia" )
	AddTile( 841, CAT.BUILD, "Wood, Painted",								TEXTURES.TILE_7,	250, 250*(949/1403),	"Chryseia" )
	AddTile( 842, CAT.BUILD, "Onyx, White",									TEXTURES.TILE_8,	100, 100*(1248/992),	"Chryseia" )
	AddTile( 843, CAT.BUILD, "Plaster",										TEXTURES.TILE_9,	400, 400*(711/652),		"Chryseia" )
	AddTile( 844, CAT.BUILD, "Wood, Desaturated",							TEXTURES.TILE_10,	400, 400*(705/1095),	"Chryseia" )

	AddWallReversed( 845, CAT.BUILD, "Window Pane, Edwardian with Sigil",	TEXTURES.WINDOW_4,	200, 200*(921/477),		"Chryseia" )
	AddWallReversed( 846, CAT.BUILD, "Window Pane, Queen Anne",				TEXTURES.WINDOW_5,	100, 100,				"Chryseia" )
	AddWallReversed( 847, CAT.BUILD, "Window Pane, Diamond, Modified",		TEXTURES.WINDOW_6,	 50,  50*(416/285),		"Chryseia" )

	AddMultilayeredEffect( 848, CAT.BUILD, "Window, Traditional",			TEXTURES.WINDOW_3,	250, 250*(613/479), 1, 1, 1, 1, { { } } ).Submitter = "Chryseia"
	AddMultilayeredEffect( 849, CAT.BUILD, "Window, Gothic, Wooden",		TEXTURES.WINDOW_7,	150, 150*(993/423), 1, 1, 1, 1, { { } } ).Submitter = "Chryseia"
	AddMultilayeredEffect( 850, CAT.BUILD, "Window, Gothic, Stone",			TEXTURES.WINDOW_8,	200, 200*(993/714), 1, 1, 1, 1, { { } } ).Submitter = "Chryseia"

	AddWallReversed( 851, CAT.BUILD, "Window, Traditional (Tiled)",			TEXTURES.WINDOW_3,	250, 250*(613/479),		"Chryseia" )
	AddWallReversed( 852, CAT.BUILD, "Window, Gothic, Wooden (Tiled)",		TEXTURES.WINDOW_7,	150, 150*(993/423),		"Chryseia" )
	AddWallReversed( 853, CAT.BUILD, "Window, Gothic, Stone (Tiled)",		TEXTURES.WINDOW_8,	200, 200*(993/714),		"Chryseia" )

	AddMultilayeredEffect( 854, CAT.BUILD, "Castle, Turret",				TEXTURES.CASTLE_1,	600, 600*(684/216), 1, 1, 1, 1, { { } } ).Submitter = "StabbityDoom"

	et = AddWall( 855, CAT.BUILD, "Fabric, Quilted",						TEXTURES.QUILT_1,	200, 200, 				nil,		1, 0.95, 0.7, 1 )
	et = AddWall( 856, CAT.BUILD, "Fabric, Quilted (Matte)",				TEXTURES.QUILT_1,	200, 200, 				nil,		1, 0.95, 0.7, 1 )
	AddModifierFaded( et )
	et = AddWall( 857, CAT.BUILD, "Fabric, Quilted (Satin)",				TEXTURES.QUILT_1,	200, 200, 				nil,		1, 0.95, 0.7, 1 )
	AddModifierBright( et )

	AddMultilayeredEffect( 858, CAT.DECO, "Axe, Mounted",					TEXTURES.WEAPON_MOUNTED_1,	100*(471/790), 100, 1, 1, 1, 1, { { } } )
end

-- 7/05/2019
EHT.EffectType:SetDefaultDateAdded( 1562348820 )

AddWallReversed( 859, CAT.LAND, "Wisteria, Cluster (Tiled)", TEXTURES.WISTERIA_1_P, 250*(504/388), 250, nil, 0.45, 0, 0.7, 1, 1, TEXTURES.WISTERIA_1_C )
AddWallReversed( 860, CAT.LAND, "Wisteria, Vines (Tiled)", TEXTURES.WISTERIA_2_P, 150*(512/157), 150, nil, 0.45, 0, 0.7, 1, 1, TEXTURES.WISTERIA_2_C )
AddWallReversed( 861, CAT.LAND, "Bush, Rose (Tiled)", TEXTURES.BUSH_ROSE_1_P, 250*(506/382), 250, nil, 1, 1, 1, 1, 1 )

-- 7/08/2019
EHT.EffectType:SetDefaultDateAdded( 1562616248 )

AddSkyEffect(
	862, "Ocean of Stars",
	-- Options
	{ R = 0.1, G = 0.32, B = 1, },
	-- Side Textures Table
	{
		{
			Texture = TEXTURES.SKY_STARS_9_T,
			Stretch = true, Wrap = true, SampleRGB = 3, SampleAlpha = 0.1,
			R = 1, G = 1, B = 1, A = 1,
			X1 = 0, X2 = 2, Y1 = 0, Y2 = 2,
			MaxVertexAlphas = { 0, 0, 0.5, 0.5 },
		},
		{
			Texture = TEXTURES.SKY_STARS_9_S,
			Stretch = true, Wrap = true, SampleRGB = 1, SampleAlpha = 0, AddColor = true,
			R = 1, G = 1, B = 1, A = 1,
			X1 = 0, X2 = 2, Y1 = 0, Y2 = 2,
			MaxVertexAlphas = { 0, 0, 1, 1 },
		},
		{
			Texture = TEXTURES.BLACK,
			Stretch = true,
			R = 0, G = 0, B = 0, A = 1,
		},
	},
	-- Top Texture Filename
	TEXTURES.SOLID,
	-- Reset Handler
	function( self )
		local sx, sy, sz = self:GetSize()
		local r, g, b = self:GetColor()
		local faces

		self.OrderDrawLevelByIndex = false
		self.RotationInterval = 600000

		local screenWidth, screenHeight = GuiRoot:GetDimensions()
		local radius = 0.5 * sx
		local circ = 2 * math.pi * radius
		local y1, y2 = 0, 1
		local x1, x2 = 0, 2 -- EHT.World:GetAspectRatioWidth( screenWidth, screenHeight, circ, sy, true )

		ProjectCylinderTextureFaces( self.TextureFaces[2], radius, x1, x2, y1, y2 )
		ProjectCylinderTextureFaces( self.TextureFaces[3], radius, x1, x2, y1, y2 )

		faces = self.TextureFaces[2]
		for index, face in ipairs( faces ) do
			local x1, x2, y1, y2 = face:GetTextureCoords()
			face.oX1, face.oX2, face.oY1, face.oY2 = x1, x2, y1, y2
		end

		faces = self.TextureFaces[3]
		local numFaces = #faces
		for index, face in ipairs( faces ) do
			face:SetDesaturation( 1 )
			face:SetVertexColors( 1 + 2, 1, 1, 1, 0.02 )
			face:SetVertexColors( 4 + 8, 1, 1, 1, 0.1 )
			face.IntervalOffset1 = 5000 * ( index / numFaces )
			face.IntervalOffset2 = 8300 * ( index / numFaces )

			local x1, x2, y1, y2 = face:GetTextureCoords()
			face.oX1, face.oX2, face.oY1, face.oY2 = x1, x2, y1, y2
		end
		
		if #self.TextureFaces[1] == 1 then
			local top0 = self.TextureFaces[1][1]
			top0:SetAutoDrawLevelEnabled( false )
			top0:SetDrawLevel( 1 )
			top0:SetAutoColorEnabled( false )
			top0:SetCanModifyColor( true )
			top0:SetColor( 0, 0, 0, 1 )
			top0:SetVertexColors( 1 + 2 + 4 + 8, 0, 0, 0, 1 )

			local top1 = self:CloneParticle( top0 )
			self.TextureFaces[1][2] = top1
			--top1:SetTextureFile( TEXTURES.SKY_STARS_9_S )
			top1:SetTextureFile( TEXTURES.STARS_1 )
			top1:SetTextureWrapping( true )
			top1:SetAdditive( true )
			top1:SetAutoColorEnabled( false )
			top1:SetAutoDrawLevelEnabled( false )
			top1:SetCanModifyColor( true )
			top1:SetColor( 1, 1, 1, 1 )
			top1:SetDrawLevel( 2 )
			top1:SetDesaturation( 1 )

			local top2 = self:CloneParticle( top0 )
			self.TextureFaces[1][3] = top2
			--top2:SetTextureFile( TEXTURES.SKY_STARS_9_S )
			top2:SetTextureFile( TEXTURES.STARS_1 )
			top2:SetTextureWrapping( true )
			top2:SetAdditive( true )
			top2:SetAutoColorEnabled( false )
			top2:SetAutoDrawLevelEnabled( false )
			top2:SetCanModifyColor( true )
			top2:SetColor( 1, 1, 1, 1 )
			top2:SetDrawLevel( 3 )
			top2:SetDesaturation( 1 )
		else
			local top0 = self.TextureFaces[1][1]
			
			local top1 = self.TextureFaces[1][2]
			top1:SetPosition( top0:GetPosition() )
			top1:SetSize( top0:GetSize() )

			local top2 = self.TextureFaces[1][3]
			top2:SetPosition( top0:GetPosition() )
			top2:SetSize( top0:GetSize() )
		end
		
		for faceIndex = 4, 2, -1 do
			for _, face in ipairs( self.TextureFaces[faceIndex] ) do
				face:SetAutoDrawLevelEnabled( false )
				face:SetDrawLevel( 5 - faceIndex )
			end
		end
	end,
	-- Update Handler
	function( self )
		local rot = -GetLinearInterval( self.RotationInterval )
		local rotY = rot
		local r, g, b, a = self:GetColor()
		local faces1, faces2 = self.TextureFaces[2], self.TextureFaces[3]
		local numFaces = #faces1

		for index = 1, numFaces do
			local face1 = faces1[index]
			local face2 = faces2[index]
			local rgb = 1 + math.max( 6 * GetEasedInterval( 5000, face2.IntervalOffset1 ), 0 ) + math.max( 6 * GetEasedInterval( 8300, face2.IntervalOffset2 ), 0 )

			face1:SetTextureCoords( face1.oX1 + rot, face1.oX2 + rot, face1.oY1 + rotY, face1.oY2 + rotY )
			face1:SetSampleProcessing( 4 + 0.5 * rgb, 0.1 )
			face2:SetTextureCoords( face2.oX1 + rot, face2.oX2 + rot, face2.oY1 + rotY, face2.oY2 + rotY )
			face2:SetSampleProcessing( 4 * rgb, 0 )
		end

		local topInterval = GetLinearInterval( self.RotationInterval * 6 )
		local topWeightOffset = 0.5 * math.abs( -1 + 2 * topInterval )
		local top0 = self.TextureFaces[1][1]
		local top1 = self.TextureFaces[1][2]
		local top2 = self.TextureFaces[1][3]

		top0:SetVertexColors( 1 + 2 + 4 + 8, 0, 0, 0, a )
		top1:RotateCoords( topInterval * 2 * math.pi, 0.5, 0.6, 0.8, 0.8 )
		top1:SetSampleProcessing( 0.5 + topWeightOffset )
		top2:RotateCoords( topInterval * 2 * math.pi + 0.7 * math.pi, 0.5, 0.2, 0.86, 0.86 )
		top2.Texture:SetVertexColors( 1, 1, 1, 1, a * ( 0.5 + math.max( 0.25 * GetEasedInterval( 5000, 0 ) ) + math.max( 0.25 * GetEasedInterval( 7000, 0 ) ) ) )
		top2.Texture:SetVertexColors( 2, 1, 1, 1, a * ( 0.5 + math.max( 0.25 * GetEasedInterval( 5000, 1250 ) ) + math.max( 0.25 * GetEasedInterval( 7000, 1750 ) ) ) )
		top2.Texture:SetVertexColors( 8, 1, 1, 1, a * ( 0.5 + math.max( 0.25 * GetEasedInterval( 5000, 2500 ) ) + math.max( 0.25 * GetEasedInterval( 7000, 3500 ) ) ) )
		top2.Texture:SetVertexColors( 4, 1, 1, 1, a * ( 0.5 + math.max( 0.25 * GetEasedInterval( 5000, 3500 ) ) + math.max( 0.25 * GetEasedInterval( 7000, 5250 ) ) ) )
		top2:SetSampleProcessing( 1 - topWeightOffset )
	end
)
--[[
local function addSkyWindow( id, category, name, animInterval, widthRatio, heightRatio )
	return EHT.EffectType:New( id, name, {
		Category = category,
		CanPitch = true,
		OrderDrawLevelByIndex = true,
		ResetOnColor = true, ResetOnScale = true, ResetOnPosition = true, ResetOnOrient = false,

		Init = function( self )
			self.AnimInterval = animInterval
			self.TCx1, self.TCx2, self.TCy1, self.TCy2 = 0, 1, 0, 1
			widthRatio = widthRatio or 1
			heightRatio = heightRatio or 1

			local p

			for index = 1, 2 do
				p = self:AddParticle( TEXTURES.SKY_STARS_7_T,	0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,		true, index == 2, true )
				p:SetSampleProcessing( 1 == index and 1.8 or 1, 0 )
			end

			for index = 1, 2 do
				p = self:AddParticle( TEXTURES.SKY_STARS_7_S,	0, 0, 0,	0, 0, 0,	1, 1, 1, 0.1,	1, 1,		true, true, true )
				p:SetAutoColorEnabled( false )
				p:SetColor( 1, 1, 1, 0.1 )
				p:SetSampleProcessing( 9, 0 )
			end

			self:SetColor( 0.6, 0.7, 1, 1 )
			self:SetSize( 500, 250, 250 )
			self:SpawnAtPlayer( 200 )
		end,

		Update = function( self )
			local x1, x2, y1, y2 = self.TCx1, self.TCx2, self.TCy1, self.TCy2
			local interval = GetLinearInterval( self.AnimInterval )
			local r, g, b = self:GetColor()
			local loopInt, p, tex
			local w = self.StarWhite or 1

			p = self.Particles[1]
			p:SetTextureCoords( x1 + interval, 2 * x2 + interval, y1, 2 * y2 )
			p:SetSampleProcessing( 2 * ( 0.4 + 0.6 * GetLoopInterval( 4000 ) ) )

			p = self.Particles[2]
			p:SetTextureCoords( 0.25 + x1 + interval, 0.25 + 2 * x2 + interval, 0.4 + 2 * y2, y1 )
			p:SetSampleProcessing( 2 * ( 0.4 + 0.6 * GetLoopInterval( 4000, 2000 ) ) )

			p = self.Particles[3]
			p:SetTextureCoords( x1 + interval, x2 + interval, y1, 0.5 + y2 )
			p:SetSampleProcessing( 14 * ( 0.2 + 0.4 * GetLoopInterval( 3456 ) + 0.4 * GetLoopInterval( 8000 ) ), 0 )

			p = self.Particles[4]
			p:SetTextureCoords( x1 + interval, x2 + interval, y1, y2 )
			tex = p.Texture

			loopInt = 3000
			p:SetVertexColors( 1, w, w, w, 0.2 * GetLoopInterval( loopInt ) )
			p:SetVertexColors( 2, w, w, w, 0.2 * GetLoopInterval( loopInt, 0.5 * loopInt ) )
			p:SetVertexColors( 4, w, w, w, 0.2 * GetLoopInterval( loopInt, 0.2 * loopInt ) )
			p:SetVertexColors( 8, w, w, w, 0.2 * GetLoopInterval( loopInt, 0.8 * loopInt ) )
		end,

		Reset = function( self )
			self:Update()

			local _, yaw = self:GetOrientation()
			local sx, sy, sz = self:GetSize()
			sy = math.max( sy, sz )

			local maxWidth, maxHeight = 1000, 1000
			local x1, x2, y1, y2 = 0, sx / maxWidth, 0, sy / maxHeight
			local s = yaw / RAD360

			x1, x2 = x1 - widthRatio * -0.5 * s * x2, widthRatio * x2 + widthRatio * 0.5 * s * x2
			y1 = y1 - heightRatio * -0.5 * y2
			y2 = heightRatio * y2 + heightRatio * 0.5 * y2
			self.TCx1, self.TCx2, self.TCy1, self.TCy2 = x1, x2, y1, y2

			local r, g, b = self:GetColor()
			local w = ( r + g + b ) / 3

			self.StarWhite = w
			self.Particles[3]:SetColor( w, w, w, 0.3 ) 
		end,
	} )
end
]]
local function addSkyWindow(id, category, name, animInterval, widthRatio, heightRatio, transparent, textureFile)
	widthRatio = widthRatio or 1
	heightRatio = heightRatio or 1

	return EHT.EffectType:New(id, name, {
		Category = category,
		CanPitch = true,
		OrderDrawLevelByIndex = true,
		ResetOnColor = true, ResetOnScale = true, ResetOnPosition = true, ResetOnOrient = true,

		Init = function(self)
			self.AnimInterval = animInterval or 30000
			self.IsWarp = 1 ~= widthRatio
			self.NumParticles = self.IsWarp and 3 or 4

			do
				local p = self:AddParticle(TEXTURES.SOLID,	0, 0, 0,	0, 0, 0,	0, 0, 0, 1,		1, 1,		true, false, true)
				if transparent then
					p:SetHidden(true)
					p:SetColorOffsets(0, 0, 0, 0)
				end
			end

			local CC = self.IsWarp and 0.23 or 0.12
			for index = 1, self.NumParticles do
				local texture = textureFile or (2 >= index and TEXTURES.SKY_STARS_7_S or TEXTURES.SKY_STARS_7_T)
				local p = self:AddParticle(texture,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1 - ((index - 1) * CC),		1, 1,		true, true, true)
				p:SetSampleProcessing((self.NumParticles - index + 1) / self.NumParticles)
				p.InvertCoords = not self.IsWarp and (index % 2 == 0) or false
			end

			self:SetColor(0.5, 0.75, 1, 1)
			self:SetSize(500, 250, 250)
			self:SpawnAtPlayer(200)
			self:SetContrast(1.5)
		end,

		Update = function(self)
			local coords = self.TC
			if coords then
				local C = self.IsWarp and 0 or 0.12
				local offsetX = -0.075 * CameraForwardX
				local offsetY = -0.075 * CameraForwardY
				local interval = GetLinearInterval(self.AnimInterval)
				local numP = #self.Particles
				for index, p in ipairs(self.Particles) do
					if index > 1 then
						local index2 = index - 1
						local tc = coords[index2]
						local offsetCoeff = 1 - C * index2
						local offsetTranslate = interval * (4 - index2)
						local ox = (offsetX * offsetCoeff + offsetTranslate) % 1
						local oy = (offsetY * offsetCoeff) % 1
						if p.InvertCoords then
							ox = 1 - ox
						end
						p:SetTextureCoords(tc[1] + ox, tc[2] + ox, tc[3] + oy, tc[4] + oy)
						p:SetSampleProcessing(1 + (ox > 0.5 and (2 - 2 * ox) or (2 * ox)))
					end
				end
			end
		end,

		Reset = function(self)
			local MAX_WIDTH, MAX_HEIGHT = (1000 * (1 / widthRatio)) * (self.TextureScaleX or 1), (1000 * (1 / heightRatio)) * (self.TextureScaleY or 1)
			local _, yaw = self:GetOrientation()
			local sx, sy, sz = self:GetSize()

			local px, py, pz = self:GetPosition()
			local pxz = -px * math.cos(yaw) - pz * math.sin(yaw)

			local widthX = sx / MAX_WIDTH
			local heightY = sy / MAX_HEIGHT

			local baseX = (((pxz % MAX_WIDTH) / MAX_WIDTH) - (0.5 * widthX)) % 1
			local baseY = -((((py % MAX_HEIGHT) / MAX_HEIGHT) + (0.5 * heightY)) % 1)

			local x1, x2, y1, y2 = baseX, baseX + widthX, baseY, baseY + heightY
			
			if self.IsWarp then
				self.TC =
				{
					{ x1, x2, y1, y2 },
					{ x1 - 0.4, x2 - 0.4, y1 + 0.2, y2 + 0.2 },
					{ x1 - 0.15, x2 - 0.15, y1 + 0.5, y2 + 0.5 },
					{ x1 - 0.8, x2 - 0.8, y1 + 0.65, y2 + 0.65 },
				}
			else
				self.TC =
				{
					{ x1, x2, y1, y2 },
					{ (x2 * 2) + 0.2, (x1 * 2) + 0.2, (y1 * 2) + 0.7, (y2 * 2) + 0.7 },
					{ (x1 * 3) + 0.8, (x2 * 3) + 0.8, (y2 * 3) + 0.6, (y1 * 3) + 0.6 },
					{ (x2 * 4) + 0.55, (x1 * 4) + 0.55, (y1 * 4) + 0.78, (y2 * 4) + 0.78 },
				}
			end

			self:Update()
		end,
	})
end

addSkyWindow(863, CAT.BUILD, "Window, Night Sky", 40000000, 1)
AddMultilayeredEffect(864, CAT.BUILD, "Wall, Orcish", TEXTURES.WALL_4, 994, 1070, 1, 1, 1, 1, {{}}).Submitter = "cryhavok101"
addSkyWindow(865, CAT.ANIM, "Interstellar Space", 100000, 1)
addSkyWindow(866, CAT.ANIM, "Interstellar Space, Warp Drive", 15000, 0.025, 1, nil, TEXTURES.STARS_2)

-- 7/10/2019
EHT.EffectType:SetDefaultDateAdded( 1562782431 )

AddCroppedEffect( 867, CAT.BUILD, "Door, Clockwork", TEXTURES.DOOR_9, 600*(732/854), 600, 0, 1, 0, 1 )

AddSkyEffect(
	868, "Nebula",
	-- Options
	{ R = 1, G = 0.3, B = 1, },
	-- Side Textures Table
	{
		{
			Texture = TEXTURES.SKY_STARS_8_S,
			Stretch = true, Wrap = true, SampleRGB = 0.5, SampleAlpha = 0, AddColor = true,
			R = 1, G = 1, B = 1, A = 1,
			X1 = 0, X2 = 3, Y1 = 0, Y2 = 3,
			MaxVertexAlphas = { 0, 0, 1, 1 },
		},
		{
			Texture = TEXTURES.SKY_STARS_8,
			Stretch = true, Wrap = true, SampleRGB = 1, SampleAlpha = 0,
			R = 1, G = 1, B = 1, A = 1,
			X1 = 0, X2 = 3, Y1 = 0, Y2 = 3,
			MaxVertexAlphas = { 0, 0, 1, 1 },
		},
		{
			Texture = TEXTURES.BLACK,
			Stretch = true,
			R = 0, G = 0, B = 0, A = 1,
		},
	},
	-- Top Texture Filename
	TEXTURES.STARS_1,
	-- Reset Handler
	function( self )
		local sx, sy, sz = self:GetSize()
		local r, g, b = self:GetColor()
		local faces, faces2

		self.RotationInterval = 600000

		local p = self.Particles[1]
		p:SetAutoColorEnabled( false )
		p:SetColor( 1, 1, 1, 1 )

		local radius = 0.5 * sx
		local circ = 2 * math.pi * radius
		local y1, y2 = 0, 1
		local x1, x2 = 0, EHT.World:GetAspectRatioWidth( 1920, 1200, circ, sy, true )

 		self.MaxX, self.MaxY = x2, y2

		ProjectCylinderTextureFaces( self.TextureFaces[2], radius, x1, x2, y1, y2 )
		ProjectCylinderTextureFaces( self.TextureFaces[3], radius, x1, x2, y1, y2 )

		faces = self.TextureFaces[3]
		faces2 = self.TextureFaces[2]
		local numFaces = #faces
		local r, g, b = self:GetColor()
		r, g, b = 1 + r, 1 + g, 1 + b

		for index = 1, numFaces do
			local face, face2 = faces[index], faces2[index]
			local x1, x2, y1, y2 = face:GetTextureCoords()

			face.oX1, face.oX2, face.oY1, face.oY2 = x1, x2, y1, y2
			face2.oX1, face2.oX2, face2.oY1, face2.oY2 = x1, x2, y1, y2
			face2:SetAutoColorEnabled( false )
			face2:SetColor( 1, 1, 1, 1 )
			face2:SetVertexColors( 1 + 2, r, g, b, 0 )
			face2:SetVertexColors( 4 + 8, r, g, b, 0.8 )
		end
	end,
	-- Update Handler
	function( self )
		local rot = -GetLinearInterval( self.RotationInterval )
		local rotA = rot * 2 * math.pi
		--local rotY = rot
		--local r, g, b = self:GetColor()
		local p = self.TextureFaces[1][1]
		p:SetTextureRotation( rotA )
		p:SetSampleProcessing( 0.5 + 0.8 * GetLoopInterval( 30000 ) )

		local faces1 = self.TextureFaces[3]
		local faces2 = self.TextureFaces[2]
		local x2, y2 = self.MaxX or 1, self.MaxY or 1

		ProjectCylinderTextureFaces( faces1, 0, rot, rot + x2, rot, rot + y2 )
		ProjectCylinderTextureFaces( faces2, 0, rot, rot + x2, rot, rot + y2 )
--[[
		local numFaces = #faces
		for index = 1, numFaces do
			local face, face2 = faces[index], faces2[index]

			face:SetTextureCoords( face.oX1 + rot, face.oX2 + rot, face.oY1 + rotY, face.oY2 + rotY )
			face2:SetTextureCoords( face2.oX1 + rot, face2.oX2 + rot, face2.oY1 + rotY, face2.oY2 + rotY )
		end
]]
	end
)

EHT.EffectType:New( 869, "Tree, Apple", {
	Category = CAT.LAND,
	CanPitch = true,
	Init = function( self )
		self:AddParticle( TEXTURES.TREE_2,	0, 0, 0,	0, 0.0 * math.pi, 0,	1, 1, 1, 1,			1, 1,	true, false, false )
		self:AddParticle( TEXTURES.TREE_2,	0, 0, 0,	0, 0.5 * math.pi, 0,	0.9, 0.9, 0.9, 1,	1, 1,	true, false, false )
		self:SetColor( 1, 1, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SetSize( 600*(673/649), 600, 600 )
		self:Update()
		self:SpawnAtPlayer( 300, false )
	end,
	nil
} )

-- 7/14/2019
EHT.EffectType:SetDefaultDateAdded( 1563145444 )

AddWallReversed( 870, CAT.LAND, "Sea Kelp, Forest", TEXTURES.KELP_1, 500*(852/480), 500, "CaffeinatedMayhem", 0.9, 0.9, 0.9, 1, 1 )

-- 7/17/2019
EHT.EffectType:SetDefaultDateAdded( 1563145444 )

EHT.EffectType:New( 871, "Faerie Fire", {
	Category = CAT.ANIM,
	Init = function( self )
		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0.4, 1, 0.4, 1 )
		self:SpawnAtPlayer( 300 )
	end,
	Update = function( self )
		if self.Emitter then self.Emitter:Update() end
	end,
	Reset = function( self )
		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()
		local maxDim = math.max( sx, sy, sz )
		local ttl = 1350
		r, g, b = 0.9 * r, 0.9 * g, 0.9 * b

		local o = { }
		o.Texture = TEXTURES.CIRCLE_SOFT_4
		o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.CAMERA, yaw
		o.EmissionX, o.EmissionY, o.EmissionZ = x, y, z
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0.5 * sx, 300, 0.5 * sz
		o.ReuseActiveEmissions, o.MaxActiveEmissions, o.MinActiveEmissions = false, 10, 5
		o.EmissionFrequency = ttl / o.MaxActiveEmissions
		o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.RANDOM, 1500, 0
		o.MaxOffset = 0.6 * math.max( sx, sy, sz )
		o.WindFactor = 0
		o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 60, 60, 0, 0
		o.MinTTL, o.MaxTTL = 0.6 * ttl, ttl
		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r - 0.03, g - 0.03, b - 0.03, 0
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r + 0.03, g + 0.03, b + 0.03, 0
		o.ColorShift, o.AlphaShift = 0, 1
		o.MinRotation, o.MaxRotation = 0, 0
		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
		o.MinVectorX, o.MinVectorY, o.MinVectorZ = 3, 3, 0
		o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 3, 3, 0
		o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = true, true, false, false
		o.UseTextureUVAnimation = true
		o.MinSampleRGB, o.MaxSampleRGB, o.MinSampleAlpha, o.MaxSampleAlpha = 1.5, 8, 0, 0

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end
	end,
} )

do
	local defaultMessage = "Label this point of interest"

	EHT.EffectType:New( 872, "Point of Interest", {
		Category = CAT.CUSTOM,
		MetaParams = {
			{
				Name = "Message",
				Deserializer = EHT.EffectDeserializers.StringVar,
				Serializer = EHT.EffectSerializers.StringVar,
			},
		},
		Init = function( self )
			self.ReticleRadius = 100
			self.MaxReticleDistance = 4000
			self.Highlighted = false
			self.HighlightValue = 0
			self.Label = self:GetMetaData( "Message" )
			if not self.Label or "" == self.Label or self.Label == defaultMessage then self.Label = "" end

			self:AddParticle( TEXTURES.ICON_PIN,	0, 0, 0,	0, 0, 0,	1, 1, 1, 0.5,			1, 1,	true, false, false )
			self:SetSize( 100, 100, 100 )
			self:SetColor( 1, 1, 0, 1 )
			self:SpawnAtPlayer( 100 )
		end,
		Update = function( self )
			local isHUD = EHT.Housing.IsHUDMode()

			if isHUD then
				local p = self.Particles[1]
				local yaw = 2 * math.pi * GetLinearInterval( 5000 )

				if "" ~= self.Label and not p:GetHidden() and self.MaxReticleDistance > self:GetPlayerDistance() and self.ReticleRadius >= GetMinReticleDistance( p:GetPosition() ) then
					EHT.UI.ShowInteractionPrompt( nil, self.FormattedLabel, nil )
					self.Highlighted = true
				elseif EHT.UI.GetInteractionPromptLabel() == self.FormattedLabel then
					EHT.UI.HideInteractionPrompt()
					self.Highlighted = false
				end

				self.HighlightValue = zo_clamp( self.HighlightValue + ( self.Highlighted and 0.05 or -0.05 ), 0, 1.5 )

				p:SetOrientationOffsets( 0, yaw, 0 )
				p:SetSampleProcessing( 0.5 + self.HighlightValue + math.sin( ( 0.5 * math.pi + ( GetPlayerCameraHeading() - yaw ) ) % math.pi ), 0 )
				self:Update()
			end
		end,
		Reset = function( self )
			self.Label = self:GetMetaData( "Message" ) or ""
			if self.Label == defaultMessage then self.Label = "" end
			self.FormattedLabel = string.format( "|c33ffff%s|r", self.Label or "" )

			local sx, sy = self:GetSize()
			self.ReticleRadius = math.min( 0.5 * math.max( sx, sy ), 500 )

			self:Update()
		end,
	} )
end

-- 7/21/2019
EHT.EffectType:SetDefaultDateAdded( 1563682875 )

AddTiledEffect( 873, CAT.LIGHT, "String Lights, Multicolor, Horizontal", TEXTURES.CHRISTMAS_LIGHTS_1, 400, 400*(267/2719), 1, 1, 1, 1, nil, 0, 0, 0 )
AddTiledEffect( 874, CAT.LIGHT, "String Lights, Multicolor, Vertical", TEXTURES.CHRISTMAS_LIGHTS_2, 400*(267/2719), 400, 1, 1, 1, 1, nil, 0, 0, 0 )
AddTiledEffect( 875, CAT.LIGHT, "String Lights, Solid, Horizontal", TEXTURES.CHRISTMAS_LIGHTS_1_N, 400, 400*(267/2719), 1, 1, 1, 1, nil, 0, 0, 0 )
AddTiledEffect( 876, CAT.LIGHT, "String Lights, Solid, Vertical", TEXTURES.CHRISTMAS_LIGHTS_2_N, 400*(267/2719), 400, 1, 1, 1, 1, nil, 0, 0, 0 )

-- 7/24/2019
EHT.EffectType:SetDefaultDateAdded( 1564000389 )

EHT.EffectType:New( 877, "Senche, Shadow Stalker", {
	Category = CAT.PET,
	OrderDrawLevelByIndex = true,
	ResetOnColor = true,
	Init = function( self )
		self:SetIntervalOffset( 0, 6000, 1000 )

		local p
		self.PrimaryIndex = 3

		for index = 1, 14 do
			local c = 1.1 - ( 0.05 * index )
			if 8 == index then c = 0 end
			p = self:AddParticle( TEXTURES.SENCHE_SHADOW,	0, 0, 0,	0, 0, 0,	c, c, c, 1,		1, 1,	true, false, false )
			p:SetTextureCoords( 0, 1, 0.5, 1 )
			p:SetVertexColors( 1 + 2 + 4 + 8, c, c, c, 0 )

			if ( self.PrimaryIndex - 1 ) == index then
				p = self:AddParticle( TEXTURES.SENCHE_SHADOW,	0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
				p:SetTextureCoords( 0, 940/1024, 0, 0.5 )
				p:SetAutoColorEnabled( false )
			end
		end

		self:SetSize( 180*(940/508), 180, 180 )
		self:SetColor( 0.8, 0, 0.8, 1 )
		self:SpawnAtPlayer( 90 )
	end,
	Update = function( self )
		local off = self:GetIntervalOffset()
		local pi = self.PrimaryIndex
		local ps = self.Particles
		local s = 0.05 * GetEasedInterval( 6000, off )

		for index = 1, 15 do
			if pi ~= index then
				local m = index % 4
				local p = ps[index]
				local interval = GetLinearInterval( 5000 - 0.3 * index * index, index * index * 40 + off ) -- index * index * 40 + off )
				local y1, y2 = 0.55, 1 + ( 0.1 * index * interval )
				local r, g, b = p:GetColor()
				local alpha = ZO_EaseInOutQuadratic( 2 * interval )
				local x2 = 1 + 0.02 * index * index
				local co = 0.8 - interval
				local v1, v2, v3, v4

				r, g, b = co * r, co * g, co * b

				if 0 == m then
					v1, v2 = 1, 8
					v3, v4 = 2, 4
					y2 = y2 + s
				elseif 1 == m then
					v1, v2 = 2, 4
					v3, v4 = 1, 8
					y2 = y2 - 0.3 * s
				elseif 2 == m then
					v1, v2 = 1, 4
					v3, v4 = 2, 8
					y2 = y2 - ( 0.01 - s )
				else
					v1, v2 = 2, 8
					v3, v4 = 1, 4
					y2 = y2 + 0.4 * s
				end

				p:SetTextureCoords( -( 0.02 * index + interval ), x2, y1, y2 )
				p:SetVertexColors( v1 + v2, r, g, b, 0.3 * alpha )
				p:SetVertexColors( v3 + v4, r, g, b, 0 )
				p:SetSampleProcessing( 1 + ( 4 - m ) * ( 1.5 - interval ) )
			end
		end
	end,
	Reset = function( self )
		self:Update()

		local r, g, b, a = self:GetColor()
		local p = self.Particles[self.PrimaryIndex or 1]
		p:SetColor( 0.5 + 0.5 * r, 0.5 + 0.5 * g, 0.5 + 0.5 * b, a )
	end
} )

do
	local variants = {
		{ ", Opaque", 1 },
		{ ", Transparent", 0.333 },
	}

	local function AddGeometricEffects( startingId, name, texture, rotation, aspectRatio )
		rotation = rotation or 0
		aspectRatio = aspectRatio or 1

		for index, variant in ipairs( variants ) do
			EHT.EffectType:New( startingId + ( index - 1 ), name .. variant[1], {
				Category = CAT.GEO,
				CanPitch = true,
				ResetOnOrient = true,
				ResetOnScale = true,
				ResetOnPosition = true,
				Init = function( self )
					local p = self:AddParticle( texture,	0, 0, 0,	0, 0, 0,	1, 1, 1, variant[2],		1, 1,	true, false, false )
					p:RotateCoords( rotation )
					self:SetColor( 1, 1, 1, 1 )
					self:SetOrientation( 0, 0, 0 )
					self:SetSize( 500, aspectRatio * 500, aspectRatio * 500 )
					self:SpawnAtPlayer( 250, false )
					self:Update()
				end,
			} )
		end
	end

	AddGeometricEffects( 878, "Rectangle", TEXTURES.SOLID, 0 )
	AddGeometricEffects( 880, "Circle", TEXTURES.SHAPE_CIRCLE, 0 )
	AddGeometricEffects( 882, "Right Angle", TEXTURES.SHAPE_RIGHT_ANGLE, 0 )
	AddGeometricEffects( 884, "Triangle, Horizontal", TEXTURES.SHAPE_TRIANGLE, 0.5 * math.pi, 1024/885 )
	AddGeometricEffects( 886, "Triangle, Vertical", TEXTURES.SHAPE_TRIANGLE, 0, 885/1024 )
	AddGeometricEffects( 888, "Arrow, Horizontal", TEXTURES.SHAPE_ARROW, 0 )
	AddGeometricEffects( 890, "Arrow, Vertical", TEXTURES.SHAPE_ARROW, -0.5 * math.pi )
end

-- Next ID: 892

-- 07/29/2019
EHT.EffectType:SetDefaultDateAdded( 1564441493 )

AddSkyEffect(
	892, "Sovngarde",
	-- Options
	{ },
	-- Side Textures Table
	{
		{
			Texture = TEXTURES.LIGHT_RAYS_1, -- "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",
			Stretch = true, AddColor = true, Wrap = true,
			R = 1, G = 1, B = 1, A = 0.12,
			X1 = 0, X2 = 5, Y1 = 0, Y2 = 0.95,
			SampleRGB = 1, SampleAlpha = 0,
			MaxVertexAlphas = { 0.9, 0.9, 0.27, 0.27 },
			RadiusOffset = 0.7
		},
		{
			Texture = TEXTURES.LIGHT_RAYS_1, -- "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",
			Stretch = true, AddColor = true, Wrap = true,
			R = 0.8, G = 0.8, B = 0.8, A = 0.18,
			X1 = 0, X2 = 7, Y1 = 0.01, Y2 = 0.75,
			SampleRGB = 1, SampleAlpha = 0,
			MaxVertexAlphas = { 0.9, 0.9, 0.25, 0.25 },
			RadiusOffset = 0.8
		},
		{
			Texture = TEXTURES.LIGHT_RAYS_1, -- "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",
			Stretch = true, AddColor = true, Wrap = true,
			R = 0.9, G = 0.9, B = 0.9, A = 0.14,
			X1 = 0, X2 = -3, Y1 = 0.02, Y2 = 0.8,
			SampleRGB = 1, SampleAlpha = 0,
			MaxVertexAlphas = { 0.9, 0.9, 0.3, 0.3 },
			RadiusOffset = 0.9
		},
		{
			Texture = TEXTURES.SMOKE_1_TILE, -- "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",
			Stretch = true, AddColor = false, Wrap = true,
			R = 0, G = 1, B = 1, A = 0.2,
			X1 = 1.5, X2 = 0.5, Y1 = -0.25, Y2 = 0.75,
			SampleRGB = 2, SampleAlpha = 0,
			MaxVertexAlphas = { 0.01, 0.01, 1, 1 },
		},
		{
			Texture = TEXTURES.SMOKE_1_TILE, -- "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",
			Stretch = true, AddColor = false, Wrap = true,
			R = 0.5, G = 0, B = 0.4, A = 0.2,
			X1 = 1.5, X2 = 0.5, Y1 = 0, Y2 = 1,
			SampleRGB = 2, SampleAlpha = 0,
			MaxVertexAlphas = { 0.01, 0.01, 1, 1 },
		},
		{
			Texture = TEXTURES.SMOKE_1_TILE, -- "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",
			Stretch = true, AddColor = false, Wrap = true,
			R = 0, G = 0.5, B = 1, A = 0.2,
			X1 = 0, X2 = 1, Y1 = 0.25, Y2 = 1.25,
			SampleRGB = 3, SampleAlpha = 0,
			MaxVertexAlphas = { 0.01, 0.01, 1, 1 },
		},
		{
			Texture = TEXTURES.SMOKE_1_TILE, -- "art/fx/texture/modelfxtextures/noisewhitealphaonly_tile_01.dds",
			Stretch = true, AddColor = false, Wrap = true,
			R = 0.5, G = 1, B = 0.4, A = 0.2,
			X1 = 0, X2 = 1, Y1 = 0, Y2 = 1,
			SampleRGB = 2, SampleAlpha = 0,
			MaxVertexAlphas = { 0.01, 0.01, 1, 1 },
		},
	},
	-- Top Texture Filename
	TEXTURES.SOLID,
	-- Reset Handler
	function( self )
		self.TextureFaces[1][1]:SetHidden( true )
		self.FaceColors = {
			{ 1, 0.5, 1 },
			{ 0.5, 1, 1 },
			{ 0.5, 0.5, 1 },
			{ 1, 1, 1 },
		}

		local r, g, b = self:GetColor()

		do
			local faces1, faces2, faces3 = self.TextureFaces[2], self.TextureFaces[3], self.TextureFaces[4]
			local numFaces = #faces1

			for index = 1, numFaces do
				faces1[index]:SetVertexColors( 1 + 2, 0.8, 1, 1, 0 )
				faces2[index]:SetVertexColors( 1 + 2, 1, 1, 0.8, 0 )
				faces3[index]:SetVertexColors( 1 + 2, 0.7, 0.7, 0.7, 0 )
			end
		end

		for faceIndex = 5, 8 do
			local faces = self.TextureFaces[faceIndex]
			local faceColors = self.FaceColors[faceIndex - 4]
			local fr, fg, fb = faceColors[1], faceColors[2], faceColors[3]
			local cr, cg, cb = r * fr, g * fg, b * fb
			local numFaces = #faces

			faceColors[1], faceColors[2], faceColors[3] = cr, cg, cb
			for index = 1, numFaces do
				faces[index]:SetVertexColors( 1 + 2, cr, cg, cb, 0 )
			end
		end
	end,
	-- Update Handler
	function( self )
		local i1, i2, i3, i4 = 2 * GetLinearInterval( 42000 ), 2 * GetLinearInterval( 47000 ), 2 * GetLinearInterval( 56000 ), 2 * GetLinearInterval( 61000 )

		local fc = self.FaceColors
		local fc1, fc2, fc3, fc4 = fc[1], fc[2], fc[3], fc[4]
		local r1, g1, b1 = fc1[1], fc1[2], fc1[3]
		local r2, g2, b2 = fc2[1], fc2[2], fc2[3]
		local r3, g3, b3 = fc3[1], fc3[2], fc3[3]
		local r4, g4, b4 = fc4[1], fc4[2], fc4[3]

		local faces1, faces2, faces3, faces4 = self.TextureFaces[5], self.TextureFaces[6], self.TextureFaces[7], self.TextureFaces[8]
		local lfaces1, lfaces2, lfaces3 = self.TextureFaces[2], self.TextureFaces[3], self.TextureFaces[4]
		local numFaces = #faces1
		local ba, ca, ao = 0.4, 0.4, 0.6

		ProjectCylinderTextureFaces( faces1, 0, 0.0 + i1, 3.0 + i1, 0.7 + i1, 3.7 + i1 )
		ProjectCylinderTextureFaces( faces2, 0, 0.5 + i2, 2.5 + i2, 0.0 + i2, 2.0 + i2 )
		ProjectCylinderTextureFaces( faces3, 0, 0.3 + i3, 1.3 + i3, 0.4 + i3, 1.4 + i3 )
		ProjectCylinderTextureFaces( faces4, 0, 0.8 + i4, 1.8 + i4, 0.2 + i4, 1.2 + i4 )

		local a1 = 2 * GetLinearInterval( 15000, 0 )
		local al1, al2 = 2 * GetLoopInterval( 4800, 600 ), 2 * GetLoopInterval( 4800, 0 )
		local al3, al4 = 2 * GetLoopInterval( 4800, 1800 ), 2 * GetLoopInterval( 4800, 1200 )
		local al5, al6 = 2 * GetLoopInterval( 4800, 3000 ), 2 * GetLoopInterval( 4800, 2400 )

		local lo = 0.1 * GetEasedInterval( 9600 )
		ProjectCylinderTextureFaces( lfaces1, 0, lo, 2 + lo, 0.02, 0.9 )
		ProjectCylinderTextureFaces( lfaces2, 0, 0.6 + lo, 3.6 + lo, 0.01, 0.85 )
		ProjectCylinderTextureFaces( lfaces3, 0, 0.38 + lo, 2.38 + lo, 0, 0.95 )

		for index = 1, numFaces do
			local tex1, tex2, tex3, tex4 = faces1[index].Texture, faces2[index].Texture, faces3[index].Texture, faces4[index].Texture
			local alpha1, alpha2 = ba + ca * math.abs( -1 + ( ( zo_lerp( a1, 2 + a1, ( index - 1 ) / numFaces ) % 2 ) ) ), ba + ca * math.abs( -1 + ( (zo_lerp( a1, 2 + a1, index / numFaces ) % 2 ) ) )

			tex1:SetVertexColors( 4, r1, g1, b1, alpha1 )
			tex1:SetVertexColors( 8, r1, g1, b1, alpha2 )

			tex2:SetVertexColors( 4, r2, g2, b2, ao - alpha1 )
			tex2:SetVertexColors( 8, r2, g2, b2, ao - alpha2 )

			tex3:SetVertexColors( 4, r3, g3, b3, alpha1 )
			tex3:SetVertexColors( 8, r3, g3, b3, alpha2 )

			tex4:SetVertexColors( 4, r4, g4, b4, ao - alpha1 )
			tex4:SetVertexColors( 8, r4, g4, b4, ao - alpha2 )

			tex1, tex2, tex3 = lfaces1[index].Texture, lfaces2[index].Texture, lfaces3[index].Texture

			tex1:SetVertexColors( 4, 0.7, 1, 1, math.abs( -1 + ( zo_lerp( al1, 2 + al1, ( index - 1 ) / numFaces ) % 2 ) ) )
			tex1:SetVertexColors( 8, 0.7, 1, 1, math.abs( -1 + ( zo_lerp( al1, 2 + al1, index / numFaces ) % 2 ) ) )

			tex2:SetVertexColors( 4, 1, 1, 0.7, math.abs( -1 + ( zo_lerp( al3, 2 + al3, ( index - 1 ) / numFaces ) % 2 ) ) )
			tex2:SetVertexColors( 8, 1, 1, 0.7, math.abs( -1 + ( zo_lerp( al3, 2 + al3, index / numFaces ) % 2 ) ) )

			tex3:SetVertexColors( 4, 1, 0.7, 1, math.abs( -1 + ( zo_lerp( al5, 2 + al5, ( index - 1 ) / numFaces ) % 2 ) ) )
			tex3:SetVertexColors( 8, 1, 0.7, 1, math.abs( -1 + ( zo_lerp( al5, 2 + al5, index / numFaces ) % 2 ) ) )
		end
	end
)

-- 07/31/2019
EHT.EffectType:SetDefaultDateAdded( 1564612556 )

AddRandomizedParticleEffect( 893, "Falling Ash, Light", CAT.ANIM, TEXTURES.ASH,
	50000, 2000, 2000,	0.6, 0, 0, 1,	0, 0.45, 0,			0.5, 0, 0.5,	2, 0.475, 2,	10, 50, 50, true,		60000, 60000,
	7, 12, 0, 0,		0, 1,			0.9, 0.9, 0.9, 0,	1, 1, 1, 0,		0, 1,			0, RAD360, nil, nil,	0, -100, 0,		0, -200, 0,		5 )

AddRandomizedParticleEffect( 894, "Falling Ash, Moderate", CAT.ANIM, TEXTURES.ASH,
	50000, 2000, 2000,	0.6, 0, 0, 1,	0, 0.45, 0,			0.5, 0, 0.5,	2, 0.475, 2,	10, 100, 100, true,		60000, 60000,
	7, 12, 0, 0,		0, 1,			0.9, 0.9, 0.9, 0,	1, 1, 1, 0,		0, 1,			0, RAD360, nil, nil,	0, -100, 0,		0, -200, 0,		20 )

AddRandomizedParticleEffect( 895, "Falling Ash, Heavy", CAT.ANIM, TEXTURES.ASH,
	50000, 2000, 2000,	0.6, 0, 0, 1,	0, 0.45, 0,			0.5, 0, 0.5,	2, 0.475, 2,	10, 150, 150, true,		60000, 60000,
	7, 12, 0, 0,		0, 1,			0.9, 0.9, 0.9, 0,	1, 1, 1, 0,		0, 1,			0, RAD360, nil, nil,	0, -100, 0,		0, -200, 0,		50 )

AddSkyEffect(
	896, "Azura's Dusk",
	-- Options
	{ R = 0.2, G = 0.2, B = 0.5, },
	-- Side Textures Table
	{
		{
			Texture = TEXTURES.CLOUDS_3,
			Stretch = true, Wrap = true, SampleRGB = 1, SampleAlpha = 0,
			R = 1, G = 1, B = 1, A = 1,
			X1 = 0, X2 = 2, Y1 = 0, Y2 = 0.65,
			CanModifyColor = false,
		},
		{
			Texture = TEXTURES.SOLID, Stretch = true, R = 0.2, G = 0.2, B = 0.2, A = 1,
		},
	},
	-- Top Texture Filename
	TEXTURES.SKY_TOP_FADE_OUT,
	-- Reset Handler
	function( self )
		local sx, sy, sz = self:GetSize()
		local r, g, b = self:GetColor()
		local ceilR, ceilG, ceilB = r, g, b
		local floorR, floorG, floorB = 2 * r, 2 * g, 2 * b
		local faces

		self.RotationInterval, self.OvercastInterval = 60000, 20000
		self.OvercastMin, self.OvercastMax = 0.3, 0.6

		faces = self.TextureFaces[1]
		for _, face in ipairs( faces ) do
			face:SetCanModifyColor( true )
			face:SetColor( ceilR, ceilG, ceilB, 1 )
			face:SetCanModifyColor( false )
			face:SetAutoColorEnabled( false )
		end

		faces = self.TextureFaces[2]
		for _, face in ipairs( faces ) do
			face:SetAutoColorEnabled( false )
			face:SetVertexColors( 1 + 2, 1, 1, 1, 0 )
			face:SetVertexColors( 4 + 8, 1, 1, 1, 0.5 )
		end

		faces = self.TextureFaces[3]
		for _, face in ipairs( faces ) do
			face:SetCanModifyColor( true )
			face:SetVertexColors( 1 + 2, ceilR, ceilG, ceilB, 1 )
			face:SetVertexColors( 4 + 8, floorR, floorG, floorB, 1 )
			face:SetCanModifyColor( false )
			face:SetAutoColorEnabled( false )
		end

		faces = self.TextureFaces[4]
		for _, face in ipairs( faces ) do
			face:SetCanModifyColor( true )
			face:SetColor( floorR, floorG, floorB, 1 )
			face:SetCanModifyColor( false )
			face:SetAutoColorEnabled( false )
		end
	end,
	-- Update Handler
	function( self )
		local overcastAlpha = zo_lerp(self.OvercastMin, self.OvercastMax, GetLoopInterval( self.OvercastInterval ) )
		local rotation = -GetLinearInterval( self.RotationInterval )
		local x1, x2, y1, y2 = 0, self.MaxX or 3, 0, self.MaxY or 1

		ProjectCylinderTextureFaces( self.TextureFaces[2], 0, x1 + rotation, x2 + rotation, y1, y2 )

		for _, face in ipairs( self.TextureFaces[2] ) do
			face:SetVertexColors( 1 + 2, 1, 1, 1, 0 )
			face:SetVertexColors( 4 + 8, 1, 1, 1, overcastAlpha )
		end
	end
)

-- 08/07/2019
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1565156976 )

local StarSizeOffsets =
{
	0.0080,
	0.0075,
	0.0090,
	0.0100,
	0.0085,
	0.0070,
}

local function AddStarCubeEffect( id, name, texture, size, interval, randomize )
	local rand = math.random
	local numP = 27
	local interval2 = interval * 2
	local interval02 = interval * 0.2
	local interval04 = interval * 0.4

	return EHT.EffectType:New( id, name, {
		Category = CAT.ANIM,
		CanPitch = true,
		ResetOnOrient = true,
		ResetOnScale = true,
		ResetOnPosition = true,

		Init = function( self )
			local ft = FrameTime
			local ftBase = rand(0, interval)
			self.Alphas = { }

			for index = 1, numP do
				local m = index % 6
				local c = 1 - ( m / 12 )
				local pp = index / numP
				local p
				if "string" == type( texture ) then
					p = self:AddParticle( texture,	0, 0, 0,	0, 0, 0,	c, c, c, 0,		0, 0,	true, false, false )
				else
					p = self:AddParticle( texture[1 + ( index % #texture )],	0, 0, 0,	0, 0, 0,	c, c, c, 0,		0, 0,	true, false, false )
				end

				local sizeOffset = size
				if "table" == type( sizeOffset ) then
					sizeOffset = sizeOffset[ 1 + ( index % #sizeOffset ) ]
				end
				sizeOffset = 0.5 * sizeOffset + sizeOffset * pp
				p:SetSizeOffsets( sizeOffset, sizeOffset )
				p.SizeOffset = sizeOffset
				p.BaseSizeOffset = sizeOffset

				local colorOffset = 0.5 + 0.5 * pp
				p:SetColorOffsets( colorOffset, colorOffset, colorOffset, 0 )
				p:SetSampleProcessing( 1.5, 0 )

				local intervalOffset = ftBase + interval * ( ( pp * 2.5 ) % 1 )
				p.IntervalStart, p.Interval = ft + intervalOffset, interval
			end

			local numPerAxis = 3
			local maxAxisIndex = numPerAxis - 1
			local numP = numPerAxis * numPerAxis * numPerAxis
			local ux, uy, uz = 1 / numPerAxis, 1 / numPerAxis, 1 / numPerAxis
			local ux2, uy2, uz2 = 0.5 * ux, 0.5 * uy, 0.5 * uz
			local ux4, uy4, uz4 = 0.25 * ux, 0.25 * uy, 0.25 * uz
			local ps = self.Particles
			local index = 1

			for ix = 0, maxAxisIndex do
				for iy = 0, maxAxisIndex do
					for iz = 0, maxAxisIndex do
						local p = ps[index]
						if not p then break end

						p.AlphaOffset = 1 + ( index % 3 )
						p:SetPositionOffsets(
							ix * ux + ux4 + ux2 * rand() - 0.5,
							iy * uy + uy4 + uy2 * rand() - 0.5,
							iz * uy + uz4 + uz2 * rand() - 0.5 )

						index = index + 1
					end
				end
			end

			self:SetColor( 0.5, 0.85, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SetSize( 1000, 1000, 1000 )
			self:SpawnAtPlayer( 500, false )
			self:SetCameraFacing( true )
		end,

		Update = function( self )
			local ft = FrameTime
			local ps = self.Particles
			local baseAlpha = self:GetAlpha() or 1

			if randomize then
				for index, p in ipairs( ps ) do
					local i = ( GetLoopInterval( p.Interval, p.IntervalStart ) - 0.66 ) * 3.0
					p:SetAlpha( baseAlpha * i )
				end
			else
				local alphas = self.Alphas
				alphas[1] = baseAlpha * ( 0.1 + 0.6 * GetLoopInterval( interval ) )
				alphas[2] = baseAlpha * ( 0.8 * GetLoopInterval( interval, interval04 ) )
				alphas[3] = baseAlpha * ( 0.2 + 0.8 * GetLoopInterval( interval2, interval02 ) )

				for index, p in ipairs( ps ) do
					p:SetAlpha( alphas[ p.AlphaOffset ] )
				end
			end
		end,

		Reset = function( self )
			local ps = self.Particles
			local sx = self:GetSize()
			self:SetSize( sx, sx, sx )

			if not randomize then
				local c = 1 + 1 - self:GetLuminosity()
				for index, p in ipairs( ps ) do
					local sizeOffset = c * StarSizeOffsets[ 1 + (index % 6) ]
					p:SetSizeOffsets( sizeOffset, sizeOffset )
				end
			end

			self:Update()
		end
	} )
end

AddStarCubeEffect( 897, "Star Cube", TEXTURES.CIRCLE_SOFT, 0.01, 3400 )
--[[
do
	local function GetAlphaInterp( self, h, m )
		local hl, hh = self.HourLow or 3, self.HourHigh or 21
		return ( zo_clamp( h, hl, hh ) - hl ) / ( hh - hl )
	end

	local function GetCurrentAlpha( self, a, h, m )
		local interp = GetAlphaInterp( self, h, m )
		return zo_lerp( self.MinAlpha, self.MaxAlpha, a * ( 1 - math.abs( zo_lerp( -1, 1, interp ) ) ) )
	end

	EHT.EffectType:New( 898, "Darkness, Auto-Adjusting", {
		Category = CAT.LIGHT,
		Global = true,
		Overlay = true,
		ResetOnColor = true,
		UniqueClass = "Darkness, Self-Adjusting",

		Init = function( self )
			self.NextTimeChange = 0
			self.MinAlpha, self.MaxAlpha = 0, 0.8
			self:SetAutoDrawLevelEnabled( false )
			self:SetAutoColorEnabled( false )
			self:SetAutoOrientationEnabled( false )
			self:SetAutoPositionEnabled( false )
			self:SetAutoSizeEnabled( false )

			local tex = self:AddParticle( TEXTURES.SOLID, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, true, false, true ).Texture
			tex:SetAnchor( CENTER, GuiRoot, CENTER, 0, 0 )
			tex:SetDimensions( 5120, 5120 )

			self:SetColor( 0, 0, 0, 0 )
		end,

		Update = function( self )
			local ft = GetFrameTimeSeconds()

			if ft >= self.NextTimeChange then
				local r, g, b = self:GetColor()
				local h, m, s = TamrielTime.Hour, TamrielTime.Minute, TamrielTime.Second
				local alpha = GetCurrentAlpha( self, 1 - math.max( r, g, b ), h, m )

				self.Particles[1]:SetColor( 0, 0, 0, alpha )
				self.NextTimeChange = ft + 1
			end
		end,

		Reset = function( self )
			self.NextTimeChange = 0
			self:Update()

			zo_callLater( function()
				if not self.Particles then return end

				local p = self.Particles[1]
				if not p or not p.Texture then return end

				local tex = p.Texture
				tex:Destroy3DRenderSpace()
				tex:SetAnchor( CENTER, GuiRoot, CENTER, 0, 0 )
				tex:SetDimensions( 5120, 5120 )
				tex:SetDrawLevel( DRAW_LEVEL_OVERLAY_EFFECT )
			end, 1000 )
		end,
	} )
end
]]
do
	EHT.EffectType:New( 898, "Brightness, Global (Auto-Adjusting)", {
		Category = CAT.LIGHT,
		Global = true,
		Overlay = true,
		ResetOnColor = true,
		UniqueClass = "Global Brightness",
		Init = function( self )
			self.NextTimeChange = 0
			self:SetAutoDrawLevelEnabled( false )
			self:SetColor( 0.5, 0.5, 0.5, 1 )
		end,
		Update = function( self )
			if self.NextTimeChange < FrameTime then
				self.NextTimeChange = FrameTime + 2000

				local timeInterval = InverseVariableEase( TamrielTime.Hour / 24, 1.2 )
				local timeBrightness = zo_lerp( ( self.Brightness + 1 ) / 2, self.Brightness, timeInterval )
				RequestBrightness( self, "Global", timeBrightness )
			end
		end,
		Reset = function( self )
			if self:IsHidden() then
				return
			end

			local r, g, b = self:GetColor()
			local brightness = ( r + g + b ) / 3
			self.Brightness = brightness
			self:SetColor( brightness, brightness, brightness, 1 )
			self.NextTimeChange = 0
		end,
		Destroy = function( self )
			RequestBrightness( self, "Global", nil )
		end,
		OnVisibilityChanged = function( self, hidden )
			if hidden then
				RequestBrightness( self, "Global", nil )
			else
				self.NextTimeChange = 0
			end
		end,
	} )
end

function AddHazeEffect( id, name, category, texture, minAlpha, maxAlpha, desaturation, invertAlpha )
	return EHT.EffectType:New( id, name, {
		Category = category,
		Global = true,
		Overlay = true,
		ResetOnColor = true,
		UniqueClass = name,

		Init = function( self )
			self.IntervalOffset = FrameTime
			self:SetAutoDrawLevelEnabled( false )
			self:SetAutoColorEnabled( false )
			self:SetAutoOrientationEnabled( false )
			self:SetAutoPositionEnabled( false )
			self:SetAutoSizeEnabled( false )

			for index = 1, 4 do
				local p = self:AddParticle( texture, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, true, false, true )
				local tex = p.Texture
				tex:SetAnchor( CENTER, GuiRoot, CENTER, 0, 0 )
				tex:SetDimensions( 5120, 5120 )
				tex:SetTextureCoords( 0, 5, 0, 5 )
			end

			local c = 1 - desaturation
			self:SetColor( c, c, c, 1 )
		end,

		Update = function( self )
			local o1, o2, o3 = GetLinearInterval( 36700, self.IntervalOffset ), GetLinearInterval( 46300, self.IntervalOffset ), GetLinearInterval( 58300, self.IntervalOffset )
			local _, y = EHT.World:GetCameraForward()
			local x = math.sin( 0.25 * CameraHeading )
			local px, py, pz = CameraX, CameraY, CameraZ
			local samp = 2 + 0.5 * GetEasedInterval( 22010, self.IntervalOffset )
			local r, g, b, alpha

			x = x + ( ( ( ( px % 10000 ) / 10000 ) + ( ( pz % 10000 ) / 10000 ) ) % 1 )
			y = y - ( ( ( py % 10000 ) / 10000 ) % 1 )
			y = y * 0.1

			for index = 1, 4 do
				local p = self.Particles[index]

				p:SetSampleProcessing( ( 0.6 + 0.1 * index ) * samp, 0 )
				if 1 == index then
					p.Texture:SetTextureCoords( -o3 + x + 0.25, -o3 + x + 0.4, o2 + y + 0.4, o2 + y + 0.5 )
				elseif 2 == index then
					p.Texture:SetTextureCoords( -o1 + x + 0.35, -o1 + x + 0.5, -o3 + y + 0.7, -o3 + y + 0.6 )
				elseif 3 == index then
					p.Texture:SetTextureCoords( o2 + x + 0.55, o2 + x + 0.7, o1 + y + 0.5, o1 + y + 0.6 )
				else
					p.Texture:SetTextureCoords( o1 + x + 0.3, o1 + x + 0.45, -o1 + y + 0.6, -o1 + y + 0.45 )
				end
			end

			self.Iteration = ( ( self.Iteration or 0 ) + 1 ) % 20

			if 10 == self.Iteration then
				for index = 1, 4 do
					local p = self.Particles[index]
					local tex = p.Texture

					p:SetAlpha( self.MaxAlpha )
					tex:Destroy3DRenderSpace()
					tex:SetAnchor( CENTER, GuiRoot, CENTER, 0, 0 )
					tex:SetDimensions( 5120, 5120 )
					tex:SetDrawLevel( DRAW_LEVEL_OVERLAY_EFFECT )
				end
			end
		end,

		Reset = function( self )
			local r, g, b = self:GetColor()
			local alpha = math.max( r, g, b )

			if invertAlpha then
				alpha = 1 - alpha
			end

			self.MaxAlpha = zo_lerp( minAlpha, maxAlpha, alpha )
			self.IntervalOffset = FrameTime
			self:Update()

			local desat = 1 - desaturation
			r, g, b = desat * r, desat * g, desat * b

			for index, p in ipairs( self.Particles ) do
				p:SetColor( 0.33 * index * r, 0.33 * index * g, 0.33 * index * b, self.MaxAlpha )
				p:SetSampleProcessing( 2, 0 )
			end
		end,
	} )
end

-- 08/10/2019
EHT.EffectType:SetDefaultDateAdded( 1565473500 )

AddHazeEffect( 899, "Darkness, Pervasive", CAT.LIGHT, TEXTURES.SMOKE_3, 0.4, 0.7, 1, true )
AddHazeEffect( 900, "Haze, Impenetrable", CAT.WEATHER, TEXTURES.SMOKE_3, 0.4, 0.4, 0, false )

do
	local et = addSkyWindow( 901, CAT.BUILD, "Window, Night Sky (Scaled)", 40000000, 1 )
	et.MetaParams = { GetMetaParamByName( "Pattern Scale % (X)" ), GetMetaParamByName( "Pattern Scale % (Y)" ) }
	local reset = et.Reset
	et.Reset = function( self )
		local scaleX = zo_clamp( ( tonumber( self:GetMetaData( "Pattern Scale % (X)" ) ) or 100 ) / 100, 0.1, 10 )
		local scaleY = zo_clamp( ( tonumber( self:GetMetaData( "Pattern Scale % (Y)" ) ) or 100 ) / 100, 0.1, 10 )
		self.TextureScaleX, self.TextureScaleY = scaleX, scaleY -- scaleX * (self.TCx2 or 1), scaleY * (self.TCy2 or 1)
		reset( self )
	end
end

do
	local canShowBook = true

	function EHT.Effect:SetCanShowFoliumDiscognitum( value )
		canShowBook = value
	end

	local function AddLibraryEffect( id, name, categoryId, colorR, colorG, colorB )
		local currentBook
		local prompted = false

		local function ShowFoliumDiscognitum()
			if canShowBook then
				EHT.UI.ShowFoliumDiscognitum( name, categoryId )
			end
		end

		EHT.EffectType:New( id, string.format( "Collections, %s", name ), {
			Category = CAT.LIBRARY,
			CanPitch = true,
			ResetOnColor = true,
			ResetOnOrient = true,
			ResetOnPosition = true,
			ResetOnScale = true,
			UniqueClass = name,

			Init = function( self )
				local ps = self.Particles

				self:AddParticle( TEXTURES.TOME_1_B,	0, 0, 3,		0, 0, 0,						1, 1, 1, 1,		1, 1,		true, false, false )
				self:AddParticle( TEXTURES.TOME_1_B,	0, 0, -3,		0, 0, 0,						1, 1, 1, 1,		1, 1,		true, false, false )
				self:AddParticle( TEXTURES.TOME_1_S,	-0.5, 0, 0,		0, 0.5*math.pi, 0,				1, 1, 1, 1,		1, 1,		true, false, false )
				self:AddParticle( TEXTURES.TOME_1_P,	0.5, 0, 0,		0, 0.5*math.pi, 0,				1, 1, 1, 1,		1, 1,		true, false, false )
				self:AddParticle( TEXTURES.TOME_1_P,	0, 0.5, 0,		0.5*math.pi, 0.5*math.pi, 0,	1, 1, 1, 1,		1, 1,		true, false, false )
				self:AddParticle( TEXTURES.TOME_1_P,	0, -0.5, 0,		0.5*math.pi, 0.5*math.pi, 0,	1, 1, 1, 1,		1, 1,		true, false, false )

				self:SetSize( (881/999)*30, 30, 30 )
				self:SetOrientation( 0, 0, 0 )
				self:SetColor( colorR or 1, colorG or 1, colorB or 1, 1 )
				self:SpawnAtPlayer( 120 )

				self.ReticleRadius = 0.8 * math.max( self:GetSize() )
				currentBook = self
				canShowBook = true
			end,

			Reset = function( self )
				local sx, sy, sz = self:GetSize()
				self:SetSize( sx, sz, sz )

				local r, g, b = self:GetColor()
				local c = 0.5 + 0.5 * ( ( r + g + b ) / 3 )
				local ps = self.Particles
				local numP = #ps

				self.ReticleRadius = 0.8 * math.max( self:GetSize() )
				self:Update()

				ps[3]:SetSize( 6, sz )

				for index = 4, numP do
					local p = ps[index]
					p:SetColor( c, c, c, 1 )
					p:SetSize( 6, 5 <= index and sx or sz )
				end
			end,

			Update = function( self )
				if EHT.Housing.IsHUDMode() and not IsGameCameraUIModeActive() and EHT.UI.IsBookHidden() and 500 > self:GetPlayerDistance() and EHT.UI.IsLorebookSelectionDialogHidden() and self.ReticleRadius >= GetMinReticleDistance( self.Particles[1]:GetPosition() ) then
					if self.lastClickCheck and EHT.LastMouseClick >= self.lastClickCheck then
						ShowFoliumDiscognitum()
					elseif not prompted then
						EHT.UI.ShowInteractionPrompt( "EHT_SHOW_GUEST_JOURNAL", "Read " .. name, ShowFoliumDiscognitum )
						prompted = true
					end
				elseif prompted then
					prompted = false
					EHT.UI.HideInteractionPrompt()
				end

				self.lastClickCheck = FrameTime
			end,

			Destroy = function( self )
				if self == currentBook then
					currentBook = nil
				end

				EHT.UI.HideInteractionPrompt()
			end
		} )
	end

	AddLibraryEffect( 902, "Folium Discognitum",		1,		0.9,	0,		1 )
	AddLibraryEffect( 903, "Orange Is The New Black",	2,		1,		0.6,	0.3 )
	AddLibraryEffect( 904, "Eidetic Compendium",		3,		0,		1,		1 )
end

-- 08/16/2019
EHT.EffectType:SetDefaultDateAdded( 1566009985 )

EHT.EffectType:New( 905, "Ground, Cracked, Glowing", {
	Category = CAT.ANIM,
	CanPitch = true,
	Init = function( self )
		self.IntervalOffset = math.random( 12000 )
		for index = 1, 2 do
			local p = self:AddParticle( TEXTURES.CRACKS_2, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.25, 1, 1, true, false )
			if 0 == index % 2 then
				p.Interval = 5000
				p.IntervalOffset = self.IntervalOffset
				p.Easing = 2
			else
				p.Interval = 6000
				p.IntervalOffset = 4000 + self.IntervalOffset
				p.Easing = 2
			end
		end
		self:SetSize( 512, 512, 512 )
		self:SetColor( 1, 0.5, 0, 1 )
		self:SetContrast( 2 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 2 )
	end,
	Update = function( self )
		for index = 1, 2 do
			local p = self.Particles[index]
			local interval = VariableEase( GetLinearInterval( p.Interval, p.IntervalOffset ), p.Easing )
			p:SetSampleProcessing( 1 + 3 * interval )
		end
	end,
	Reset = function( self )
		self:Update()
		local r, g, b, a = self:GetColor()
		for index = 1, 2 do
			local p = self.Particles[index]
			local m = index % 2
			p:SetVertexColors( 3, r, g, b, 0 == m and 1 or 0 )
			p:SetVertexColors( 12, r, g, b, 0 == m and 0 or 1 )
		end
	end,
} )

do
	EHT.EffectType:New( 906, "Brightness, Area", {
		AutoPreview = false,
		Category = CAT.LIGHT,
		CanPitch = false,
		ResetOnColor = true,
		ResetOnScale = true,
		ResetOnPosition = true,
		ResetOnOrient = false,

		Init = function( self )
			local p, r

			self:SetAutoColorEnabled( false )
			self:SetAutoDrawLevelEnabled( false )
			self:SetColor( 0.5, 0.5, 0.5, 1 )

			p = self:AddParticle( TEXTURES.SPHERE,		0, 0, 0,	0, 0, 0,	0, 0, 0, 0,		1, 1,		false, false, false )
			p:SetHidden( true )

			self:SetSize( 1000, 1000, 1000 )
			self:SpawnAtPlayer( 0 )
		end,

		Update = function( self )
			if self:IsHidden() then
				return
			end

			local p1 = self.Particles[1]
			local r = self.Radius
			local distance = self:GetPlayerDistance()
			local radius = self.Radius
			local value = distance <= radius and self.Brightness or nil

			RequestBrightness( self, "Local", value )

			if self ~= CurrentEditorEffect or EHT.Housing.IsHUDMode() then
				p1:SetHidden( true )
			else
				local a = 0.15 + 0.5 * self.Brightness

				if value then
					p1:SetColor( 0, 1, 1, a )
				else
					p1:SetColor( 1, 1, 1, 0.5 )
				end

				p1:FaceCamera()
				p1:SetHidden( false )
			end
		end,

		Reset = function( self, reason )
			local r, g, b = self:GetColor()
			self.Brightness = ( r + g + b ) / 3

			if not reason or reason ~= RESET_COLOR then
				local s = self:GetSize()
				self.Radius = 0.45 * s
				self:SetSize( s, s, s )
				self:Update()
			end
		end,

		Destroy = function( self )
			RequestBrightness( self, "Local", nil )
		end,

		OnVisibilityChanged = function( self, hidden )
			if hidden then
				RequestBrightness( self, "Local", nil )
			else
				RequestBrightness( self, "Local", self.Brightness )
			end
		end
	} )
end

-- 08/24/2019
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1566638310 )

do
	local function AddCloudedSkyEffect( id, name, speed, lightning )
		local et = AddSkyEffect(
			id, name,
			-- Options
			{ CanModifyTopColor = true, },
			-- Side Textures Table
			{
				{
					Texture = TEXTURES.CLOUDS_2, Stretch = true, Wrap = true, SampleRGB = 0.8, SampleAlpha = 0, AddColor = false,
					R = 1, G = 1, B = 1, A = 0.5, X1 = 0, X2 = 1,
					MaxVertexAlphas = { 0, 0, 0.5, 0.5 },
				},
				{
					Texture = TEXTURES.CLOUDS_2, Stretch = true, Wrap = true, SampleRGB = 1.1, SampleAlpha = 0, DodgeColor = true,
					R = 1, G = 1, B = 1, A = 0.5, X1 = 1.4, X2 = 0.4, Y1 = -0.2, Y2 = 1.4,
					MaxVertexAlphas = { 0, 0, 0.5, 0.5 },
				},
				{
					Texture = TEXTURES.SOLID, Stretch = false, Wrap = false, SampleRGB = 1, SampleAlpha = 0, AddColor = false,
					R = 0, G = 0, B = 0, A = 1,
				},
			},
			-- Top Texture Filename
			TEXTURES.SOLID,
			-- Reset Handler
			function( self )
				local sx, sy, sz = self:GetSize()
				local r, g, b = self:GetColor()

				self.ResetOnColor = true
				self.ResetOnOrient = true
				self.ResetOnPosition = true
				self.ResetOnScale = true
				self.RotationInterval = 600000

				local p = self.Particles[1]
				p:SetAutoColorEnabled( false )
				p:SetColor( 1, 1, 1, 1 )

				local screenWidth, screenHeight = GuiRoot:GetDimensions()
				local radius = 0.5 * sx
				local circ = 2 * math.pi * radius
				local y1, y2 = 0, 2
				local x1, x2 = 0, EHT.World:GetAspectRatioWidth( screenWidth, screenHeight, circ, sy, true )

				self.Radius, self.ProjectX, self.ProjectY = radius, x2, y2

				ProjectCylinderTextureFaces( self.TextureFaces[2], radius, x1, x2, y1, y2 )
				ProjectCylinderTextureFaces( self.TextureFaces[3], radius, x1, x2, -0.2, 1.4 )

				local r, g, b = self:GetColor()
				for _, p in ipairs( self.TextureFaces[4] ) do
					p:SetColor( 0.2 * r, 0.2 * g, 0.2 * b, 1 )
				end

				local topFaces = self.TextureFaces[1]
				local top = topFaces[1]
				top:SetDrawLevel( 1 )
				top:SetColor( 0.2 * r, 0.2 * g, 0.2 * b, 1 )
				local sx, sy = top:GetSize()
				top:SetSize( sx * 1.1, sy * 1.1 )

				local topCloud = self:CloneParticle( top )
				topCloud:SetTextureFile( TEXTURES.CLOUDS_2_R )
				topFaces[2] = topCloud
				topCloud:SetColor( r, g, b, 1 )
				topCloud:SetDrawLevel( 2 )
			end,
			-- Update Handler
			function( self )
				local i1 = 2 * GetLinearInterval( speed )
				local faces1, faces2 = self.TextureFaces[2], self.TextureFaces[3]
				local f2s = 0.5 * GetEasedInterval( 4 * speed * math.pi )

				ProjectCylinderTextureFaces( faces1, self.Radius, 0.5 + i1, 0.5 + self.ProjectX + i1, 0, self.ProjectY )
				ProjectCylinderTextureFaces( faces2, self.Radius, 2 * i1, self.ProjectX + 2 * i1, -0.2 + f2s, 1.4 + f2s )

				local i1 = 2 * GetLinearInterval( 3 * speed )
				local top = self.TextureFaces[1][2]
				top:RotateCoords( -( i1 + 0.3 ) * math.pi, nil, nil, 0.9, 0.9 )

				if 0 ~= lightning then
					local ft = FrameTime

					if ft > ( self.LightningEnd1 or 0 ) then
						self.Lightning1 = ft
						self.LightningDuration1 = math.random( lightning, 6 * lightning )
						self.LightningFollowup1 = math.random( 100, 600 )
						self.LightningEnd1 = ft + self.LightningDuration1
					end

					if ft > ( self.LightningEnd2 or 0 ) then
						self.Lightning2 = ft
						self.LightningDuration2 = math.random( lightning, 3 * lightning )
						self.LightningFollowup2 = math.random( 300, 700 )
						self.LightningEnd2 = ft + self.LightningDuration2
					end

					local l1, l2 = GetEasedInterval( self.LightningDuration1, self.Lightning1 ), GetEasedInterval( self.LightningDuration1, self.Lightning1 + self.LightningFollowup1 )
					local l3, l4 = GetEasedInterval( self.LightningDuration2, self.Lightning2 ), GetEasedInterval( self.LightningDuration2, self.Lightning2 + self.LightningFollowup2 )

					local c = 0.92
					local s1 = 0.8 + 7 * ( math.max( c, l1, l2 ) - c )
					local s2 = 1.1 + 14 * ( math.max( c, l3, l4 ) - c )
					local sg = math.max( s1, s2 )

					local numFaces = #faces1
					for index = 1, numFaces do
						faces1[index]:SetSampleProcessing( sg )
						faces2[index]:SetSampleProcessing( sg )
					end

					local st = math.max( s1, s2 )
					top:SetSampleProcessing( 0.8 + 0.4 * st )
				end
			end
		)
		local init = et.Init
		et.Init = function( self )
			init( self )
			self:SetColor( 0.5, 0.75, 1, 1 )
		end
		return et
	end

	AddCloudedSkyEffect( 907, "Ominous Sky",	500000, 0 )
	AddCloudedSkyEffect( 908, "Thunderstorm",	320000, 3000 )
	AddCloudedSkyEffect( 909, "Maelstrom",		20000, 3000 )
end

local function AddMovingFogEffect( id, name, alphaCoefficient, speed )
	local et = EHT.EffectType:New( id, name, {
		Category = CAT.WEATHER,
		CanPitch = true,
		ResetOnOrient = true, ResetOnPosition = true, ResetOnScale = true,
		Init = function( self )
			self.IntervalOffset = math.random()

			local numP = 3
			local partition1, partition2 = numP, numP
			local p

			for index = 1, numP do
				local cc = 0.2 + 0.8 * ( index / numP )
				local ca = 0.7 + 0.3 * ( index / numP )
				local mu = 1 + math.floor( index / 3 )

				for clone = 1, 2 do
					p = self:AddParticle( TEXTURES.SMOKE_4,		1 == clone and -0.25 or 0.25, 0, 0,		0, 0, 0,	cc, cc, cc, alphaCoefficient * ca,		0.5, 1,		true, false, 0 ~= speed )
					p:SetSampleProcessing( ( ( numP - index + 1 ) / numP ) * 3, 0 )
					p.IntervalOffset = self.IntervalOffset + speed * ( ( index / partition1 ) )
					p.Interval = speed * ( index / partition2 )
					p.FlipY = 0 == ( index % 2 )
					p.Multiplier = mu
				end
			end

			self:SetColor( 0.9, 1, 1, 1 )
			self:SetSize( 4000, 0, 2000 )
			self:SetOrientation( math.rad( 90 ), 0, 0 )
			self:SpawnAtPlayer( 50 )
		end,
		Update = function( self )
			local eR, eG, eB = self:GetColor()
			local numP = #self.Particles

			for index = 1, numP do
				local p = self.Particles[index]
				local cR, cG, cB, cA = p:GetColorOffsets()
				local offsetX1 = GetLinearInterval( p.Interval, p.IntervalOffset )
				local offsetY1 = p.FlipY and 0 or 1
				local offsetY2 = p.FlipY and 1 or 0
				local offsetX2 = ( 1 + offsetX1 )
				local tex = p.Texture
				local r, g, b = eR * cR, eG * cG, eB * cB
				-- p.Multiplier
				if 0 == index % 2 then
					offsetX2 = zo_lerp( offsetX1, offsetX2, 0.5 )
					p:SetVertexColors( 1 + 4, r, g, b, cA )
					p:SetVertexColors( 2 + 8, r, g, b, 0 )
				else
					offsetX1 = zo_lerp( offsetX1, offsetX2, 0.5 )
					p:SetVertexColors( 2 + 8, r, g, b, cA )
					p:SetVertexColors( 1 + 4, r, g, b, 0 )
				end

				p:SetTextureCoords( offsetX1, offsetX2, offsetY1, offsetY2 )
			end
		end,
		Reset = function( self )
			self:Update()
		end,
	} )
	return et
end

AddMovingFogEffect( 910, "Fog, Drifting",		0.5, 80000 )

local function AddGlassEffect( id, name, alpha )
	EHT.EffectType:New( id, name, {
		Category = CAT.BUILD,
		CanPitch = true, ResetOnColor = true, ResetOnOrient = true, ResetOnPosition = true, ResetOnScale = true,
		Init = function( self )
			self:AddParticle( TEXTURES.GLASS_3,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,		true, false, true )
			self:SetColor( 0.7, 0.8, 0.8, 1 )
			self:SetSize( 500, 0, 500 )
			self:SetOrientation( math.rad( 90 ), 0, 0 )
			self:SpawnAtPlayer( 250 )
		end,
		Reset = function( self )
			local p = self.Particles[1]
			local sx, sy, sz = self:GetSize()
			local size = math.max( sx, sy, sz )
			local r, g, b, a = self:GetColor()
			local co1, co2 = 0.8, 1.2

			size = size < 1800 and 1 or math.min( 2, size / 1800 )
			if sx < sy then
				sx = sx / sy * size
				sy = size
			else
				sy = sy / sx * size
				sx = size
			end

			p:SetTextureCoords( 0, sx, 0, sy )
			self.MinR, self.MinG, self.MinB, self.MinA = co1 * r, co1 * g, co1 * b, co1 * a * alpha
			self.MaxR, self.MaxG, self.MaxB, self.MaxA = co2 * r, co2 * g, co2 * b, co2 * a * alpha
		end,
		Update = function( self )
			local c = ZO_EaseInOutQuadratic( self:GetViewingAngleAlpha() )
			local minR, minG, minB, minA = self.MinR, self.MinG, self.MinB, self.MinA
			local maxR, maxG, maxB, maxA = self.MaxR, self.MaxG, self.MaxB, self.MaxA
			local r, g, b, a = zo_lerp( minR, maxR, c ), zo_lerp( minG, maxG, c ), zo_lerp( minB, maxB, c ), zo_lerp( minA, maxA, c )
			local p = self.Particles[1]

			p:SetVertexColors( 1, zo_lerp( minR, maxR, -0.2 + c ), zo_lerp( minG, maxG, -0.2 + c ), zo_lerp( minB, maxB, -0.2 + c ), zo_lerp( minA, maxA, -0.2 + c ) )
			p:SetVertexColors( 2 + 4, r, g, b, a )
			p:SetVertexColors( 8, zo_lerp( minR, maxR, 0.2 + c ), zo_lerp( minG, maxG, 0.2 + c ), zo_lerp( minB, maxB, 0.2 + c ), zo_lerp( minA, maxA, 0.2 + c ) )
		end
	} )
end

-- 09/15/2019
EHT.EffectType:SetDefaultDateAdded( 1568576059 )

AddGlassEffect( 911, "Glass, Thin", 0.7 )
AddGlassEffect( 912, "Glass, Fogged", 0.95 )

-- 10/10/2019
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1570757960 )

local function CullTargetEffectList( list )
	if list then
		for index = #list, 1, -1 do
			local e = list[index]
			if not e or not e.Active or e.Deleted then
				table.remove( list, index )
			end
		end
	end
end

local function AddActionEffect( id, name, onActionStateChanged, enableAxisX, enableAxisY )
	EHT.EffectType:New( id, name, {
		AutoPreview = false, Category = CAT.ACTION, CanPitch = false, ResetOnColor = true, ResetOnScale = true, ResetOnPosition = true, ResetOnOrient = false,
		MetaParams = { { Name = "Target Effect", Deserializer = EHT.EffectDeserializers.Int8, Serializer = EHT.EffectSerializers.Int8 } },
		OrderDrawLevelByIndex = true,

		Init = function( self )
			self.OnActionStateChanged = onActionStateChanged
			self.TargetEffects = EHT.Effect:GetById( tonumber( self:GetMetaData( "Target Effect" ) ), true )

			self:SetAutoPositionEnabled( false )
			self:SetAutoSizeEnabled( false )
			self:SetAutoColorEnabled( false )
			self:SetCameraFacing( true )
			self:SetColor( 0.5, 0.5, 0.5, 1 )
			self.value1, self.value2 = { }, { }

			-- Value 2

			do
				local p = self:AddParticle( TEXTURES.ARROW_1,	0, 0, 0,		0, 0, 0,	0, 0, 0, 0,		1, 1,		false, false, false )
				p:SetHidden( true )
				p:SetColor( 1, 1, 1, 1 )
				p:SetSize( 20, 100 )
				p:RotateCoords( -RAD90, -2.25, 0.5, 0.15, 0.75 )
				self.value2.background1 = p
			end

			do
				local p = self:AddParticle( TEXTURES.ARROW_1,	0, 0, 0,		0, 0, 0,	0, 0, 0, 0,		1, 1,		false, false, false )
				p:SetHidden( true )
				p:SetColor( 1, 1, 1, 1 )
				p:SetSize( 20, 100 )
				p:RotateCoords( RAD90, -2.25, 0.5, 0.15, 0.75 )
				self.value2.background2 = p
			end
			
			-- Value 1

			do
				local p = self:AddParticle( TEXTURES.ARROW_1,	0, 0, 0,		0, 0, 0,	0, 0, 0, 0,		1, 1,		false, false, false )
				p:SetHidden( true )
				p:SetColor( 1, 1, 1, 1 )
				p:SetSize( 100, 20 )
				p:RotateCoords( RAD180, -2.25, 0.5, 0.15, 0.75 )
				self.value1.background1 = p
			end

			do
				local p = self:AddParticle( TEXTURES.ARROW_1,	0, 0, 0,		0, 0, 0,	0, 0, 0, 0,		1, 1,		false, false, false )
				p:SetHidden( true )
				p:SetColor( 1, 1, 1, 1 )
				p:SetSize( 100, 20 )
				p:RotateCoords( 0, -2.25, 0.5, 0.15, 0.75 )
				self.value1.background2 = p
			end

			do
				local p = self:AddParticle( TEXTURES.BOX,		0, 0, 0,		0, 0, 0,	0, 0, 0, 0,		1, 1,		false, false, false )
				p:SetHidden( true )
				p:SetVertexColors( 1, 0.356, 0.25, 0.722, 0.25 )
				p:SetVertexColors( 2, 0.356, 0.25, 0.722, 0.5 )
				p:SetVertexColors( 4, 0.356, 0.25, 0.722, 0.75 )
				p:SetVertexColors( 8, 0.356, 0.25, 0.722, 1 )
				p:SetSize( 20, 100 )
				self.value2.bar = p
			end

			do
				local p = self:AddParticle( TEXTURES.BOX,		0, 0, 0,		0, 0, 0,	0, 0, 0, 0,		1, 1,		false, false, false )
				p:SetHidden( true )
				p:SetVertexColors( 1, 0.25, 0.356, 0.722, 0.75 )
				p:SetVertexColors( 2, 0.25, 0.356, 0.722, 0.25 )
				p:SetVertexColors( 4, 0.25, 0.356, 0.722, 1 )
				p:SetVertexColors( 8, 0.25, 0.356, 0.722, 0.5 )
				--p:SetColor( 0.25, 0.356, 0.722, 0.5 )
				p:SetSize( 100, 20 )
				self.value1.bar = p
			end

			self:SetSize( 100, 100, 100 )
			self:SpawnAtPlayer( 200 )
		end,

		Update = function( self )
			local hidden = not ( self == CurrentEditorEffect and not EHT.Housing.IsHUDMode() )
			local value1, value2 = self.value1, self.value2

			if not hidden then
				--local angle = math.atan2( -( CameraX - self.X ), -( CameraZ - self.Z ) ) % RAD360
				--local offsetX, offsetZ = math.sin( angle ), math.cos( angle )

				if enableAxisX then
					local v1 = self.SizeX / 2000
					--local x, y, z = self.X + offsetX * 100, self.Y, self.Z + offsetZ * 100
					local x, y, z = self.X, self.Y, self.Z

					value1.bar:SetTextureCoords( 0.95 - v1, 1.45 - v1, -1, 2 )
					value1.bar:SetPosition( x, y, z )
					value1.background1:SetPosition( x, y, z )
					value1.background2:SetPosition( x, y, z )
				end

				if enableAxisY then
					local v2 = self.SizeY / 2000
					--local x, y, z = self.X + offsetX * 100, self.Y, self.Z + offsetZ * 100
					local x, y, z = self.X, self.Y, self.Z

					value2.bar:SetTextureCoords( -1, 2, -0.45 + v2, 0.05 + v2 )
					value2.bar:SetPosition( x, y, z )
					value2.background1:SetPosition( x, y, z )
					value2.background2:SetPosition( x, y, z )
				end
			end

			if enableAxisX then
				for _, p in pairs( value1 ) do
					p:SetHidden( hidden )
				end
			end

			if enableAxisY then
				for _, p in pairs( value2 ) do
					p:SetHidden( hidden )
				end
			end
		end,

		OnMetaDataChanged = function( self, field, prevValue, newValue )
			if "Target Effect" == field then
				CullTargetEffectList( self.TargetEffects )
				self.OnActionStateChanged( self, false, self.TargetEffects )
				self.IsActionActive = nil
				self.TargetEffects = EHT.Effect:GetById( newValue, true )
				self.OnActionStateChanged( self, true, self.TargetEffects )
			end
		end,

		Reset = function( self, reason )
			self.TargetEffects = EHT.Effect:GetById( tonumber( self:GetMetaData( "Target Effect" ) ), true )
			self.OnActionStateChanged( self, true, self.TargetEffects )

			local sizeX, sizeY = self:GetSize()
			sizeX, sizeY = zo_clamp( sizeX, 1, 1000 ), zo_clamp( sizeY, 1, 1000 )

			if uniformSize then
				self:SetSize( sizeX, sizeX, sizeX )
			else
				self:SetSize( sizeX, sizeY, sizeY )
			end

			self:Update()
		end,

		Destroy = function( self )
			self.IsActionActive = nil
			CullTargetEffectList( self.TargetEffects )
			self.OnActionStateChanged( self, nil, self.TargetEffects )
		end,
	} )
end

local function AddRadiusActionEffectType( id, name, inclusive, onActionStateChanged, uniformSize, metaParams )
	if nil == uniformSize then uniformSize = true end

	return EHT.EffectType:New( id, name, {
		AutoPreview = false, Category = CAT.ACTION, CanPitch = false, ResetOnColor = true, ResetOnScale = true, ResetOnPosition = true, ResetOnOrient = false,
		MetaParams = metaParams,

		Init = function( self )
			self.OnActionStateChanged = onActionStateChanged
			self.TargetEffects = EHT.Effect:GetById( tonumber( self:GetMetaData( "Target Effect" ) ), true )

			self:SetAutoColorEnabled( false )
			self:SetColor( 0.5, 0.5, 0.5, 1 )

			local p = self:AddParticle( TEXTURES.SPHERE,		0, 0, 0,	0, 0, 0,	0, 0, 0, 0,		1, 1,		false, false, false )
			p:SetHidden( true )

			self:SetSize( 1000, 1000, 1000 )
			self:SpawnAtPlayer( 0 )
		end,

		Update = function( self )
			local p = self.Particles[1]
			local active = self:IsNearPlayer( self.ActionEffectRadius )
			if not inclusive then active = not active end

			if active ~= self.IsActionActive then
				CullTargetEffectList( self.TargetEffects )
				self.IsActionActive = active
				self.OnActionStateChanged( self, active, self.TargetEffects )
			end

			if EHT.Housing.IsHUDMode() or self ~= CurrentEditorEffect then
				p:SetHidden( true )
			else
				local size = self:GetSize()
				p:SetSize( size, size )

				if active then
					p:SetColor( 0, 1, 1, 0.5 )
				else
					p:SetColor( 1, 1, 1, 0.4 )
				end

				p:FaceCamera()
				p:SetHidden( false )
			end
		end,

		OnMetaDataChanged = function( self, field, prevValue, newValue )
			if "Target Effect" == field then
				self.OnActionStateChanged( self, nil, self.TargetEffects )
				CullTargetEffectList( self.TargetEffects )
				self.IsActionActive = nil
				self.TargetEffects = EHT.Effect:GetById( newValue, true )
			end
		end,

		Reset = function( self, reason )
			self.TargetEffects = EHT.Effect:GetById( tonumber( self:GetMetaData( "Target Effect" ) ), true )
			self.IsActionActive = nil

			local s = self:GetSize()
			self.ActionEffectRadius = 0.5 * s

			if uniformSize then
				self:SetSize( s, s, s )
			end

			self:Update()
		end,

		Destroy = function( self )
			self.IsActionActive = nil
			CullTargetEffectList( self.TargetEffects )
			self.OnActionStateChanged( self, nil, self.TargetEffects )
		end,
	} )
end

local function AddRadiusActionEffect( id, name, inclusive, onActionStateChanged, uniformSize )
	local metaParams =
	{
		{
			Name = "Target Effect", Deserializer = EHT.EffectDeserializers.Int8, Serializer = EHT.EffectSerializers.Int8
		}
	}
	return AddRadiusActionEffectType( id, name, inclusive, onActionStateChanged, uniformSize, metaParams )
end

local function AddRadiusActionEffectForFurniture( id, name, inclusive, onActionStateChanged, uniformSize )
	local metaParams =
	{
		{
			Name = "Furniture", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
		}
	}
	return AddRadiusActionEffectType( id, name, inclusive, onActionStateChanged, uniformSize, metaParams )
end

do
	local LERP_INTERVAL = 1000

	do
		local function Action( self, active, effects )
			local r, g, b, a = self:GetColor()

			for _, effect in ipairs( effects ) do
--				if effect.Active and not effect.Deleted and effect.Particles then
					if nil == active then
						effect:UnmodifyColor()
						effect:SetHidden( false )
					elseif active then
						EHT.EffectLerp:New( effect, "Color", LERP_INTERVAL, function( effect, key, lerp )
							effect:ModifyColor( 0, 0, 0, 0, lerp )
							effect:SetHidden( false )
						end, function( effect, key, lerp )
							effect:SetHidden( true )
							effect:UnmodifyColor()
						end )
					else
						EHT.EffectLerp:New( effect, "Color", LERP_INTERVAL, function( effect, key, lerp )
							effect:ModifyColor( 0, 0, 0, 0, 1 - lerp )
							effect:SetHidden( false )
						end, function( effect )
							effect:UnmodifyColor()
						end )
					end
--				end
			end
		end

		AddRadiusActionEffect( 913, "Hide when in range", true, Action )
		AddRadiusActionEffect( 914, "Hide when out of range", false, Action )
	end

	do
		local function Action( self, active, effects )
			local r, g, b, a = self:GetColor()

			for _, effect in ipairs( effects ) do
				if nil == active then
					effect:UnmodifyColor()
				elseif active then
					effect:UnmodifyColor()
					EHT.EffectLerp:New( effect, "Color", LERP_INTERVAL, function( effect, key, lerp )
						effect:ModifyColor( r, g, b, nil, lerp )
					end )
				else
					EHT.EffectLerp:New( effect, "Color", LERP_INTERVAL, function( effect, key, lerp )
						effect:ModifyColor( r, g, b, nil, 1 - lerp )
					end, function( effect )
						effect:UnmodifyColor()
					end )
				end
			end
		end

		AddRadiusActionEffect( 915, "Recolor when in range", true, Action )
		AddRadiusActionEffect( 916, "Recolor when out of range", false, Action )
	end

	do
		local activated, deactivated = { }, { }
		local registered = false
		local speed = 0.33

		local function Update()
			local pX, pY, pZ = PlayerX, PlayerY, PlayerZ

			for effect, _ in pairs( activated ) do
				if not effect.Active or effect.Deleted then
					activated[effect] = nil
				else
					local x, y, z = effect:GetPosition()
					effect:SetPosition( zo_lerp( x, pX, speed ), zo_lerp( y, pY, speed ), zo_lerp( z, pZ, speed ) )
					effect:SetOrientation( nil, CameraHeading )
				end
			end

			for effect, _ in pairs( deactivated ) do
				if not effect.Active or effect.Deleted or effect:IsHidden() then
					deactivated[effect] = nil
				else
					local x, y, z = effect:GetPosition()
					effect:SetPosition( zo_lerp( x, pX, speed ), zo_lerp( y, pY, speed ), zo_lerp( z, pZ, speed ) )
					effect:SetOrientation( nil, CameraHeading )
				end
			end
		end

		local function Action( self, active, effects )
			if not registered then
				registered = true
				EVENT_MANAGER:RegisterForUpdate( "EHT_ActionFX_FollowPlayer", 1, Update )
			end

			for _, effect in ipairs( effects ) do
				if not effect.OriginalAlpha then _, _, _, effect.OriginalAlpha = effect:GetColor() end
				if not effect.OriginalPosition then effect.OriginalPosition = { effect:GetPositionAndOrientation() } end

				if nil == active then
					effect:SetHidden( false )
					effect:SetPositionAndOrientation( unpack( effect.OriginalPosition ) )
					activated[effect] = nil
					deactivated[effect] = nil
				elseif active and not activated[effect] then
					activated[effect] = true
					deactivated[effect] = nil
					effect:SetHidden( false )

					EHT.EffectLerp:New( effect, "Color", LERP_INTERVAL, function( effect, key, lerp )
						effect:SetHidden( false )
						effect:ModifyColor( 0, 0, 0, 0, 1 - lerp )
					end, function( effect )
						effect:UnmodifyColor()
					end )
				elseif not active and activated[effect] then
					deactivated[effect] = true
					activated[effect] = nil
					effect:SetHidden( false )

					EHT.EffectLerp:New( effect, "Color", LERP_INTERVAL, function( effect, key, lerp )
						effect:SetHidden( false )
						effect:ModifyColor( 0, 0, 0, 0, lerp )
					end, function( effect, key, lerp )
						effect:SetHidden( true )
						effect:UnmodifyColor()
					end )
				end
			end
		end

		AddRadiusActionEffect( 917, "Follow player when in range", true, Action )
		AddRadiusActionEffect( 918, "Follow player when out of range", false, Action )
	end
end

do
	local function AddEyesEffect( id, name, texture, textureGlow, width, height, r, g, b, x1, x2, y1, y2 )
		width, height = width or 18, height or 18

		EHT.EffectType:New( id, name, {
			Category = CAT.DECO,
			CanPitch = true,
			Init = function( self )
				local p = self:AddParticle( texture, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
				if x1 then p:SetTextureCoords( x1, x2, y1, y2 ) end
				self:SetSize( width, height, height )
				self:SetColor( r, g, b, 1 )
				self:SetOrientation( 0, 0, 0 )
				self:SpawnAtPlayer( 210 )
			end,
		} )

		EHT.EffectType:New( id + 1, name .. " (Glowing)", {
			Category = CAT.DECO,
			CanPitch = true,
			Init = function( self )
				local p = self:AddParticle( textureGlow, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, true, false, false )
				if x1 then p:SetTextureCoords( x1, x2, y1, y2 ) end
				self:SetSize( width, height, height )
				self:SetColor( r, g, b, 1 )
				self:SetOrientation( 0, 0, 0 )
				self:SpawnAtPlayer( 210 )
			end,
			Update = function( self )
				self.Particles[1]:SetSampleProcessing( 1 + 0.8 * self:GetViewingAngleAlpha() )
			end,
		} )
	end

	AddEyesEffect( 919, "Eyes, Mischievous", TEXTURES.EYES_1, TEXTURES.EYES_1_GLOW, 18, 18, 0.7, 0.6, 0 )
	AddEyesEffect( 921, "Eyes, Watchful", TEXTURES.EYES_2, TEXTURES.EYES_2_GLOW, 20, 5, 0.9, 0.9, 0.9, 0, 1, 0, 0.35 )
end

AddStarCubeEffect( 923, "Dazzling", { TEXTURES.CIRCLE_SOFT, TEXTURES.CIRCLE_SOFT_2, TEXTURES.STARBURST_2, TEXTURES.CIRCLE_SOFT_2, TEXTURES.STARBURST_1 }, { 0.005, 0.01, 0.022, 0.008, 0.016 }, 4000, true )

do
	local LERP_INTERVAL = 1000

	local function Action(self, active, effects)
		local sizeX, sizeY, sizeZ = self:GetSize()
		local scale = sizeZ / 1000

		for _, effect in ipairs(effects) do
			if nil == active then
				effect:UnmodifySize()
			elseif active then
				effect:UnmodifySize()
				EHT.EffectLerp:New(effect, "Size", LERP_INTERVAL, function(effect, key, lerp)
					effect:ModifySize(zo_lerp(1, scale, lerp))
				end)
			else
				EHT.EffectLerp:New(effect, "Size", LERP_INTERVAL, function(effect, key, lerp)
					effect:ModifySize(zo_lerp(scale, 1, lerp))
				end, function(effect)
					effect:UnmodifySize()
				end)
			end
		end
	end

	AddRadiusActionEffect( 924, "Resize when in range", true, Action, false )
	AddRadiusActionEffect( 925, "Resize when out of range", false, Action, false )
end

-- 10/18/2019
EHT.EffectType:SetDefaultDateAdded( 1571379574 )

EHT.EffectType:New( 926, "Maelstrom, Apocrypha", {
	Category = CAT.ANIM,
	CanPitch = true,
	ResetOnColor = true,
	ResetOnOrient = true,
	Init = function( self )
		local total = 14

		for index = 1, total do
			local modulo = index % 4
			local texture = 0 == modulo and TEXTURES.PAPER_1 or 2 == modulo and TEXTURES.PAPER_2 or TEXTURES.PAPER_3
			modulo = zo_lerp( 0.25, 1, ( ( index % 6 ) / 4.5 ) % 1 )

			local p = self:AddParticle( texture,	0, 0, 0, 	0, 0, 0,	 modulo, modulo, modulo, 1, 	0, 0, 	true, false, false )
			p.roll = RAD90 * ( index % 6 ) / 6
			p:SetHidden( true )
			--p:SetSampleProcessing( 1.4 * modulo )
		end

		self:SetAutoPositionEnabled( false )
		self:SetAutoOrientationEnabled( false )
		self:SetAutoSizeEnabled( false )
		self:SetSize( 220, 220 )
		self:SetColor( 0.5, 0.5, 0.5, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 160 )
		self:Update()
	end,
	Update = function( self )
		local interval = GetLinearInterval( 2000 )
		local pitch, yaw, roll = self:GetOrientation()
		local sx, sy = self:GetSize()
		local yoffset = -0.5 * sy
		local x, y, z = self:GetPosition()
		local total = #self.Particles
		local radius = 0.3
		local sz = sx

		for index, p in ipairs( self.Particles ) do
			local theta = yaw + RAD360 * ( interval + ( ( index % 9 ) / 9 ) )
			local c, s = math.cos( theta ), math.sin( theta )
			local modulo = index % 4
			local pitchangle = ( -1 + modulo ) * theta
			local yawangle = ( 2 - modulo ) * theta
			local ppitch, pyaw, proll = EHT.Housing.TransformOrientation( pitch, yaw, roll, pitchangle, yawangle, 0 )
			local px, py, pz = EHT.Housing.TransformVector( pitch, yaw, roll, sx * radius * c, yoffset + sy * index / total, sz * radius * s )

			p:SetPositionAndOrientation( x + px, y + py, z + pz, ppitch, pyaw, proll )
			radius = 0.3 + 0.7 * ( index / total )
		end
	end,
	Reset = function( self )
		local sx, sy = self:GetSize()
		local scale = 0.2 * sx
		local scaleX, scaleY = 0.7 * scale, scale

		for index, p in ipairs( self.Particles ) do
			local c1 = 0.3 + 0.15 * ( index % 5 )
			local c2 = 1 - 0.1 * ( index % 3 )
			p:SetHidden( false )
			p:SetSize( scaleX * c1, scaleY * c2 )
		end

		self:Update()
	end,
} )

do
	local LERP_INTERVAL = 1000

	do
		local function OnLerpComplete( action, fadedIn, effect, key, lerp )
			local active = action.IsActionActive

			if true == active then
				local nextFade = not fadedIn

				zo_callLater( function()
					EHT.EffectLerp:New( effect, "Color", LERP_INTERVAL, function( effect, key, lerp )
						effect:ModifyColor( 0, 0, 0, 0, nextFade and ( 1 - lerp ) or lerp )
					end, function( effect, key, lerp )
						OnLerpComplete( action, nextFade, effect, key, lerp )
					end )
				end, 1 )
			elseif false == active then
				EHT.EffectLerp:New( effect, "Color", LERP_INTERVAL, function( effect, key, lerp )
					effect:ModifyColor( 0, 0, 0, 0, lerp )
				end )
			else
				EHT.EffectLerp:Delete( effect, "Color" )
				effect:ModifyColor( nil )
			end
		end

		local function Action( self, active, effects )
			local r, g, b, a = self:GetColor()

			for _, effect in ipairs( effects ) do
				OnLerpComplete( self, false, effect, key, lerp )
			end
		end

		AddRadiusActionEffect( 927, "Fade in/out when in range", true, Action )
		AddRadiusActionEffect( 928, "Fade in/out when out of range", false, Action )
	end
end

-- /sc StartChatInput( tostring( GetTimeStamp() ) )
--EHT.EffectType:SetDefaultDateAdded( 1573877490 )

AddAuroraSkyEffect( 929, "Aurora Borealis, Day", false )

do
	local et = AddRandomizedParticleEffect(
		930, "Shooting Stars", CAT.ANIM, TEXTURES.SHOOTING_STAR,
		5000, 5000, 5000,
		1, 1, 1, 1,
		0, 0.89, 0,
		0.25, 0.1, 0.25,
		1, 1, 1,
		0.05, 1, 2,
		true,
		10000, 10000,
		20, 40, 0, 0,
		0.8, 2,
		0.8, 0.8, 0.8, 0,
		1, 1, 1, 0,
		0, 0.8,
		0, 0, 0, 0,
		1800, -2400, 0,
		3000, -3600, 0,
		0, EHT.ParticleEmitter.ORIENTATIONS.VECTOR, false,
		EHT.ParticleEmitter.PATTERNS.PERIMETER, nil, 8000,
		false, false, nil, nil, nil,
		true, nil, true, nil,
		nil, nil,
		nil,
		nil,
		function( self )
			local e = self.Emitter
			e.MinSizeY, e.MaxSizeY = 400, 1200
			e.Pitch = -0.12 * math.pi
			e.MaxLocalRadius = 4000
			e.LocalOffsetY = 5000
			e:Reset()
		end
	)
	et.ResetOnColor = true
end

do
	local et = AddRandomizedParticleEffect(
		931, "Meteor Shower", CAT.ANIM, TEXTURES.SHOOTING_STAR,
		5000, 5000, 5000,
		1, 1, 1, 1,
		1, 0.89, 1,
		1, 0.1, 1,
		1, 1, 1,
		0.05, 20, 30,
		false,
		6000, 6000,
		40, 60, 0, 0,
		0.8, 2,
		0.8, 0.8, 0.8, 0,
		1, 1, 1, 0,
		0, 2,
		0, 0, 0, 0,
		-5000, -200, 0,
		-10000, -500, 0,
		0, EHT.ParticleEmitter.ORIENTATIONS.VECTOR, false,
		EHT.ParticleEmitter.PATTERNS.RANDOM, EHT.ParticleEmitter.ORIENTATIONS.VECTOR, 8000,
		false, false, nil, nil, nil,
		false, nil, false, nil,
		nil, nil,
		nil,
		nil,
		function( self )
			local e = self.Emitter
			e.MinSizeY, e.MaxSizeY = 500, 2000
			e.Pitch = -0.4 * math.pi
			e.MaxLocalRadius = 4000
			e.LocalOffsetY = 5000
			e:Reset()
		end
	)
	et.ResetOnColor = true
end

do
	local activeEffects = { }

	local function Update()
		local processed = 0

		for effect in pairs( activeEffects ) do
			if effect.Active and not effect.Deleted then
				effect:SetOrientation( FaceCameraPitch, FaceCameraYaw, FaceCameraRoll )
				processed = processed + 1
			else
				activeEffects[effect] = nil
			end
		end

		if 0 == processed then
			EVENT_MANAGER:UnregisterForUpdate( "EHT.ActionFX.FaceCamera" )
		end
	end

	local function Action( self, active, effects )
		for _, effect in ipairs( effects ) do
			if true == active then
				if not effect.OriginalPitch then
					effect.OriginalPitch, effect.OriginalYaw, effect.OriginalRoll = effect:GetOrientation()
				end

				activeEffects[effect] = true
			else
				activeEffects[effect] = nil

				if effect.OriginalPitch then
					effect:SetOrientation( effect.OriginalPitch, effect.OriginalYaw, effect.OriginalRoll )
					effect.OriginalPitch, effect.OriginalYaw, effect.OriginalRoll = nil, nil, nil
				end
			end
		end

		if active then
			EVENT_MANAGER:RegisterForUpdate( "EHT.ActionFX.FaceCamera", 1, Update )
		end
	end

	AddRadiusActionEffect( 932, "Face camera when in range", true, Action, false )
	AddRadiusActionEffect( 933, "Face camera when out of range", false, Action, false )
end

do
	local activeEffects = { }

	local function Update()
		local processed = 0

		for effect in pairs( activeEffects ) do
			if effect.Active and not effect.Deleted then
				effect:SetOrientation(EHT.World:FacePlayer(effect:GetPosition()))
				processed = processed + 1
			else
				activeEffects[effect] = nil
			end
		end

		if 0 == processed then
			EVENT_MANAGER:UnregisterForUpdate( "EHT.ActionFX.FacePlayer" )
		end
	end

	local function Action( self, active, effects )
		for _, effect in ipairs( effects ) do
			if true == active then
				if not effect.OriginalPitch then
					effect.OriginalPitch, effect.OriginalYaw, effect.OriginalRoll = effect:GetOrientation()
				end

				activeEffects[effect] = true
			else
				activeEffects[effect] = nil

				if effect.OriginalPitch then
					effect:SetOrientation( effect.OriginalPitch, effect.OriginalYaw, effect.OriginalRoll )
					effect.OriginalPitch, effect.OriginalYaw, effect.OriginalRoll = nil, nil, nil
				end
			end
		end

		if active then
			EVENT_MANAGER:RegisterForUpdate( "EHT.ActionFX.FacePlayer", 1, Update )
		end
	end

	AddRadiusActionEffect( 934, "Face player when in range", true, Action, false )
	AddRadiusActionEffect( 935, "Face player when out of range", false, Action, false )
end

-- 6/1/2020
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1590382277 )

EHT.EffectType:New( 936, "Glass, Dingy", {
	Category = CAT.BUILD,
	CanPitch = true,
	Init = function( self )
		local p = self:AddParticle( TEXTURES.GLASS_1,		0, 0, 0,	0, 0, 0,	1, 1, 1, 0.7,		1, 1,	true, false, false )
		p:SetSampleProcessing( 0.5, 0 )
		self:SetSize( 1000, 1000, 1000 )
		self:SetColor( 0.08, 0.46, 1, 1 )
		self:SetOrientation( 0, 0, 0 )
		self:SpawnAtPlayer( 500 )
	end,
	Reset = function( self )
		self:Update()
		local p = self.Particles[1]
		local sx, sy = self:GetSize()
		if sx > sy then
			local ratio = sy / sx
			p:SetTextureCoords( 0, 1, 0, ratio )
		elseif sy > sx then
			local ratio = sx / sy
			p:SetTextureCoords( 0, ratio, 0, 1 )
		else
			p:SetTextureCoords( 0, 1, 0, 1 )
		end
	end,
} )

EHT.EffectType:New( 937, "Grass, Sparse", {
	Category = CAT.LAND,
	CanPitch = true,
	Init = function( self )
		self:AddParticle( TEXTURES.GRASS_2,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
		self:SetSize( 400, 400, 400 )
		self:SetColor( 0.1, 0.8, 0.25, 0.8 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 5 )
	end,
} )

EHT.EffectType:New( 938, "Grass, Patchy", {
	Category = CAT.LAND,
	CanPitch = true,
	Init = function( self )
		self.OrderDrawLevelByIndex = true
		self.TileX, self.TileY = 0, 0
		for index = 1, 2 do
			self:AddParticle( TEXTURES.GRASS_3,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, true )
		end
		local p = self:AddParticle( TEXTURES.NOISE_2,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )
		p:SetDodge( true )
		self:SetSize( 512, 512, 512 )
		self:SetColor( 0.85, 0.6, 0.2, 0.8 )
		self:SetOrientation( math.rad( 90 ), 0, 0 )
		self:SpawnAtPlayer( 5 )
	end,
	Reset = function( self )
		local p = self.Particles
		local r, g, b, a = self:GetColor()
		p[1]:Tile( 384, 384 )
		--p[2]:Tile( -314, -314, 100, 200 )
		p[2]:Tile( -1000, -1000, 100, 200 )
		self:Update()
		p[2]:SetVertexColors( 1, r, g, b, a )
		p[2]:SetVertexColors( 2, r, g, b, a )
		p[2]:SetVertexColors( 4, r, g, b, 0 )
		p[2]:SetVertexColors( 8, r, g, b, 0 )
	end,
} )

-- 8/8/2020
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1596939359 )

EHT.EffectType:New( 939, "Glitter, Falling", {
	Category = CAT.ANIM,
	Init = function( self )
		self.MinSize = 10
		self:SetSize( 100, 400, 100 )
		self:SetColor( 0.5, 0.65, 1, 1 )
		self:SpawnAtPlayer( 200 )
	end,
	Update = function( self )
		if self.Emitter then
			self.Emitter:Update()

			local ft = FrameTime
			for _, p in ipairs( self.Particles ) do
				local interval = ( ft - p.BaseTime ) / 500
				if not p.PitchVelocity or interval <= 0.01 then
					p.PitchVelocity = math.rad( math.random( -360, 360 ) )
					p.Yaw = math.rad( math.random( -180, 180 ) )
				end
				p.Pitch = ( p.PitchVelocity * interval ) % RAD360
				p:SetSampleProcessing( zo_lerp( 0.1, 2, p.Pitch / RAD360 ) ) 
			end
		end
	end,
	Reset = function( self )
		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()
		sz = sx

		local o = { }
		o.Texture = ""
		o.AutoOrientation = EHT.ParticleEmitter.ORIENTATIONS.MANUAL
		o.Yaw = 0
		o.EmissionX, o.EmissionY, o.EmissionZ = x, y + 0.5 * sy, z
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0.5 * sx, 0, 0.5 * sz
		o.ReuseActiveEmissions = false
		o.MaxActiveEmissions = 50
		o.MinActiveEmissions = 10
		o.Localized = false
		o.EmissionFrequency = 1
		o.EmissionPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
		o.EmissionInterval = 1
		o.EmissionIntervalOffset = 0
		o.MaxOffsetX = sx
		o.MaxOffsetY = 0.501 * sy
		o.MaxOffsetZ = sz
		o.WindFactor = 0
		o.MinSize = math.ceil(zo_clamp(zo_lerp(1, 40, EaseIn2(sx / 20000)), 1, 40))
		o.MaxSize = o.MinSize
		o.MinGrowth = 0
		o.MaxGrowth = 0
		local avgTtl = math.abs( sy / zo_clamp( sy * -0.3, -250, -50 ) ) * 1000
		o.MaxTTL = 1.2 * avgTtl
		o.MinTTL = 0.8 * avgTtl
		o.MinSampleRGB = 1
		o.MaxSampleRGB = 1
		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r * 0.9, g * 0.9, b * 0.9, a
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r, g, b, a
		o.ColorShift = 0
		o.AlphaShift = 0
		o.MinRotation = -math.pi
		o.MaxRotation = math.pi
		o.MinAngularVelocity = 2 * math.pi
		o.MaxAngularVelocity = 10 * math.pi
		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM
		o.MaxVectorX = 10
		o.MaxVectorY = zo_clamp( sy * -0.3, -250, -50 )
		o.MaxVectorZ = 10
		o.MinVectorX = -10
		o.MinVectorY = 0.5 * o.MaxVectorY
		o.MinVectorZ = -10
		o.InvertVectorX = false
		o.InvertVectorY = false
		o.InvertVectorZ = false
		o.UniformVectors = false
		o.LockAtRange = false
		o.RecycleAtRange = true
		o.UseTextureUVAnimation = false
		o.UseCellAnimation = false
		o.CellsStatic = false
		o.CellsFPS = nil
		o.CellsX = 0
		o.CellsY = 0
		o.BezierAxisY = 0

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end
		self.Emitter:Update()
	end,
} )

do
	AddSkyEffect(
		940, "Clear Sky",
		-- Options
		{ R = 0.5, G = 0.74, B = 1, },
		-- Side Textures Table
		{
			{
				Texture = TEXTURES.SOLID, Stretch = true, R = 1, G = 1, B = 1, A = 1,
			},
		},
		-- Top Texture Filename
		TEXTURES.SKY_TOP_FADE_OUT,
		-- Reset Handler
		function( self )
			local sx, sy, sz = self:GetSize()
			local r, g, b, a = self:GetColor()
			local ceilR, ceilG, ceilB = r * 0.8, g * 0.8, b * 0.8
			local floorR, floorG, floorB = r, g, b
			local faces

			faces = self.TextureFaces[1]
			for _, face in ipairs( faces ) do
				face:SetCanModifyColor( true )
				face:SetColor( ceilR, ceilG, ceilB, a )
				face:SetCanModifyColor( false )
				face:SetAutoColorEnabled( false )
			end

			local LERP = 1.02
			faces = self.TextureFaces[2]
			for _, face in ipairs( faces ) do
				face:SetCanModifyColor( true )
				face:SetVertexColors(1 + 2, zo_lerp(floorR, ceilR, LERP), zo_lerp(floorG, ceilG, LERP), zo_lerp(floorB, ceilB, LERP), a)
				face:SetVertexColors(4 + 8, floorR, floorG, floorB, a)
				face:SetCanModifyColor( false )
				face:SetAutoColorEnabled( false )
			end

			faces = self.TextureFaces[3]
			for _, face in ipairs( faces ) do
				face:SetCanModifyColor( true )
				face:SetColor( floorR, floorG, floorB, a )
				face:SetCanModifyColor( false )
				face:SetAutoColorEnabled( false )
			end
		end
	)
end

do
	AddSkyEffect(
		941, "Azura's Dawn",
		-- Options
		{ R = 0.5, G = 0.74, B = 1, A = 1 },
		-- Side Textures Table
		{
			{
				Texture = TEXTURES.CLOUDS_3, Stretch = true, R = 1, G = 1, B = 1, A = 1,
			},
			{
				Texture = TEXTURES.CLOUDS_3, Stretch = true, R = 1, G = 1, B = 1, A = 1,
			},
			{
				Texture = TEXTURES.SOLID, Stretch = true, R = 1, G = 1, B = 1, A = 1,
			},
		},
		-- Top Texture Filename
		TEXTURES.SKY_TOP_FADE_OUT,
		-- Reset Handler
		function( self )
			local sx, sy, sz = self:GetSize()
			local r, g, b, a = self:GetColor()
			local ceilR, ceilG, ceilB = r, g, b
			local floorR, floorG, floorB = r * 0.65, g * 0.65, b * 0.65
			local faces

			faces = self.TextureFaces[1]
			for _, face in ipairs( faces ) do
				face:SetCanModifyColor( true )
				face:SetColor( ceilR, ceilG, ceilB, a )
				face:SetCanModifyColor( false )
				face:SetAutoColorEnabled( false )
			end

			faces = self.TextureFaces[2]
			for _, face in ipairs( faces ) do
				face:SetTextureWrapping( true )
				face:SetAutoColorEnabled( false )
				face:SetCanModifyColor( true )
				face:SetVertexColors( 1 + 2, 1, 1, 1, 0 )
				face:SetVertexColors( 4 + 8, 1, 1, 1, a * 0.4 )
				face:SetSampleProcessing( 0.3, 0 )
				face:SetCanModifyColor( false )
			end

			faces = self.TextureFaces[3]
			for _, face in ipairs( faces ) do
				face:SetTextureWrapping( true )
				face:SetAutoColorEnabled( false )
				face:SetCanModifyColor( true )
				face:SetVertexColors( 1 + 2, 1, 1, 1, 0 )
				face:SetVertexColors( 4 + 8, 1, 1, 1, a )
				face:SetAdditive( true )
				face:SetSampleProcessing( 1, 0 )
				face:SetCanModifyColor( false )
			end

			faces = self.TextureFaces[4]
			for _, face in ipairs( faces ) do
				face:SetAutoColorEnabled( false )
				face:SetCanModifyColor( true )
				face:SetVertexColors( 1 + 2, ceilR, ceilG, ceilB, a )
				face:SetVertexColors( 4 + 8, floorR, floorG, floorB, a )
				face:SetCanModifyColor( false )
			end

			faces = self.TextureFaces[5]
			for _, face in ipairs( faces ) do
				face:SetAutoColorEnabled( false )
				face:SetCanModifyColor( true )
				face:SetColor( floorR, floorG, floorB, a )
				face:SetCanModifyColor( false )
			end
		end,
		-- Update
		function( self )
			local interval = GetLinearInterval( 200000 )
			--ProjectCylinderTextureFaces(self.TextureFaces[2], 0, interval, 3 + interval, 0, 1 )
			ProjectCylinderTextureFaces(self.TextureFaces[2], 0, interval, 2 + interval, 0, 0.9 )
			interval = GetLinearInterval( 120000 )
			--ProjectCylinderTextureFaces(self.TextureFaces[3], 0, 0.35 - interval, 3.35 - interval, 0, 0.95 )
			ProjectCylinderTextureFaces(self.TextureFaces[3], 0, 0.4 - interval, 1.4 - interval, 0, 0.6 )

			local newWeight = 2 * GetLoopInterval( 30000 )
			local weight = self.LayerWeight
			if not weight or round( weight, 2 ) ~= round( newWeight, 2 ) then
				weight = newWeight
				self.LayerWeight = weight

				weight = 2 * weight
				for _, face in ipairs( self.TextureFaces[2] ) do
					face:SetSampleProcessing( weight, 0 )
				end
				
				weight = 2 - weight
				for _, face in ipairs( self.TextureFaces[3] ) do
					face:SetSampleProcessing( weight, 0 )
				end
			end
		end
	)
end

AddMusicEffect( 942, "Music, Peaceful", OVERRIDE_MUSIC_MODE_SCRYING )
AddMusicEffect( 943, "Music, Battle", OVERRIDE_MUSIC_MODE_DUELING )
AddMusicEffect( 944, "Music, Melancholy", OVERRIDE_MUSIC_MODE_CREDITS )

AddFadeToEffect( CAT.ANIM, 945, "Vignette", 0, 0, 0, TEXTURES.VIGNETTE )

EHT.EffectType:New( 946, "Electricity, Globe", {
	Category = CAT.ANIM,
	Init = function( self )
		self:SetSize( 300, 300, 300 )
		self:SetColor( 0.65, 0.9, 1, 1 )
		self:SetContrast( 2 )
		self:SpawnAtPlayer( 200 )
	end,
	Update = function( self )
		if self.Emitter then self.Emitter:Update() end
	end,
	Reset = function( self )
		local ttl, maxEmissions, maxSegments = 900, 100, 200
		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()
		local previousSizeX = self.previousSizeX
		self.previousSizeX = sx
		local radius = previousSizeX ~= sx and sx or sy
		self:SetSize( radius, radius, radius )
		local sphericalArea = 4 * math.pi * radius * radius
		local maxParticleDimension = math.sqrt( sphericalArea / maxSegments )

		local o = { }
		o.Texture = { TEXTURES.ELECTRICITY_01, TEXTURES.ELECTRICITY_02, TEXTURES.ELECTRICITY_03, TEXTURES.ELECTRICITY_04 }
		o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.CAMERA, yaw
		o.EmissionX, o.EmissionY, o.EmissionZ = x, y, z
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0.5 * sx, 0.5 * sx, 0.5 * sx
		o.ReuseActiveEmissions, o.MaxActiveEmissions, o.MaxEmissionSegments = false, maxEmissions, maxSegments
		o.MinActiveEmissions = o.MaxActiveEmissions
		o.EmissionFrequency = 100
		o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.SPHERICAL, 1, 0
		o.MaxOffset = radius
		o.WindFactor = 0
		o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 1, 5, 0.5 * maxParticleDimension, 0.7 * maxParticleDimension
		o.MinTTL, o.MaxTTL = 0.35 * ttl, ttl
		local co = 0.12 -- Max color offset
		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r - co, g - co, b - co, 0
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r + co, g + co, b + co, 0
		o.ColorShift, o.AlphaShift = 0, 0.95
		o.MinSampleRGB, o.MaxSampleRGB, o.MinSampleAlpha, o.MaxSampleAlpha = 2, 3.5, 0, 0
		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.LINEAR
		o.MinVectorX, o.MinVectorY, o.MinVectorZ = 0, 0, 0
		o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 0, 0, 0
		o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = false, false, false, false
		o.UseTextureUVAnimation = false
		o.MinRotation, o.MaxRotation = -math.pi, math.pi

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end
	end,
} )

EHT.EffectType:New( 947, "Electricity, Field", {
	Category = CAT.ANIM,
	CanPitch = true,
	Init = function( self )
		self:SetSize( 1000, 1000, 1000 )
		self:SetOrientation( 0.5 * math.pi, 0, 0 )
		self:SetColor( 0.65, 0.9, 1, 1 )
		self:SetContrast( 2 )
		self:SpawnAtPlayer( 50 )
	end,
	Update = function( self )
		if self.Emitter then self.Emitter:Update() end
	end,
	Reset = function( self )
		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()
		local maxDim = math.max( sx, sy, sz )
		local avgDim = ( sx + sy + sz ) / 3
		local ttl = 500

		local o = { }
		o.Texture = TEXTURES.ELECTRICITY_CELLS
		o.UseCellAnimation, o.RandomizeCellAnimation, o.CellsStatic, o.CellsFPS, o.CellsX, o.CellsY = true, true, false, 16, 4, 4
		o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.CAMERA, yaw
		o.EmissionX, o.EmissionY, o.EmissionZ = x, y, z
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0.5 * sx, 0.5 * sy, 0.5 * sz
		o.ReuseActiveEmissions, o.MaxActiveEmissions, o.MinActiveEmissions = false, 80, 50
		o.EmissionFrequency = 20
		o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.PLANAR, 1, 0
		o.MaxOffset = maxDim
		o.WindFactor = 0
		o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = 0.06 * avgDim, 0.1 * avgDim, 0, 0 -- 0.02 * avgDim, 0.04 * avgDim
		o.MinTTL, o.MaxTTL = ttl, ttl * 0.5
		local co = 0 -- 0.12 -- Max color offset
		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r - co, g - co, b - co, 0.2
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r + co, g + co, b + co, 0.2
		o.ColorShift, o.AlphaShift = 0, 1
		o.MinRotation, o.MaxRotation = 0, 0 -- -0.5 * math.pi, 0.5 * math.pi
		o.MinAngularVelocity, o.MaxAngularVelocity = 0, 0 -- math.pi * -3, math.pi * 3
		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.LINEAR
		o.MinVectorX, o.MinVectorY, o.MinVectorZ = 0, 0, 0
		o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 0, 0, 0
		o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = false, false, false, false
		o.MinSampleRGB, o.MaxSampleRGB, o.MinSampleAlpha, o.MaxSampleAlpha = 1.0, 3.0, 0, 0
		o.UseTextureUVAnimation = false

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end
	end,
} )

local function AddSwirlingEffect( effectIndex, effectName, textures, options )
	local spherical = options.spherical == true
	local defaultColor = options.color or { 1, 1, 1, 1 }
	local defaultContrast = options.contrast or 1
	local maxTTL = options.ttl or 600
	local maxParticles = options.particles or 90
	local numEmissions = options.emissions or 3
	local particleSizeCoeff = options.sizeCoeff or 0.5
	local startSizeCoeff = options.startSizeCoeff or 0.8
	local minStartSizeCoeff = options.minStartSizeCoeff or startSizeCoeff
	local endSizeCoeff = options.endSizeCoeff or -0.4
	local angleIncrement = options.angleIncrement or 18
	local minAngle = options.minAngle or 4
	local maxAngle = options.maxAngle or 6
	local minAngleInterval = options.minInterval or 6000
	local maxAngleInterval = options.maxInterval or 12000
	local minRGB = options.minRGB or 1
	local maxRGB = options.maxRGB or 1
	local rangeRGB = maxRGB - minRGB
	local pcoeff = 0.2
	local co = 0.12 -- Max color offset

	return EHT.EffectType:New( effectIndex, effectName, {
		Category = CAT.ANIM,
		Init = function( self )
			self:SetSize( 300, 300, 300 )
			self:SetColor( defaultColor[1], defaultColor[2], defaultColor[3], defaultColor[4] )
			self:SetContrast( defaultContrast )
			self:SpawnAtPlayer( 200 )

			local x, y, z = self:GetPosition()
			local pitch, yaw, roll = self:GetOrientation()
			local r, g, b, a = self:GetColor()
			local sx, sy, sz = self:GetSize()
			local px, py, pz = pcoeff * sx, pcoeff * sy, pcoeff * sz

			local o = { }
			o.Yaw = 0
			o.Texture = textures
			o.PreserveTextureCoords = true
			o.AutoOrientation = EHT.ParticleEmitter.ORIENTATIONS.CAMERA
			o.EmissionX, o.EmissionY, o.EmissionZ = x, y, z
			o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0, 0, 0
			o.ReuseActiveEmissions, o.MaxActiveEmissions = false, maxParticles
			o.MinActiveEmissions = 3
			o.EmissionFrequency = options.EmissionFrequency or 50
			o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.LINEAR, 1, 0
			o.MaxOffset = 100000
			o.WindFactor = 0
			o.MinSize, o.MaxSize, o.MinGrowth, o.MaxGrowth = px, px, 0, 0
			o.MinSizeY, o.MaxSizeY, o.MinGrowthY, o.MaxGrowthY = px, px, 0, 0
			o.MinTTL, o.MaxTTL = 0.75 * maxTTL, maxTTL
			o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r - co, g - co, b - co, 0
			o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = r + co, g + co, b + co, 0
			o.ColorShift, o.AlphaShift = 0, 1.5
			o.MinSampleRGB, o.MaxSampleRGB, o.MinSampleAlpha, o.MaxSampleAlpha = minRGB, maxRGB, 0, 0
			o.VectorPattern = EHT.ParticleEmitter.PATTERNS.LINEAR
			o.MinVectorX, o.MinVectorY, o.MinVectorZ = 0, 0, 0
			o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 0, 0, 0
			o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = false, false, false, false
			o.UseTextureUVAnimation = false
			o.MinRotation, o.MaxRotation = -math.pi, math.pi
			
			local sourceIndex = 1
			local sources = { }
			for index = 1, numEmissions do
				local angle = 2 * math.pi * ( ( index - 1 ) / numEmissions )
				local source = 
				{
					pitch = angle,
					yaw = angle,
					vectorP = 0,
					vectorY = 0,
					nextVectorUpdate = 0,
					nextRotation = 0,
					nextIndex = 0,
				}
				table.insert( sources, source )
			end
			local numSources = #sources
			local nextVectorUpdate = 0
			self.Sources = sources

			o.OnEmission = function( self, p )
				local source = sources[sourceIndex]

				local ft = FrameTime
				if source.nextVectorUpdate <= ft then
					local targetPitch, targetYaw = math.rad( math.random( minAngle, maxAngle ) ), math.rad( math.random( minAngle, maxAngle ) )
					source.vectorP, source.vectorY = 0.35 * source.vectorP + 0.65 * targetPitch, 0.35 * source.vectorY + 0.65 * targetYaw
					if math.random() > 0.5 then source.vectorP = -source.vectorP end
					source.pitch = source.pitch + RAD180
					source.nextVectorUpdate = ft + math.random( minAngleInterval, maxAngleInterval )
				end

				local pitch, yaw = source.pitch, source.yaw
				pitch = ( pitch + source.vectorP ) % RAD360
				yaw = ( yaw + source.vectorY ) % RAD360
				source.pitch, source.yaw = pitch, yaw

				source.nextIndex = ( source.nextIndex + 1 ) % 8
				local radiusCoeff = 1 - 0.04 * ( source.nextIndex / 7 )
				local offsetX = radiusCoeff * self.maxOffsetX * math.sin( pitch ) * math.sin( yaw )
				local offsetY = radiusCoeff * self.maxOffsetY * math.cos( pitch )
				local offsetZ = radiusCoeff * self.maxOffsetZ * math.sin( pitch ) * math.cos( yaw )

				local pX, pY, pZ = self.EmissionX + offsetX, self.EmissionY + offsetY, self.EmissionZ + offsetZ
				p:SetPosition( pX, pY, pZ )

				source.nextRotation = ( ( source.nextRotation + 1 ) % 3 )
				p:SetTextureRotation( source.nextRotation * math.rad( 130 ) )

				sourceIndex = sourceIndex + 1
				if sourceIndex > numSources then sourceIndex = 1 end
			end

			self.Emitter = EHT.ParticleEmitter:New( self, o )
			self.Emitter.maxOffsetX, self.Emitter.maxOffsetY, self.Emitter.maxOffsetZ = 0.5 * sx, 0.5 * sy, 0.5 * sz
		end,
		Update = function( self )
			if self.Emitter then self.Emitter:Update() end
		end,
		Reset = function( self )
			local sx, sy, sz = self:GetSize()
			if spherical then
				if self.previousSizeX then
					if self.previousSizeX ~= sx then
						self:SetSize( sx, sx, sx )
					else
						self:SetSize( sy, sy, sy )
					end
				end

				self.previousSizeX = sx
			end

			local emitter = self.Emitter
			if emitter then
				emitter.maxOffsetX, emitter.maxOffsetY, emitter.maxOffsetZ = 0.5 * sx, 0.5 * sy, 0.5 * sz

				local r, g, b, a = self:GetColor()
				emitter.MinColorR, emitter.MinColorG, emitter.MinColorB, emitter.MinColorA = r - co, g - co, b - co, 0
				emitter.RangeColorR, emitter.RangeColorG, emitter.RangeColorB, emitter.RangeColorA = ( r + co ) - emitter.MinColorR, ( g + co ) - emitter.MinColorG, ( b + co ) - emitter.MinColorB, 0

				local x, y, z = self:GetPosition()
				emitter.EmissionX, emitter.EmissionY, emitter.EmissionZ = x, y, z

				local radiusXZ = 0.5 * ( emitter.maxOffsetX + emitter.maxOffsetZ )
				emitter.MinSize = 3 * radiusXZ * math.sin( math.rad( maxAngle ) * 0.5 )
				emitter.RangeSize = 0
				emitter.MinGrowth = -0.5 * radiusXZ * math.sin( math.rad( maxAngle ) * 0.5 )
				emitter.MaxGrowth = 0
				emitter.RangeGrowth = 0

				local radiusY = emitter.maxOffsetY
				emitter.MinSizeY = 3 * radiusY * math.sin( math.rad( maxAngle ) * 0.5 )
				emitter.RangeSizeY = 0
				emitter.MinGrowthY = -0.5 * radiusY * math.sin( math.rad( maxAngle ) * 0.5 )
				emitter.MaxGrowthY = 0
				emitter.RangeGrowthY = 0
			end
		end,
	} )
end

do
	local options =
	{
		spherical = true, emissionFrequency = 15, particles = 200, emissions = 2, ttl = 1200,
		color = { 0.65, 0.9, 1, 1 }, minRGB = 2, maxRGB = 4, contrast = 2,
		minAngle = 6, maxAngle = 6, minInterval = 6000, maxInterval = 18000,
	}
	AddSwirlingEffect( 948, "Electricity Globe, Swirling", { TEXTURES.ELECTRICITY_01, TEXTURES.ELECTRICITY_02, TEXTURES.ELECTRICITY_03, TEXTURES.ELECTRICITY_04 }, options )
end

do
	local options =
	{
		spherical = true, emissionFrequency = 15, particles = 100, emissions = 3, ttl = 600,
		color = { 0.65, 0.9, 1, 1 }, minRGB = 2, maxRGB = 4, contrast = 2,
		minAngle = 6, maxAngle = 6, minInterval = 1000, maxInterval = 3000,
	}
	AddSwirlingEffect( 949, "Electricity Globe, Crawling", { TEXTURES.ELECTRICITY_01, TEXTURES.ELECTRICITY_02, TEXTURES.ELECTRICITY_03, TEXTURES.ELECTRICITY_04 }, options )
end

do
	local options =
	{
		spherical = false, emissionFrequency = 15, particles = 200, emissions = 2, ttl = 1200,
		color = { 0.65, 0.9, 1, 1 }, minRGB = 2, maxRGB = 4, contrast = 2,
		minAngle = 6, maxAngle = 6, minInterval = 6000, maxInterval = 18000,
	}
	AddSwirlingEffect( 950, "Electricity, Swirling", { TEXTURES.ELECTRICITY_01, TEXTURES.ELECTRICITY_02, TEXTURES.ELECTRICITY_03, TEXTURES.ELECTRICITY_04 }, options )
end

do
	local options =
	{
		spherical = false, emissionFrequency = 15, particles = 100, emissions = 3, ttl = 600,
		color = { 0.65, 0.9, 1, 1 }, minRGB = 2, maxRGB = 4, contrast = 2,
		minAngle = 6, maxAngle = 6, minInterval = 1000, maxInterval = 3000,
	}
	AddSwirlingEffect( 951, "Electricity, Crawling", { TEXTURES.ELECTRICITY_01, TEXTURES.ELECTRICITY_02, TEXTURES.ELECTRICITY_03, TEXTURES.ELECTRICITY_04 }, options )
end

do
	local options =
	{
		spherical = false, emissionFrequency = 100, particles = 20, emissions = 1, ttl = 400,
		color = { 0.65, 0.9, 1, 1 }, minRGB = 2, maxRGB = 4, contrast = 2,
		minAngle = 15, maxAngle = 15, minInterval = 800, maxInterval = 800,
	}
	AddSwirlingEffect( 952, "Electricity, Continuous Arc", { TEXTURES.ELECTRICITY_01, TEXTURES.ELECTRICITY_02, TEXTURES.ELECTRICITY_03, TEXTURES.ELECTRICITY_04 }, options )
end

local function AddEnergyStreamEffect( id, name, rotation, defaultSize, defaultColor, maxVertexAlpha )
	return EHT.EffectType:New( id, name, {
		Category = CAT.ANIM,
		CanPitch = true,
		Init = function( self )
			self.AnimInterval = 7500
			self.AnimIntervalOffset = math.random( 0, self.AnimInterval )
			self.ConstX = { 0, 0.25, 0.5, 0.75 }
			self.CoeffX = { 100, 50, 200, 100 }
			self.CoeffY = { 4, 4, 4, 4 }

			self:SetSize( unpack( defaultSize ) )
			self:SetColor( unpack( defaultColor ) )
			self:SpawnAtPlayer( 150 )

			for index = 1, 4 do
				local p = self:AddParticle( TEXTURES.LIGHTNING_LINES,	0, 0, 0,	0, 0, 0,		1, 1, 1, 1,		1, 1,	true, false, true )
			end
		end,
		Update = function( self )
			local anim = GetLinearInterval( self.AnimInterval, self.AnimIntervalOffset )
			local sample = 2 + Ease2( 0.5 * ( GetLoopInterval( 1480 ) + GetLoopInterval( 1170 ) ) )

			for index = 1, 4 do
				local p = self.Particles[index]
				p:RotateCoords( rotation, self.ConstX[index] + anim, 0.125 + ( index - 1 ) * 0.25, self.CoeffX[index], self.CoeffY[index] )
				p:SetSampleProcessing( sample, 0 )
			end
		end,
		Reset = function( self )
			self:Update()

			if maxVertexAlpha then
				local r, g, b, a = self:GetColor()
				for _, p in ipairs( self.Particles ) do
					for index = 1, 4 do
						p:SetVertexColors( 2 ^ ( index - 1 ), r, g, b, a * maxVertexAlpha[index] )
					end
				end
			end
		end,
	} )
end

AddEnergyStreamEffect( 953, "Energy Stream, Horizontal", 0, { 400, 50, 50 }, { 0.5, 0.85, 1, 1 } )
AddEnergyStreamEffect( 954, "Energy Stream, Vertical", 0.5 * math.pi, { 50, 400, 400 }, { 0.5, 0.85, 1, 1 } )
AddEnergyStreamEffect( 955, "Energy Outlet, Horizontal", 0, { 400, 50, 50 }, { 0.5, 0.85, 1, 1 }, { 0, 1, 0, 1 } )
AddEnergyStreamEffect( 956, "Energy Outlet, Vertical", 0.5 * math.pi, { 50, 400, 400 }, { 0.5, 0.85, 1, 1 }, { 0, 0, 1, 1 } )
AddEnergyStreamEffect( 957, "Energy Inlet, Horizontal", 0, { 400, 50, 50 }, { 0.5, 0.85, 1, 1 }, { 1, 0, 1, 0 } )
AddEnergyStreamEffect( 958, "Energy Inlet, Vertical", 0.5 * math.pi, { 50, 400, 400 }, { 0.5, 0.85, 1, 1 }, { 1, 0, 0, 0 } )

do
	local options =
	{
		spherical = true, emissionFrequency = 30, particles = 60, emissions = 4, ttl = 700,
		color = { 0.5, 0.7, 0.85, 1 }, minRGB = 2, maxRGB = 4, contrast = 2,
		minAngle = 18, maxAngle = 18, minInterval = 2000, maxInterval = 3000,
	}
	AddSwirlingEffect( 959, "Electricity Globe, Crackling", { TEXTURES.ELECTRICITY_01, TEXTURES.ELECTRICITY_02, TEXTURES.ELECTRICITY_03, TEXTURES.ELECTRICITY_04 }, options )
end

EHT.EffectType:New( 960, "Cinder Rain", {

	Category = CAT.WEATHER,
	MinSize = { 50, 200, 50 },

	Init = function( self )
		self:SetSize( 2000, 2000, 2000 )
		self:SetColor( 1, 0.5, 0.15, 1 )
		self:SpawnAtPlayer( 500 )
		self:SetCameraFacing( true )
	end,

	Update = function( self )
		if self.Emitter then self.Emitter:Update() end
	end,

	Reset = function( self )
		self:Update()

		local x, y, z = self:GetPosition()
		local pitch, yaw, roll = self:GetOrientation()
		local r, g, b, a = self:GetColor()
		local sx, sy, sz = self:GetSize()
		local maxDim = math.max( sx, sy, sz )
		local ttl = 10000 * sy / 150

		local o = { }
		o.Texture = TEXTURES.ASH_SEQ_1
		o.WindFactor = 0
		o.AutoOrientation, o.Yaw = EHT.ParticleEmitter.ORIENTATIONS.CAMERA, yaw
		o.EmissionX, o.EmissionY, o.EmissionZ = x, y + 0.49 * sy, z
		o.MaxEmissionRadiusX, o.MaxEmissionRadiusY, o.MaxEmissionRadiusZ = 0.45 * sx, 0, 0.45 * sx
		o.ReuseActiveEmissions, o.MaxActiveEmissions = false, 20
		o.MinActiveEmissions = 1
		o.EmissionFrequency = 250
		o.EmissionPattern, o.EmissionInterval, o.EmissionIntervalOffset = EHT.ParticleEmitter.PATTERNS.RANDOM, 20000, 0
		o.MaxOffsetX, o.MaxOffsetY, o.MaxOffsetZ = 0.5 * sx, 0.5 * sy, 0.5 * sx
		o.MaxSize = zo_clamp( 0.1 * sx, 5, 50 )
		o.MinSize = 0.5 * o.MaxSize
		o.MinGrowth, o.MaxGrowth = 0, 0
		o.MinTTL, o.MaxTTL = 0.8 * ttl, ttl
		o.MinSampleRGB, o.MaxSampleRGB = 2, 8
		o.MinColorR, o.MinColorG, o.MinColorB, o.MinColorA = r, g, b, 0
		o.MaxColorR, o.MaxColorG, o.MaxColorB, o.MaxColorA = 0.98 * r, 0.98 * g, 0.98 * b, 0
		o.ColorShift, o.AlphaShift = -0.9, 3
		o.MinRotation, o.MaxRotation, o.MinAngularVelocity, o.MaxAngularVelocity = -math.pi, math.pi, -4 * math.pi, 4 * math.pi

		o.VectorPattern = EHT.ParticleEmitter.PATTERNS.SPIRAL
		o.MinVectorX, o.MinVectorY, o.MinVectorZ = -0.05 * sx, math.max( -0.2 * sy, -200 ), -0.05 * sx
		o.MaxVectorX, o.MaxVectorY, o.MaxVectorZ = 0.05 * sx, math.max( -0.15 * sy, -150 ), 0.05 * sx
		o.InvertVectorX, o.InvertVectorY, o.InvertVectorZ, o.UniformVectors = false, false, false, false

		o.UseCellAnimation, o.CellsStatic, o.CellsFPS, o.CellsX, o.CellsY = true, false, nil, 8, 8
		o.LockAtRange, o.RecycleAtRange = false, true

		if not self.Emitter then
			self.Emitter = EHT.ParticleEmitter:New( self, o )
		else
			self.Emitter:Initialize( o )
		end
	end,

} )

local function AddSphericalEffect( id, name, category, defaultSize, defaultColor, texture, impenetrable, soundCallback )
	return EHT.EffectType:New( id, name, {
		Category = category,
		CanPitch = false,
		Init = function( self )
			self.inside = nil
			self.LoopInterval = 20000
			self:SetAutoSizeEnabled( false )
			self:SetSize( unpack( defaultSize ) )
			self:SetColor( unpack( defaultColor ) )
			self:SpawnAtPlayer( defaultSize[2] * 0.5, nil, defaultSize[1] * -0.65 )

			local p1 = self:AddParticle( texture,		0, 0, 0,	0, 0, 0,		1, 1, 1, 1,				0.5, 0.5,	true, false, false )
			p1:SetSampleProcessing( 1.8 )
			local p2 = self:AddParticle( texture,		0, 0, 0,	0, 0, 0,		0.5, 0.5, 0.5, 1,		0.5, 0.5,	true, false, false )
			p2:SetSampleProcessing( 1.3 )

			local p1 = self:AddParticle( texture,		0, 0, 0,	0, 0, 0,		1, 1, 1, 1,				0.5, 0.5,	false, false, false )
			p1:SetHidden( true )
			p1:SetAlpha( 0 )
			p1:SetSampleProcessing( 1.8 )
			p1:SetAutoDrawLevelEnabled( false )
			p1.Texture:SetDrawLayer( DL_OVERLAY )

			local p2 = self:AddParticle( texture,		0, 0, 0,	0, 0, 0,		0.5, 0.5, 0.5, 1,		0.5, 0.5,	false, false, false )
			p2:SetHidden( true )
			p2:SetAlpha( 0 )
			p2:SetSampleProcessing( 1.3 )
			p2:SetAutoDrawLevelEnabled( false )
			p2.Texture:SetDrawLayer( DL_OVERLAY )
		end,
		Update = function( self )
			if self.InitFullscreen and self.InitFullscreen <= FrameTime then
				self.InitFullscreen = nil

				for index = 3, 4 do
					local p = self.Particles[index]
					p:SetHidden( true )
					local tex = p.Texture
					tex:Destroy3DRenderSpace()
					tex:SetAnchor( CENTER, GuiRoot, CENTER, 0, 0 )
					local maxDimension = 1.2 * math.max( GuiRoot:GetDimensions() )
					tex:SetDimensions( maxDimension, maxDimension )
					tex:SetDrawLevel( DRAW_LEVEL_OVERLAY_EFFECT )
				end
			end

			local p1, p2 = self.Particles[1], self.Particles[2]
			local p3, p4 = self.Particles[3], self.Particles[4]
			local size = self.SizeX
			local vx, vy, vz = CameraX - self.X, CameraY - self.Y, CameraZ - self.Z
			local distanceSquared = vx * vx + vy * vy + vz * vz
			local distanceH = math.sqrt( vx * vx + vz * vz )
			local angleH = math.atan2( vx, vz )
			local angleV = math.atan2( distanceH, vy )
			local nx, ny, nz = NormalVector( vx, vy, vz )
			local interval1 = GetLinearInterval( self.LoopInterval )
			local interval2 = ( 2 * interval1 ) % 1
			local sample1 = 0.5 + 2 * ZO_EaseInOutQuadratic( math.abs( -1 + ( 4 * interval1 ) % 2 ) )
			local sample2 = 0.5 + 2 * ZO_EaseInOutQuadratic( math.abs( -1 + ( 4 * GetLinearInterval( self.LoopInterval * 1.7 ) ) % 2 ) )
			local centerRatio = distanceSquared / self.SizeSquared
			local inside

			if impenetrable then
				local dx, dy, dz = PlayerX - self.X, PlayerY - self.Y, PlayerZ - self.Z
				local lastDistance = self.lastDistance or self.SizeSquared

				self.lastDistance = dx * dx + dy * dy + dz * dz
				if self.lastDistance < lastDistance then
					if not self.flareStartMS and self.lastDistance <= self.SizeSquared then
						self.flareStartMS = FrameTime
						self.flareDurationMS = 300
						self.flareMultiplier = 2
					end

					if self.lastDistance <= ( self.SizeSquared * 1.15 ) then
						StopAllMovement()

						if soundCallback and ( not self.nextSoundMS or self.nextSoundMS < FrameTime ) then
							self.nextSoundMS = FrameTime + 2000

							local INSIDE = true
							soundCallback( INSIDE )

							zo_callLater( function()
								local emotes = { "/knock", "/hammerwall", "/stagger", "/knockeddown", "/faint", }
								self.nextEmoteIndex = ( ( self.nextEmoteIndex or 0 ) % #emotes ) + 1 
								EHT.Util.PlayEmote( emotes[ self.nextEmoteIndex ] )
							end, 300 )
						end
					end
				end
			end
			
			if self.flareStartMS then
				if self.flareStartMS + self.flareDurationMS < FrameTime then
					self.flareStartMS, self.flareDurationMS, self.flareMultiplier = nil, nil, nil
				else
					local flareInterval = ( FrameTime - self.flareStartMS ) / self.flareDurationMS
					local flare = EaseOutIn2( flareInterval ) * self.flareMultiplier
					sample1, sample2 = sample1 + flare, sample2 + flare
				end
			end

			if centerRatio < 1 then
				local alpha = ZO_EaseOutQuartic( 1 - centerRatio )
				inside = true

				p3:RotateCoords( -interval1 * 2 * math.pi, 0.5, 0.5, 1.2 )
				p4:RotateCoords( -interval2 * 2 * math.pi, 0.5, 0.5, 1.2 )
				p3:SetSampleProcessing( sample1 )
				p4:SetSampleProcessing( sample2 )
				p3:SetAlpha( alpha )
				p4:SetAlpha( alpha )
				p3:SetHidden( false )
				p4:SetHidden( false )
			else
				inside = false

				p3:SetHidden( true )
				p4:SetHidden( true )
			end

			local px, py, pz = self.X + nx * size, self.Y + ny * size, self.Z + nz * size
			local pitch = RAD90 + angleV
			local yaw = angleH
			local alpha = zo_clamp( centerRatio - 1, 0, 1 )

			p1:RotateCoords( interval1 * 2 * math.pi, 0.5, 0.5, 1.05 )
			p2:RotateCoords( interval2 * 2 * math.pi, 0.5, 0.5, 1.03 )
			p1:SetSampleProcessing( sample1 )
			p2:SetSampleProcessing( sample2 )
			p1:SetAlpha( alpha )
			p2:SetAlpha( alpha )
			p1:SetPositionAndOrientation( px, py, pz, pitch, yaw, 0 )
			p2:SetPositionAndOrientation( px, py, pz, pitch, yaw, 0 )
			p1:SetHidden( inside )
			p2:SetHidden( inside )

			if inside ~= self.blurInside then
				self.blurInside = inside
				if inside then
					SetFullscreenEffect( FULLSCREEN_EFFECT_UNIFORM_BLUR, nil, nil, true )
				else
					SetFullscreenEffect( FULLSCREEN_EFFECT_NONE, nil, nil, false )
				end
			end

			if not impenetrable and soundCallback and self.inside ~= inside then
				if self.inside ~= nil and ( not self.insideTimeMS or self.insideTimeMS < FrameTime ) then
					self.inside = inside
					soundCallback( inside )
				else
					self.inside = inside
				end
				self.insideTimeMS = FrameTime + 1000
			end
		end,
		Reset = function( self )
			self:Update()
			self.SizeSquared = self.SizeX * self.SizeX * 0.95
			self.InitFullscreen = FrameTime + 500
			self.Particles[1]:SetSize( self.SizeX, self.SizeX )
			self.Particles[2]:SetSize( self.SizeX, self.SizeX )
		end,
		Destroy = function( self )
			if self.blurInside then
				SetFullscreenEffect( FULLSCREEN_EFFECT_NONE, nil, nil, false )
			end
		end,
	} )
end

AddSphericalEffect( 961, "Force Field", CAT.ANIM, { 500, 500, 500 }, { 0.5, 0.85, 1, 1 }, TEXTURES.FORCEFIELD_1, false, function() PlayCrownCrateTierSpecificParticleSoundAndVibration( 30, CROWN_CRATE_TIERED_PARTICLES_REVEALED ) end )
AddSphericalEffect( 962, "Force Field, Mute", CAT.ANIM, { 500, 500, 500 }, { 0.5, 0.85, 1, 1 }, TEXTURES.FORCEFIELD_1, false, nil )
AddSphericalEffect( 963, "Force Field, Barrier", CAT.ANIM, { 500, 500, 500 }, { 0.5, 0.85, 1, 1 }, TEXTURES.FORCEFIELD_1, true, function() PlayCrownCrateTierSpecificParticleSoundAndVibration( 12, CROWN_CRATE_TIERED_PARTICLES_REVEALED ) end )

local function AddSolarWindsEffect( id, name, backdropAlpha, defaultContrast )
	AddSkyEffect(
		id, name,
		-- Options
		{ R = 0, G = 0.9, B = 0.9, Contrast = defaultContrast, },
		-- Side Textures Table
		{
			{
				Texture = TEXTURES.AURORA_BOREALIS_1,
				Stretch = true, AddColor = true, Wrap = true,
				R = 1, G = 1, B = 1, A = 0, SampleRGB = 1,
			},
			{
				Texture = TEXTURES.AURORA_BOREALIS_1,
				Stretch = true, AddColor = true, Wrap = true,
				R = 1, G = 1, B = 1, A = 0, SampleRGB = 1,
			},
			{
				Texture = TEXTURES.AURORA_BOREALIS_1,
				Stretch = true, AddColor = true, Wrap = true,
				R = 1, G = 1, B = 1, A = 0, SampleRGB = 1,
			},
			{
				Texture = TEXTURES.NOISE_3, CanModifyColor = false,
				Stretch = true, AddColor = false, Wrap = true,
				R = 1, G = 1, B = 1, A = backdropAlpha, SampleRGB = 1,
				MaxVertexAlphas = { backdropAlpha, backdropAlpha, backdropAlpha, backdropAlpha, },
			},
			{
				Texture = TEXTURES.NOISE_3, CanModifyColor = false,
				Stretch = true, AddColor = false, Wrap = true,
				R = 1, G = 1, B = 1, A = backdropAlpha, SampleRGB = 1,
				MaxVertexAlphas = { backdropAlpha, backdropAlpha, backdropAlpha, backdropAlpha, },
			},
		},
		-- Top Texture Filename
		TEXTURES.SOLID,
		-- Reset Handler
		function( self )
			self.BackdropInterval = 300000
			self.BackdropScale = 1
			self.ShakeInterval = 3000
			self.VerticalInterval = 360000
			self.AlphaIntervals = { 60000, 70000, 50000, } -- { 25500, 34000, 17000, }
			self.HeightOffsets = { 0.01, 0, 0.495, }
			self.RotationIntervals = { 30000, 25000, 20000, } -- { 45000, 45000, 45000, }
			self.RotationOffsets = { 2000, 0, 1200, }

			local top = self.TopTexture
			top:SetColor( 0, 0, 0, 0 )
			top:SetHidden( true )
			--top:SetColor( 0, 0, 0, backdropAlpha )
			top:SetCanModifyColor( false )
			top:SetAutoDrawLevelEnabled( false )
			top:SetDrawLevel( 2 )

			for backdropIndex = 5, 6 do
				local backdrop = self.TextureFaces[ backdropIndex ]
				for index = 1, #backdrop do
					local p = backdrop[ index ]
					p:SetCanModifyColor( false )
					p:SetAutoDrawLevelEnabled( false )
					p:SetDrawLevel( backdropIndex - 4 )
				end
			end

			local r, g, b, a = self:GetColor()
			local faces1, faces2, faces3 = self.TextureFaces[ 2 ], self.TextureFaces[ 3 ], self.TextureFaces[ 4 ]
			local numFaces = #faces1

			for index = 1, numFaces do
				local p2, p3, p4 = faces1[ index ], faces2[ index ], faces3[ index ]
				p2:SetVertexColors( 15, r, g, b, 0 )
				p3:SetVertexColors( 15, r, g, b, 0 )
				p4:SetVertexColors( 15, r, g, b, 0 )
			end
		end,
		-- Update Handler
		function( self )
			local r, g, b, a = self:GetColor()
			local shakeOffset = GetEasedInterval( self.ShakeInterval ) * 0.005

			for index = 1, 3 do
				shakeOffset = -shakeOffset
				local offset = self.RotationOffsets[ index ]
				local heightOffset = self.HeightOffsets[ index ]
				local alphaInterval = GetEasedInterval( self.AlphaIntervals[ index ], offset )
				local rotationInterval = GetLinearInterval( self.RotationIntervals[ index ], offset ) + shakeOffset
				local verticalInterval = GetLinearInterval( self.VerticalInterval ) + heightOffset + math.abs( 0.1 * shakeOffset )
				local faces = self.TextureFaces[ 1 + index ]
				local numFaces = #faces - 1
				local fr, fg, fb = r, g, b

				if 1 == index then
					fg = fg + 0.5 * alphaInterval
					fr = fr + 0.5 * -alphaInterval
				elseif 2 == index then
					fb = fb + 0.5 * alphaInterval
					fg = fg + 0.5 * -alphaInterval
				else
					fr = fr + 0.5 * alphaInterval
					fb = fb + 0.5 * -alphaInterval
				end

				ProjectCylinderTextureFaces( faces, 0, rotationInterval, ( 1 == index and 4 or 2 ) + rotationInterval, verticalInterval, 0.5 + verticalInterval )

				for faceIndex, face in ipairs( faces ) do
					do
						local offset1, offset2, offset3 = ( faceIndex - 1 ) / numFaces, faceIndex / numFaces
						local alpha1 = 0.7 - 2 * ZO_EaseInOutQuadratic( math.abs( -1 + 2 * ( ( alphaInterval + offset1 ) % 1 ) ) )
						local alpha2 = 0.7 - 2 * ZO_EaseInOutQuadratic( math.abs( -1 + 2 * ( ( alphaInterval + offset2 ) % 1 ) ) )

						face:SetVertexColors( 4, fr, fg, fb, a * alpha1 )
						face:SetVertexColors( 8, fr, fg, fb, a * alpha2 )
					end
				end
			end

			if backdropAlpha > 0 then
				local backdropInterval = GetLinearInterval( self.BackdropInterval )
				ProjectCylinderTextureFaces( self.TextureFaces[ 5 ], 0, backdropInterval, self.BackdropScale + backdropInterval, 0, 1 )

				backdropInterval = ( ( 1 - backdropInterval ) + 0.2 ) % 1
				ProjectCylinderTextureFaces( self.TextureFaces[ 6 ], 0, backdropInterval, self.BackdropScale + backdropInterval, 1, 0 )
			end
		end
	)
end

AddSolarWindsEffect( 964, "Solar Winds", 0, 2 )
AddSolarWindsEffect( 965, "Solar Winds, Night", 0.4, 1 )

do
	local options =
	{
		orderDrawLevelByIndex = false,
		emissionInterval = 5000,
		emissionFrequency = 500,
		maxEmissions = 50,
		minVelocityY = -0.15,
		maxVelocityY = -0.2,
		sizeX = 800,
		sizeY = 800,
		sizeByAreaPercentage = 0.005,
		sizeByAreaVariance = 0.1,
		minTtl = 4000,
		maxTtl = 5000,
		minGrowth = 1,
		maxGrowth = 2,
		pulseInterval = 1,
		recycleAtRange = false,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.SPIRAL,
	}
	CreateParticleEmitter( 966, "Magicka, Drifting", options )
end

do
	local options =
	{
		orderDrawLevelByIndex = false,
		emissionInterval = 5000,
		emissionFrequency = 250,
		maxEmissions = 50,
		minVelocityY = -0.5,
		maxVelocityY = -0.4,
		sizeX = 800,
		sizeY = 800,
		sizeByAreaPercentage = 0.005,
		sizeByAreaVariance = 0.1,
		minTtl = 1500,
		maxTtl = 2000,
		minGrowth = 1,
		maxGrowth = 2,
		pulseInterval = 1,
		recycleAtRange = false,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.SPIRAL,
	}
	CreateParticleEmitter( 967, "Magicka, Chaotic", options )
end

do
	local options =
	{
		orderDrawLevelByIndex = false,
		emissionInterval = 5000,
		emissionFrequency = 500,
		maxEmissions = 50,
		minVelocityY = 0.15,
		maxVelocityY = 0.2,
		sizeX = 800,
		sizeY = 800,
		sizeByAreaPercentage = 0.005,
		sizeByAreaVariance = 0.1,
		minTtl = 4000,
		maxTtl = 5000,
		minGrowth = 1,
		maxGrowth = 2,
		pulseInterval = 1,
		recycleAtRange = false,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.SPIRAL,
	}
	CreateParticleEmitter( 968, "Magicka, Updraft", options )
end

do
	local options =
	{
		orderDrawLevelByIndex = false,
		emissionInterval = 5000,
		emissionFrequency = 250,
		maxEmissions = 50,
		minVelocityY = 0.4,
		maxVelocityY = 0.5,
		sizeX = 800,
		sizeY = 800,
		sizeByAreaPercentage = 0.005,
		sizeByAreaVariance = 0.1,
		minTtl = 1500,
		maxTtl = 2000,
		minGrowth = 1,
		maxGrowth = 2,
		pulseInterval = 1,
		recycleAtRange = false,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.SPIRAL,
	}
	CreateParticleEmitter( 969, "Magicka, Releasing", options )
end

do
	local options =
	{
		autoAdjustTtl = false,
		respawnOnResize = false,
		orderDrawLevelByIndex = false,
		maxEmissions = 8,
		emissionFrequency = 300,
		emissionRadiusY = 0.49,
		emissionInterval = 1,
		minVelocityY = 1,
		maxVelocityY = 1,
		minSizePercent = 1.5,
		minGrowth = 1,
		maxGrowth = 3,
		minTtl = 1200,
		maxTtl = 1200,
		sizeX = 500,
		sizeY = 500,
		pulseInterval = 1,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM,
		velocityFunction = function()
			return 0, 25 * ( math.random( 0, 1 ) == 1 and 1 or -1 ), 0
		end,
		sampleFunction = CreateEasingFunction( 1, 0, 8 ),
	}
	CreateParticleEmitter( 970, "Magicka, Lingering", options )
end

do
	local options =
	{
		autoAdjustTtl = false,
		orderDrawLevelByIndex = false,
		maxEmissions = 5,
		emissionFrequency = 1000,
		emissionInterval = 2000,
		emissionOffset = 0.25,
		minVelocityY = 10,
		maxVelocityY = 20,
		minSizePercent = 1.5,
		minGrowth = 1,
		maxGrowth = 1,
		sizeX = 300,
		sizeY = 300,
		pulseInterval = 1,
		alphaFunction = function( self, interval, duration )
			return EaseOutIn4( interval )
		end,
		vectorAngleFunction = function()
			local a = EaseOutIn2( math.random() )
			return 0.08 * math.pi * ( a < 0.5 and ( 0.5 - 2 * a ) or ( -0.5 + 2 * a ) )
		end,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.SPHERICAL,
		recycleAtRange = false,
		spherical = true,
	}
	CreateParticleEmitter( 971, "Magicka, Circling", options )
end

do
	local options =
	{
		autoAdjustTtl = false,
		orderDrawLevelByIndex = false,
		emissionInterval = 2000,
		emissionFrequency = 1000,
		emissionOffset = 0.25,
		minVelocityY = 8,
		maxVelocityY = 8,
		minSizePercent = 1.5,
		minGrowth = 1,
		maxGrowth = 3,
		sizeX = 300,
		sizeY = 300,
		pulseInterval = 1,
		growthFunction = function( self, interval, duration, sizeX, sizeY )
			return sizeX, sizeY
		end,
		vectorAngleFunction = function()
			local a = 0.05 * math.pi + 0.4 * math.pi * EaseOutIn2( math.random() )
			return a * math.random( 1, 2 )
		end,
		vectorRadiusFunction = function()
			return 0.7 + 0.3 * math.random()
		end,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.SPHERICAL,
		recycleAtRange = false,
		spherical = true,
	}
	CreateParticleEmitter( 972, "Magicka, Orbiting", options )
end

do
	local maxEmissions = 6
	local emissionCounter = 0
	local options =
	{
		autoAdjustTtl = false,
		respawnOnResize = false,
		orderDrawLevelByIndex = false,
		emissionInterval = 2000,
		emissionOffset = 0.1,
		minEmissions = maxEmissions,
		maxEmissions = maxEmissions,
		minVelocityY = 2,
		maxVelocityY = 2,
		minSizePercent = 2,
		minGrowth = 1,
		maxGrowth = 2,
		minTtl = 0,
		maxTtl = 0,
		sizeX = 300,
		sizeY = 300,
		pulseInterval = 5000,
		updateFunction = function( self, emitter )
			local offset = 0 -- self.emitterIntervalOffset
			--[[
			if not offset then
				offset = math.random( 0, 30000 )
				self.emitterIntervalOffset = offset
			end
			]]
			local interval1, interval2 = 0.5 + EaseInOut2( GetLoopInterval( 10000, offset ) ), 0.5 + EaseOutIn2( GetLoopInterval( 15000, offset ) )
			local radiusInterval = 0.005 * GetEasedInterval( 30000, offset )
			local angleInterval = RAD360 * GetLinearInterval( 60000, offset )
			local angleModulo = 2 + 3.5 * GetLoopInterval( 20000, offset )
			for index, p in ipairs( self.Particles ) do
				if not p.BaseSphericalOffset then
					p.BaseSphericalOffset = -0.05 * math.sin( RAD360 * ( index / maxEmissions ) )
					p.SphericalRadius = 1
					p.SphericalInterval = emitter.EmissionInterval / 500
				end
				p.SphericalAngle = 0.15 * RAD180 * math.sin( RAD360 * ( index / angleModulo ) ) + angleInterval
				p.SphericalOffset = p.BaseSphericalOffset * ( index % 2 == 0 and interval1 or interval2 )
			end
		end,
		alphaFunction = function()
			return 1
		end,
		growthFunction = function( self, interval, duration, sizeX, sizeY )
			local c = 1 + EaseInOut2( ( ( self.Index / 10 ) + ( duration % 2 ) / 2 ) % 1 )
			return c * sizeX, c * sizeY
		end,
		sampleFunction = function( self, interval, duration )
			local offset = ( self.Index % 5 ) / 5
			return 3 + 2 * EaseInOut2( GetLinearInterval( 2000 + offset * 2000, ( 1 - offset ) * 1500 ) )
		end,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.SPHERICAL,
		recycleAtRange = false,
		spherical = true,
	}
	CreateParticleEmitter( 973, "Magicka, Swarming", options )
end

-- 8/31/2020
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1598843728 )

do
	local options =
	{
		autoAdjustTtl = false,
		orderDrawLevelByIndex = false,
		texture = TEXTURES.NOISE_4,
		defaultColor = { 1, 0.48, 0.05, 1 },
		colorOffset = 0.1,
		maxEmissions = 8,
		emissionFrequency = 700,
		emissionInterval = 1,
		emissionY = 0.99,
		spawnY = 0,
		minVelocityY = -1,
		maxVelocityY = -1,
		minGrowth = 1,
		maxGrowth = 1,
		minSizePercent = 1,
		minTtl = 5000,
		maxTtl = 5000,
		sizeX = 12000,
		sizeY = 12000,
		pulseInterval = 1,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.RANDOM,
		resetFunction = function( self, emitter )
			self.particleWidth = self.SizeY and zo_clamp( self.SizeY / 650, 1, 20 ) or 10
			self.particleHeight = self.SizeY and zo_clamp( self.SizeY / 20, 6, 500 ) or 200
		end,
		growthFunction = function( p, interval, duration, sizeX, sizeY )
			return p.Effect.particleWidth * ( 1 - interval * 0.5 ), p.Effect.particleHeight * EaseOutIn4( interval )
		end,
		sampleFunction = function( p, interval, duration )
			return 2.5 + math.sin( interval * 4 * math.pi )
		end,
		velocityFunction = function( p )
			return 0, -( math.max( 10, p.Effect.SizeY / 14 ) * ( 1 - 0.3 * ( ( p.Index % 3 ) / 3 ) ) ), 0
		end,
		vertexColorFunction = function( p, interval, duration )
			local r, g, b = p.BaseR, p.BaseG, p.BaseB
			local a = EaseOutIn3( interval )
			return r, g, b, 0,
				r, g, b, 0,
				r, g, b, 0,
				r, g, b, a
		end,
		uvCoordsFunction = function( p, interval, duration )
			local offset = ( p.Index % 8 ) / 13
			local y = offset + 0.3 * interval
			return offset, offset + 0.005, y, y + 0.05
		end,
	}
	CreateParticleEmitter( 974, "Meteorites", options )
end

local function AddClockHandEffect( id, name, options )
	options = options or {}

	return EHT.EffectType:New( id, name, {
		OrderDrawLevelByIndex = true,
		Category = CAT.DECO,
		CanPitch = true,
		Init = function( self )
			self:SetSize( 40, 40, 40 )
			self:SetColor( 1, 0.66, 0.4, 1 )
			self:SpawnAtPlayer( 200, nil, -100 )

			if options.back then
				self.Back = self:AddParticle( TEXTURES.CLOCK_FACE_BACK,		0, 0, 0,		0, 0, 0,	0.7, 0.7, 0.7, 1,		1, 1,		true, false, false )
				self.Back:SetDesaturation( 0.5 )
			end
			if options.face then
				self.Face = self:AddParticle( TEXTURES.CLOCK_FACE,			0, 0, 0,		0, 0, 0,	1.0, 1.0, 1.0, 1,		1, 1,		true, false, false )
				self.Face:SetDesaturation( 0.75 )
			end
			if options.minute then
				self.MinuteHand = self:AddParticle( TEXTURES.CLOCK_HAND,	0, 0, 0,		0, 0, 0,	1.0, 1.0, 1.0, 1,		1, 1,		true, false, false )
			end
			if options.hour then
				self.HourHand = self:AddParticle( TEXTURES.CLOCK_HAND,		0, 0, 0,		0, 0, 0,	0.95, 0.95, 0.95, 1,	1, 1,		true, false, false )
			end
			if options.second then
				self.SecondHand = self:AddParticle( TEXTURES.CLOCK_HAND,	0, 0, 0,		0, 0, 0,	0.7, 0.7, 0.7, 1,		1, 1,		true, false, false )
			end
		end,
		Update = function( self )
			local h, m, s = TamrielTime.Hour or 0, TamrielTime.Minute or 0, TamrielTime.Second or 0
			local index = 1

			if self.HourHand then
				local ha = ( ( ( h % 12 ) + 1 ) / 12 ) * RAD360
				self.HourHand:RotateCoords( ha, 0.25, 0.5, 2, 0.6 )
				index = index + 1
			end

			if self.MinuteHand then
				local ma = ( ( ( m % 60 ) + 1 ) / 60 ) * RAD360
				self.MinuteHand:RotateCoords( ma, 0.25, 0.5, 2, 0.9 )
				index = index + 1
			end

			if self.SecondHand then
				local sa = ( ( ( s % 60 ) + 1 ) / 60 ) * RAD360
				self.SecondHand:RotateCoords( sa, 0.75, 0.5, 2, 1 )
			end
		end,
		Reset = function( self )
			local _, size = self:GetSize()
			self:SetSize( size, size, size )
			self:Update()
		end,
	} )
end

AddClockHandEffect( 975, "Clock Hand (Hour)", { hour = true, } )
AddClockHandEffect( 976, "Clock Hand (Minute)", { minute = true, } )
AddClockHandEffect( 977, "Clock Hand (Second)", { second = true, } )
AddClockHandEffect( 978, "Clock Hands (Hour/Minute)", { hour = true, minute = true, } )
AddClockHandEffect( 979, "Clock Hands (Hour/Minute/Second)", { hour = true, minute = true, second = true, } )
AddClockHandEffect( 980, "Clock Face & Hands (Opaque)", { hour = true, minute = true, second = true, back = true, face = true } )
AddClockHandEffect( 981, "Clock Face & Hands (Transparent)", { hour = true, minute = true, second = true, face = true } )
AddClockHandEffect( 982, "Clock Face (Opaque)", { back = true, face = true, } )
AddClockHandEffect( 983, "Clock Face (Transparent)", { face = true, } )

local function AddSmokeEffect( id, name, options )
	local et = EHT.EffectType:New( id, name, {
		Category = CAT.WEATHER,
		CanPitch = true,
		ResetOnOrientation = false,
		Init = function( self )
			self.IntervalOffset = math.random( 2000 ) + 2000 * self.Index
			self.Options = options
			options.OffsetX, options.OffsetY = options.OffsetX or 0, options.OffsetY or 0
			options.ScaleX, options.ScaleY = options.ScaleX or 1, options.ScaleY or 1

			local density = self.Options.Density
			for index = 1, density do
				local ratio = ( index - 1 ) / ( density - 1 )
				local marginY = self.Options.MarginY * ( index - 1 ) * ( index % 2 == 0 and 1 or -1 )
				local cc = 1 + ( 0.5 - ratio ) * self.Options.ColorRange

				p = self:AddParticle( self.Options.Texture,		0, marginY, 0,		RAD90, 0, 0,	cc, cc, cc, 0,		1, 1,	true, false, false )
				p.angle = ratio * RAD360
				p.fadingIn = true
				p.offsetX = zo_lerp( self.Options.MinOffsetX, self.Options.MaxOffsetX, ratio )
				p.offsetY = zo_lerp( self.Options.MinOffsetY, self.Options.MaxOffsetY, ratio )
				p.marginY = marginY
			end

			self:SetCameraFacing( self.Options.CameraFacing )
			self:SetColor( unpack( self.Options.Color ) )
			self:SetContrast( self.Options.Contrast )
			self:SetSize( 4000, 0, 4000 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( self.Options.SpawnY )
		end,
		Update = function( self )
			local opt = self.Options
			local interval = GetLinearInterval( opt.Interval, self.IntervalOffset )

			if opt.OnUpdate then
				opt.OnUpdate( self, opt, interval )
			end

			local alphaMultiplier = opt.AlphaMultiplier
			local periodMultiplier = opt.PeriodMultiplier
			local offsetX, offsetY = opt.OffsetX, opt.OffsetY
			local scaleX, scaleY = opt.ScaleX, opt.ScaleY
			local sample = EasedCyclicalLerp( 0.5, 1, opt.SampleMultiplier * interval % 1 )
			local numP = #self.Particles

			for index, p in ipairs( self.Particles ) do
				local periodInterval = interval + index / numP
				local period = ( periodMultiplier * periodInterval ) % 1
				local loop = math.abs( -1 + 2 * ( period + 0.5 ) )
				local alpha = EaseOutIn2( ( alphaMultiplier * period ) % 1 )

				p:RotateCoords( p.angle, scaleX * loop, scaleY, p.offsetX + offsetX, p.offsetY + offsetY )
				p:SetColorOffsets( nil, nil, nil, alpha )
				p:SetSampleProcessing( sample, 0 )
				p:SetAutoPositionEnabled( alpha < 0.1 )
			end
			
			self:Update()
		end,
	} )
	return et
end

do
	local options =
	{
		AlphaMultiplier = 1,
		CameraFacing = false,
		Color = { 0.6, 0.5, 1, 1 },
		ColorRange = 0.4,
		Contrast = 2,
		Density = 11,
		Interval = 240000,
		MarginY = 6,
		MinOffsetX = 0.4,
		MinOffsetY = 0.4,
		MaxOffsetX = 0.4,
		MaxOffsetY = 0.4,
		OffsetX = 0,
		OffsetY = 0,
		PeriodMultiplier = 16,
		SampleMultiplier = 5,
		ScaleX = 0.5,
		ScaleY = 0.25,
		SpawnY = 70,
		Texture = TEXTURES.SMOKE_5,
		OnUpdate = function( self, opt, interval )
			local radius = 0.1 * ( -1 + 2 * EaseInOut2( ( 10 * interval ) % 1 ) )
			opt.OffsetX, opt.OffsetY = radius, radius
		end,
	}
	AddSmokeEffect( 984, "Fog, Encircling", options )
end

do
	local options =
	{
		orderDrawLevelByIndex = false,
		emissionInterval = 4000,
		emissionFrequency = 30,
		maxEmissions = 80,
		minVelocityY = -0.7,
		maxVelocityY = -0.6,
		sizeX = 300,
		sizeY = 600,
		sizeByAreaPercentage = 0.005,
		sizeByAreaVariance = 0.1,
		minTtl = 1200,
		maxTtl = 1500,
		minGrowth = 1,
		maxGrowth = 2,
		pulseInterval = 1,
		recycleAtRange = false,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.SPIRAL,
	}
	CreateParticleEmitter( 985, "Magicka, Pouring", options )
end

do
	local options =
	{
		orderDrawLevelByIndex = false,
		emissionInterval = 4000,
		emissionFrequency = 30,
		maxEmissions = 80,
		minVelocityY = 0.6,
		maxVelocityY = 0.7,
		sizeX = 300,
		sizeY = 600,
		sizeByAreaPercentage = 0.005,
		sizeByAreaVariance = 0.1,
		minTtl = 1200,
		maxTtl = 1500,
		minGrowth = 1,
		maxGrowth = 2,
		pulseInterval = 1,
		recycleAtRange = false,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.SPIRAL,
	}
	CreateParticleEmitter( 986, "Magicka, Escaping", options )
end

-- 09/19/2020
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1600498957 )

AddCurrentsSkyEffect( 987, "Under the Sea", {
	alpha = 0.65,
	backdropTexture = TEXTURES.SOLID,
	bidirectional = true,
	defaultColor = { 0.25, 0.6, 0.55, 1 },
	fixedScale = true,
	interval = 0.01,
	sampleRGB = 5,
	sampleAlpha = 0,
	texture = TEXTURES.WAVES_2,
	topTexture = TEXTURES.WAVES_2,
	waveScale = 0.5,
} )

AddCurrentsSkyEffect( 988, "Watercolors", {
	alpha = 1,
	defaultColor = { 0.6, 1, 0.7, 1 },
	defaultContrast = 2,
	fixedScale = true,
	interval = 0.01,
	sampleRGB = 4,
	sampleAlpha = 0,
	texture = TEXTURES.WAVES_2,
	waveScale = 0.2,
} )

AddCurrentsSkyEffect( 989, "Jet Stream", {
	alpha = 0.1,
	defaultColor = { 0.45, 0.5, 0.55, 1 },
	defaultContrast = 1.5,
	fixedScale = true,
	interval = 0.005,
	sampleRGB = 7,
	sampleAlpha = 0,
	scaleX = 2,
	scaleY = 3.5,
	texture = TEXTURES.WAVES_2,
	waveScale = 0.5,
} )

do
	local ParticleColors =
	{
		{ 0.15, 0, 0, },
		{ 0, 0.15, 0, },
		{ 0, 0, 0.15, },
		{ 0.1, 0.1, 0, },
		{ 0, 0.1, 0.1, },
		{ 0.1, 0, 0.1, },
	}

	function EHT.EffectType.AddFlareEffect( id, name, options )
		local et = EHT.EffectType:New( id, name, {
			Category = CAT.LIGHT,
			CanPitch = false,
			ResetOnOrientation = false,
			Init = function( self )
				self.Options = options
				self.AngleInterval = self.Options.AngleInterval or 600000
				self.Density = self.Options.Density or 6
				self.Interval = ( self.Options.Interval or 20000 ) * ( 0.8 + 0.4 * math.random() )
				self.IntervalOffset = math.random( 5000 ) + 5000 * self.Index
				self.Options.AngleRange = self.Options.AngleRange or RAD45

				local prismatic = self.Options.Prismatic
				local particleColors = not prismatic and ParticleColors or nil
				if prismatic then
					self:SetAutoColorEnabled( false )
				end

				for index = 1, self.Density do
					local ratio = ( index - 1 ) / ( self.Density - 1 )
					local cr, cg, cb = 0, 0, 0
					if particleColors then
						cr, cg, cb = unpack( particleColors[ index ] )
					end
					local p = self:AddParticle( self.Options.Texture,		0, 0, 0,		RAD90, 0, 0,	1 + cr, 1 + cg, 1 + cb, 0,		1, 1,	true, false, false )

					p.AngleBase = EaseIn2( ratio ) * RAD360
					p.AngleRange = ( 0.5 + EaseIn2( ratio ) ) * ( 0 == index % 2 and 1 or -1 ) * self.Options.AngleRange
					p.IntervalOffset = VariableEaseIn( ratio, 1.5 )
					p.IntervalScale = 1 + 0.3 * math.random()
					p.MinAlpha = 0
					p.MaxAlpha = 0.4 + 0.6 * ratio
					p.MinScale = 0.25 + 0.2 * ratio
					p.MaxScale = ratio
				end

				self:SetCameraFacing( true )
				self:SetColor( unpack( self.Options.Color or { 1, 1, 1, 1, } ) )
				self:SetContrast( self.Options.Contrast or 2 )
				self:SetSize( 500, 500, 500 )
				self:SetOrientation( 0, 0, 0 )
				self:SpawnAtPlayer( self.Options.SpawnY or 250 )
			end,
			Update = function( self )
				local opt = self.Options
				local interval = GetLinearInterval( self.Interval, self.IntervalOffset )
				local numP = #self.Particles
				local angleInterval = ( FrameTime % self.AngleInterval ) / self.AngleInterval
				local baseAngle = angleInterval * RAD360
				interval = ( interval + ( ( 1 + CameraForwardX ) / 4 ) ) % 1

				local r, g, b, a, vr, vg, vb
				if self.Options.Prismatic then
					r, g, b, a = self:GetColor()
					vr, vg, vb = 0.5 * r + 0.5 * GetEasedInterval( 5000 ), 0.5 * g + 0.5 * GetEasedInterval( 4000 ), 0.5 * b + 0.5 * GetEasedInterval( 3000 )
				end

				for index, p in ipairs( self.Particles ) do
					local periodInterval = math.min( 1, ( ( interval + p.IntervalOffset ) % 1 ) * p.IntervalScale )
					local easedInterval = VariableEase( periodInterval, 1.1 )
					local alpha = zo_lerp( easedInterval, p.MinAlpha, p.MaxAlpha )
					local angle = ( ( 0 == index % 2 and baseAngle or -baseAngle ) + p.AngleBase + periodInterval * p.AngleRange ) % RAD360
					local scale = zo_lerp( periodInterval, p.MinScale, p.MaxScale )
					local sampling = 2 + 4 * EaseIn2( alpha ) * VariableEase( ( 30 * angleInterval ) % 1, 1.5 )

					p:RotateCoords( angle, 0.5, 0.5, scale, scale )
					p:SetSampleProcessing( sampling )
					
					if r then
						local pr = ( index < 3 or index > 4 ) and vr or r
						local pg = ( index > 1 and index < 5 ) and vg or g
						local pb = ( index > 3 ) and vb or b
						p:SetColor( pr, pg, pb, a * alpha )
					else
						p:SetColorOffsets( nil, nil, nil, alpha )
					end
				end

				self:Update()
			end,
		} )
		return et
	end
end

-- 11/11/2020
EHT.EffectType:SetDefaultDateAdded( 1605068199 )

EHT.EffectType.AddFlareEffect( 990, "Lens Flare",
{
	Texture = TEXTURES.LENS_FLARE_3,
} )

EHT.EffectType.AddFlareEffect( 991, "Solar Flare",
{
	AngleRange = RAD90,
	Interval = 4000,
	Texture = TEXTURES.LENS_FLARE_3,
} )

local function AddRadiusActionEffectsForFurnitureStateToggle( id1, id2, state, stateName, inactiveState, inactiveStateName )
	local effectTypeName1, effectTypeName2
	if inactiveState then
		effectTypeName1 = string.format( "Turn item %s / %s when in range", stateName, inactiveStateName )
		effectTypeName2 = string.format( "Turn item %s / %s when out of range", stateName, inactiveStateName )
	else
		effectTypeName1 = string.format( "Turn item %s when in range", stateName )
		effectTypeName2 = string.format( "Turn item %s when out of range", stateName )
	end

	local function Action( self, active )
		local furnitureId = self:GetMetaData( "Furniture" )
		local furnitureState = EHT.Housing.GetFurnitureState( furnitureId )

		if furnitureState then
			if active and furnitureState ~= state then
				EHT.Housing.SetFurnitureState( furnitureId, state )
			else
				if inactiveState and not active and furnitureState ~= inactiveState then
					EHT.Housing.SetFurnitureState( furnitureId, inactiveState )
				end
			end
		end
	end

	do
		local et = AddRadiusActionEffectForFurniture( id1, effectTypeName1, true, Action, false )
		AddFurnitureIndicatorsToActionEffect( et, { "Furniture" } )
	end

	do
		local et = AddRadiusActionEffectForFurniture( id2, effectTypeName2, false, Action, false )
		AddFurnitureIndicatorsToActionEffect( et, { "Furniture" } )
	end
end

-- 11/25/2020
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1606287568 )

AddRadiusActionEffectsForFurnitureStateToggle( 992, 993, EHT.STATE.OFF, "OFF" )
AddRadiusActionEffectsForFurnitureStateToggle( 994, 995, EHT.STATE.ON, "ON" )
AddRadiusActionEffectsForFurnitureStateToggle( 996, 997, EHT.STATE.ON2, "ON (2)" )
AddRadiusActionEffectsForFurnitureStateToggle( 998, 999, EHT.STATE.ON3, "ON (3)" )
AddRadiusActionEffectsForFurnitureStateToggle( 1000, 1001, EHT.STATE.ON4, "ON (4)" )
AddRadiusActionEffectsForFurnitureStateToggle( 1002, 1003, EHT.STATE.ON5, "ON (5)" )
AddRadiusActionEffectsForFurnitureStateToggle( 1004, 1005, EHT.STATE.ON, "ON", EHT.STATE.OFF, "OFF" )

do
	local FIRST_PERSON = 1
	local THIRD_PERSON = 2
	
	local cameraModeEffects = {}
	
	local function UpdateCameraMode()
		local nearestEffect, nearestEffectDistance = nil, math.huge

		for effect, distance in pairs( cameraModeEffects ) do
			if distance < nearestEffectDistance then
				nearestEffect = effect
				nearestEffectDistance = distance
			end
		end

		if not nearestEffect then
			EHT.Util.RestorePreferredCameraMode()
			EVENT_MANAGER:UnregisterForUpdate( "EHT.Effect.UpdateCameraMode" )
			return
		end

		if nearestEffect.CameraMode == FIRST_PERSON then
			EHT.Util.SetCameraToFirstPerson()
		else
			EHT.Util.SetCameraToThirdPerson()
		end
	end

	local function AddCameraModeEffectType( id, effectName, cameraMode )
		return EHT.EffectType:New( id, effectName, {
			AutoPreview = false,
			Category = CAT.CUSTOM,
			CanPitch = false,
			ResetOnScale = true,
			ResetOnPosition = true,
			ResetOnOrient = false,

			Init = function( self )
				self.CameraMode = cameraMode
				self:SetAutoColorEnabled( false )
				self:SetAutoDrawLevelEnabled( false )
				self:SetAutoOrientationEnabled( false )
				self:SetColor( 1, 1, 1, 1 )

				local p = self:AddParticle( TEXTURES.SPHERE,		0, 0, 0,	RAD90, 0, 0,	0, 0, 0, 1,		1, 1,		false, false, false )
				p:SetHidden( true )

				self:SetSize( 1000, 1000, 1000 )
				self:SpawnAtPlayer( 0 )

				local r = self:GetSize()
				self.Radius = 0.5 * r
			end,

			Update = function( self )
				local p = self.Particles[1]
				local playerDistance = p:GetPlayerCharacterDistance()
				local inRange = playerDistance <= self.Radius

				if inRange then
					cameraModeEffects[ self ] = playerDistance
					EVENT_MANAGER:RegisterForUpdate( "EHT.Effect.UpdateCameraMode", 500, UpdateCameraMode )
				else
					cameraModeEffects[ self ] = nil
				end

				if self ~= CurrentEditorEffect or EHT.Housing.IsHUDMode() then
					p:SetHidden( true )
				else
					local red = inRange and 0 or 1
					p:FaceCamera()
					p:SetColor( red, 1, 1, 0.5 )
					p:SetHidden( false )
				end
			end,

			Reset = function( self )
				local r = self:GetSize()
				self.Radius = 0.5 * r
				self:SetSize( r, r, r )
				self:Update()
			end,
			
			Destroy = function( self )
				cameraModeEffects[ self ] = nil
			end,
		} )
	end

	AddCameraModeEffectType( 1006, "First Person Camera", FIRST_PERSON )
	AddCameraModeEffectType( 1007, "Third Person Camera", THIRD_PERSON )
end

EHT.EffectType.AddFlareEffect( 1008, "Prismatic Flare",
{
	AngleRange = RAD90,
	Color = { 1, 1, 1, 0.75, },
	Interval = 6000,
	Prismatic = true,
	Texture = TEXTURES.LENS_FLARE_3,
} )

do
	local et = EHT.EffectType:New( 1009, "Toggle one item with another item", {
		AutoPreview = false,
		Category = CAT.ACTION,
		CanPitch = false,
		ResetOnScale = false,
		ResetOnPosition = false,
		ResetOnOrient = false,
		MetaParams =
		{
			{
				Name = "When Furniture", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
			},
			{
				Name = "Is", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
			},
			{
				Name = "Then Furniture", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
			},
			{
				Name = "Will Be", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
			},
		},

		Init = function( self )
			self:SetAutoColorEnabled( false )
			self:SetAutoDrawLevelEnabled( false )
			self:SetAutoOrientationEnabled( false )
			self:SetColor( 1, 1, 1, 1 )
			self:SetSize( 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 150 )
		end,

		OnFurnitureStateChanged = function( self, furnitureId, newState, oldState )
			if not self.targetFurnitureId or not self.targetFurnitureState then
				return
			end

			if furnitureId ~= self.sourceFurnitureId then
				return
			end

			if newState ~= self.sourceFurnitureState and self.sourceFurnitureState ~= EHT.STATE.TOGGLE then
				return
			end

			EHT.Housing.SetFurnitureState( self.targetFurnitureId, self.targetFurnitureState )
		end,

		Reset = function( self )
			EHT.EffectFurnitureStateManager:UnregisterHandler( self.sourceFurnitureId, self )
			
			self.sourceFurnitureId = self:GetMetaData( "When Furniture" )
			self.sourceFurnitureState = self:GetMetaData( "Is" )
			self.targetFurnitureId = self:GetMetaData( "Then Furniture" )
			self.targetFurnitureState = self:GetMetaData( "Will Be" )

			EHT.EffectFurnitureStateManager:RegisterHandler( self.sourceFurnitureId, self )
		end,
		
		Destroy = function( self )
			EHT.EffectFurnitureStateManager:UnregisterHandler( self.sourceFurnitureId, self )
		end,
	} )

	AddFurnitureIndicatorsToActionEffect( et, { "When Furniture", "Then Furniture" } )
end

do
	local et = EHT.EffectType:New( 1010, "Toggle a group of items with another item", {
		AutoPreview = false,
		Category = CAT.ACTION,
		CanPitch = false,
		ResetOnScale = false,
		ResetOnPosition = false,
		ResetOnOrient = false,
		MetaParams =
		{
			{
				Name = "When Furniture", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
			},
			{
				Name = "Is", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
			},
			{
				Name = "Then Group", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
			},
			{
				Name = "Then Group Furniture", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
			},
			{
				Name = "Will Be", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
			},
		},

		Init = function( self )
			self:SetAutoColorEnabled( false )
			self:SetAutoDrawLevelEnabled( false )
			self:SetAutoOrientationEnabled( false )
			self:SetColor( 1, 1, 1, 1 )
			self:SetSize( 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 150 )
		end,

		OnFurnitureStateChanged = function( self, furnitureId, newState, oldState )
			if not self.targetFurnitureIdList or not self.targetFurnitureState then
				return
			end

			if furnitureId ~= self.sourceFurnitureId then
				return
			end

			if newState ~= self.sourceFurnitureState and self.sourceFurnitureState ~= EHT.STATE.TOGGLE then
				return
			end

			EHT.Housing.SetFurnitureState( self.targetFurnitureIdList, self.targetFurnitureState )
		end,

		Reset = function( self )
			EHT.EffectFurnitureStateManager:UnregisterHandler( self.sourceFurnitureId, self )
			
			self.sourceFurnitureId = self:GetMetaData( "When Furniture" )
			self.sourceFurnitureState = self:GetMetaData( "Is" )
			self.targetFurnitureIds = self:GetMetaData( "Then Group Furniture" )
			self.targetFurnitureIdList = self.targetFurnitureIds and { SplitString( "\,", self.targetFurnitureIds ) } or { }
			self.targetFurnitureState = self:GetMetaData( "Will Be" )

			EHT.EffectFurnitureStateManager:RegisterHandler( self.sourceFurnitureId, self )
		end,
		
		Destroy = function( self )
			EHT.EffectFurnitureStateManager:UnregisterHandler( self.sourceFurnitureId, self )
		end,
	} )

	AddFurnitureIndicatorsToActionEffect( et, { "When Furniture" } )
end

-- 12/9/2020
-- /sc StartChatInput( tostring( GetTimeStamp() ) )
EHT.EffectType:SetDefaultDateAdded( 1607495396 )

EHT.EffectType:New( 1011, "Smoke Plume", {
	Category = CAT.ANIM,
	CanPitch = false,

	Init = function( self )
		self:SetColor( 1, 1, 0.95, 1 )
		self:SetSize( 300, 400, 400 )
		self:SpawnAtPlayer( 200 )
		self:SetCameraFacing( true )

		local numP = 6
		local intervalOffset = math.random( 0, 10000 )

		for index = 1, numP do
			local percent = ( index - 1 ) / ( numP - 1 )
-- /script for i = 1, 6 do efp( 1 , i ).EasingScale = 3 end
			local r, g, b
			local m = index % 4
			if 0 == m then
				r, g, b = 1, 0.94, 0.94
			elseif 1 == m then
				r, g, b = 0.94, 1, 0.94
			elseif 1 == m then
				r, g, b = 0.94, 0.94, 1
			else
				r, g, b = 0.9, 0.9, 0.9
			end

			local p = self:AddParticle( TEXTURES.SMOKE_PLUME_1,		0, 0, 0,	0, 0, 0,	r, g, b, 1,		1, 1,		true, false, false )

			-- p.Interval = 9000
			-- p.IntervalOffset = intervalOffset + VariableEase( percent, 3 ) * p.Interval
			p.Interval = 12000
			p.IntervalOffset = intervalOffset + VariableEaseIn( percent, 2 ) * p.Interval * 0.7
			p.EasingAlpha = zo_lerp( 2.5, 4, percent )
			p.EasingScale = zo_lerp( 4, 2, percent )
			p.MaxAlpha = 0.9

			p.RangeX = zo_lerp( 10, 6, percent )
			local shiftX = percent * 0.2 - 0.1
			if 0 == index % 3 then
				p.OffsetX1, p.OffsetX2 = -1 + shiftX, 2 + shiftX
			else
				p.OffsetX1, p.OffsetX2 = 2 - shiftX, -1 - shiftX
			end

			p.RangeY = 5 + ( index - 1 ) * 0.5
			p.RangeY2 = 0.3 - percent * 0.3
			--p.RangeY2 = 0.1 + percent * 0.3
			p.OffsetY1 = -0.2
			p.OffsetY2 = 1
		end
	end,

	Update = function( self )
		for index, p in ipairs( self.Particles ) do
			local interval = GetLinearInterval( p.Interval, p.IntervalOffset )
			--local scaleInterval = 1 - VariableEaseOut( 1 - interval, p.EasingScale )
			local scaleInterval = VariableEaseIn( 1 - interval, p.EasingScale )
			local alphaInterval = InverseVariableEase( interval, p.EasingAlpha )
			local alpha = p.MaxAlpha * alphaInterval
			local offsetX, offsetY = p.RangeX * scaleInterval, p.RangeY * scaleInterval
			local offsetY2 = p.RangeY2 * interval

			if 0 >= p.OffsetX1 then
				p:SetTextureCoords( p.OffsetX1 - offsetX, p.OffsetX2 + offsetX, p.OffsetY1 - offsetY, p.OffsetY2 + offsetY2 )
			else
				p:SetTextureCoords( p.OffsetX1 + offsetX, p.OffsetX2 - offsetX, p.OffsetY1 - offsetY, p.OffsetY2 + offsetY2 )
			end

			p:SetAlpha( alpha )
			p:SetSampleProcessing( 1 + alphaInterval )
		end
	end,
} )

do
	local function ApplyEffect( effects, active )
		if effects then
			for _, effect in ipairs( effects ) do
				if effect.Active and not effect.Deleted then
					effect:SetHidden( active )
				end
			end
		end
	end
	
	local function OnStateChanged( self, furnitureId, newState, oldState )
		local originalNewState = newState
		if nil == newState then
			newState = EHT.Housing.GetFurnitureState( self.sourceFurnitureId )
		end

		local isActive = self.isActive
		if self.sourceFurnitureState == EHT.STATE.TOGGLE then
			if nil ~= originalNewState then
				isActive = not isActive
			end
		elseif newState == self.sourceFurnitureState then
			isActive = true
		else
			isActive = false
		end
		self.isActive = isActive

		CullTargetEffectList( self.TargetEffects )
		ApplyEffect( self.TargetEffects, isActive )
	end

	local function RefreshTargetEffects( self )
		ApplyEffect( self.TargetEffects, false )

		self.TargetEffects = EHT.Effect:GetById( tonumber( self:GetMetaData( "Target Effect" ) ), true )
		CullTargetEffectList( self.TargetEffects )

		EHT.EffectFurnitureStateManager:UnregisterHandler( self.sourceFurnitureId, self )
		self.sourceFurnitureId = self:GetMetaData( "When Furniture" )
		self.sourceFurnitureState = self:GetMetaData( "Is" )
		EHT.EffectFurnitureStateManager:RegisterHandler( self.sourceFurnitureId, self )

		-- Force refresh to match current state of source furniture.
		OnStateChanged( self )
	end

	local et = EHT.EffectType:New( 1012, "Toggle an item to hide FX", {
		AutoPreview = false,
		Category = CAT.ACTION,
		CanPitch = false,
		ResetOnScale = false,
		ResetOnPosition = false,
		ResetOnOrient = false,
		MetaParams =
		{
			{
				Name = "When Furniture", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
			},
			{
				Name = "Is", Deserializer = EHT.EffectDeserializers.StringVar, Serializer = EHT.EffectSerializers.StringVar
			},
			{
				Name = "Target Effect", Deserializer = EHT.EffectDeserializers.Int8, Serializer = EHT.EffectSerializers.Int8
			},
		},

		Init = function( self )
			self:SetAutoColorEnabled( false )
			self:SetAutoDrawLevelEnabled( false )
			self:SetAutoOrientationEnabled( false )
			self:SetColor( 1, 1, 1, 1 )
			self:SetSize( 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 150 )

			self.isActive = false
		end,

		OnFurnitureStateChanged = OnStateChanged,

		OnMetaDataChanged = RefreshTargetEffects,

		Reset = RefreshTargetEffects,

		Destroy = function( self )
			ApplyEffect( self.TargetEffects, false )
			EHT.EffectFurnitureStateManager:UnregisterHandler( self.sourceFurnitureId, self )
		end,
	} )

	AddFurnitureIndicatorsToActionEffect( et, { "When Furniture" } )
end

-- 2021-06-30
-- /sc StartChatInput(tostring(GetTimeStamp()))
EHT.EffectType:SetDefaultDateAdded(1625028940)

local function AddTornadoEffect(id, name, opt)
	local options = EHT.Util.CloneTable(opt)
	local rad30, rad90, rad180, rad360 = RAD45, RAD90, RAD180, RAD360
	local numP = 30

	return EHT.EffectType:New(id, name, {
		Category = CAT.WEATHER,
		CanPitch = false,
		ResetOnScale = true,

		Init = function(self)
			self:SetColor(unpack(options.color))
			self:SetContrast(options.contrast)
			self:SetSize(unpack(options.size))
			self:SetOrientation(0, 0, 0)
			self:SpawnAtPlayer(options.spawnOffsetY)

			self.CurrentYawOffset = 0
			self.CurrentSize = self:GetSize()
			self.RadiusSquared = self.CurrentSize * self.CurrentSize * 0.5
			self.Interval = options.interval
			self.IntervalOffset = math.random(0, options.interval)

			for index = 1, numP do
				local percent = (index - 1) / (numP - 1)
				local texture = (index <= options.textureTransitionIndex) and TEXTURES.WHIRLPOOL_3 or opt.texture
				local offsetY = 0 < options.distributionY and VariableEaseIn(percent, options.distributionY) or (1 - VariableEaseIn(percent, -options.distributionY))

				local alphaEasing
				if 0 < options.distributionAlpha then
					alphaEasing = VariableEaseIn(percent, options.distributionAlpha)
				else
					alphaEasing = VariableEaseOut(1 - percent, -options.distributionAlpha)
				end
				local alpha = zo_lerp(options.minAlpha, options.maxAlpha, alphaEasing)
				
				local red = 0.92 + 0.08 * math.sin((0.5 + percent) * 4 * math.pi)
				local green = 0.92 + 0.08 * math.sin(percent * 4 * math.pi)
				local p = self:AddParticle(texture,		0, offsetY, 0,		0, 0, 0,	red, green, 1, alpha,		1, 1,		true, false, false)

				p.BaseX, p.BaseZ = 0, 0

				p.Sampling = 1 - 0.2 * math.sin(((percent * 2) % 1) * rad180)
				p:SetSampleProcessing(p.Sampling)

				p.IntervalCoeff = (options.rotationBaseFactor + (numP - index) * options.rotationIncrementFactor) * (0 == index % 3 and 0.5 or 1) 
				p.IntervalOffset = (index % 7) * math.rad(51) * ((1 <= index % 3) and 1 or -1)

				p.TextureScale = options.maxScale - (options.maxScale - options.minScale) * VariableEaseOut(percent, options.distributionScale)
				local maxCenterOffset = options.maxCenterOffset * (1 - VariableEaseIn(percent, options.distributionMaxCenterOffset))
				p.maxCenterOffset = 0.48 * math.min(maxCenterOffset, 1 - p.TextureScale)
			end
		end,

		Update = function(self)
			local interval = GetLinearInterval(self.Interval, self.IntervalOffset)
			local theta = rad360 * interval
			local offsetTheta = theta * 100
			local centerOffsetAngleRange = zo_lerp(options.minCenterOffsetAngle, options.maxCenterOffsetAngle, 0.5 + 0.5 * math.sin(rad360 * interval * options.centerOffsetTransitionMultiplier))
			local maxOffsetTheta = offsetTheta + centerOffsetAngleRange
			local effectTarget = math.sin(((interval * 48) % 1) * rad180)

			local thunderInterval1 = GetLinearInterval(7000)
			local thunderInterval2 = (thunderInterval1 * 2 + 0.1) % 1
			local thunder1 = 9.2 * math.max(0, (math.sin(thunderInterval1 * rad180) - 0.9))
			local thunder2 = 4.3 * math.max(0, (math.sin(thunderInterval2 * rad180) - 0.8))
			
			local ex, ey, ez = self:GetPosition()
			local dx, dy, dz = CameraX - ex, CameraY - ey, CameraZ - ez
			local dxz = dx * dx + dz * dz
			local pitch, yaw, roll
			if dxz > self.RadiusSquared then
				yaw	= (rad90 + math.atan2(self.X - CameraX, self.Z - CameraZ)) % rad360
			else
				yaw = GetPlayerCameraHeading() - rad90
			end

			local pMin, pMax = self.Particles[1], self.Particles[numP]
			local maxY = pMax.Y - pMin.Y
			local camY = (CameraY or 0) - pMin.Y
			local heightOffset = zo_clamp((2 * (camY / maxY)) - 1, -2, 2) * 0.5
			local pitchDelta
			if heightOffset >= 0 then
				pitchDelta = zo_lerp(-rad30, 0, heightOffset)
			else
				pitchDelta = zo_lerp(rad30, 0, -heightOffset)
			end
			local headingX, headingY = math.sin(yaw), math.cos(yaw)
			local pitch, roll = headingX * pitchDelta + rad90, headingY * pitchDelta

			for index, p in ipairs(self.Particles) do
				p:SetOrientation(pitch, 0, roll)

				local m = index % 4
				local percent = index / numP
				local offset = p.IntervalOffset
				local rotation = offset + theta * p.IntervalCoeff
				local scale = p.TextureScale
				local offsetRotation = rotation + zo_lerp(offsetTheta, maxOffsetTheta, percent)
				local tx, ty = 0.5 + p.maxCenterOffset * math.sin(offsetRotation), 0.5 + p.maxCenterOffset * math.cos(offsetRotation)
				p:RotateCoords(rotation, tx, ty, scale, scale)

				local tt = percent > 0.5 and effectTarget or (1 - effectTarget)
				if 1 <= m then
					p:SetSampleProcessing(p.Sampling + (thunder1 * tt))
				else
					p:SetSampleProcessing(p.Sampling + (thunder2 * tt))
				end
			end
		end,

		Reset = function(self)
			self:SetAutoOrientationEnabled(false)
			self:SetAutoSizeEnabled(false)

			local sizeX, sizeY, sizeZ = self:GetSize()
			if options.aspectRatioX or options.aspectRatioY then
				local size
				if sizeX ~= self.CurrentSizeX then
					size = math.max(options.sizeMin[1], sizeX)
				else
					size = math.max(options.sizeMin[1], sizeZ)
				end
				self.CurrentSizeX = size
				self.RadiusSquared = self.CurrentSize * self.CurrentSize * 0.5
				self:SetSize(size, options.aspectRatioY and (options.aspectRatioY * size) or sizeY, size)
				self:Update()

				local pSizeX, pSizeY = (options.aspectRatioX or 1) * size, (options.aspectRatioX or 1) * size
				for index, p in ipairs(self.Particles) do
					p:SetSize(pSizeX, pSizeY)
				end
			else
				self.CurrentSizeX = sizeX
				self.RadiusSquared = self.CurrentSize * self.CurrentSize * 0.5
				self:Update()

				for index, p in ipairs(self.Particles) do
					p:SetSize(sizeX, sizeX)
				end
			end
		end,
	} )
end

do
	local baseOptions =
	{
		aspectRatioX = 1.0,
		aspectRatioY = 0.8,
		centerOffsetTransitionMultiplier = 40,
		color = {0.72, 0.86, 1, 1},
		contrast = 1.75,
		distributionAlpha = 1.0,
		distributionScale = 1.5,
		distributionMaxCenterOffset = 2,
		distributionY = 1,
		interval = 600000,
		maxAlpha = 1, minAlpha = 1,
		maxCenterOffset = 0.3,
		maxCenterOffsetAngle = math.rad(1000), minCenterOffsetAngle = math.rad(-800),
		maxScale = 1, minScale = 0.2,
		reverseOrderDrawLevel = true,
		rotationBaseFactor = 200,
		rotationIncrementFactor = 20,
		size = {1000, 1000, 1000}, sizeMin = {300, 300, 300},
		spawnOffsetY = 100,
		texture = TEXTURES.WHIRLPOOL_1,
		textureTransitionIndex = 1,
	}

	local options
	options = EHT.Util.CloneTable(baseOptions)
	AddTornadoEffect(1013, "Tornado, Natural", options)

	options = EHT.Util.CloneTable(baseOptions)
	options.color = {1.0, 0.47, 0.27, 1.0}
	options.contrast = 4.0
	AddTornadoEffect(1014, "Tornado, Fire", options)

	options = EHT.Util.CloneTable(baseOptions)
	options.aspectRatioX = 1
	options.aspectRatioY = 1.0
	options.centerOffsetTransitionMultiplier = 20
	options.color = {0.6, 0.86, 1.0, 1.0}
	options.contrast = 2.5
	options.distributionMaxCenterOffset = 1
	options.distributionScale = 1 -- 1.4
	options.distributionY = 1
	options.maxCenterOffset = 0.4
	options.maxCenterOffsetAngle = math.rad(480) options.minCenterOffsetAngle = math.rad(180)
	options.maxScale = 0.22 options.minScale = 0.3
	options.rotationIncrementFactor = 2
	options.textureTransitionIndex = 1
	AddTornadoEffect(1015, "Water Spout", options)

	options = EHT.Util.CloneTable(baseOptions)
	options.aspectRatioX = 3.0
	options.aspectRatioY = 2.0
	options.centerOffsetTransitionMultiplier = 30
	options.color = {0.6, 0.86, 1.0, 1.0}
	options.contrast = 2.5
	options.distributionMaxCenterOffset = 1
	options.distributionScale = 1.8
	options.distributionY = -1
	options.maxCenterOffset = 0.4
	options.maxCenterOffsetAngle = math.rad(720) options.minCenterOffsetAngle = -math.rad(1080)
	options.maxScale = 0.9 options.minScale = 0.3
	options.rotationIncrementFactor = 2
	options.size = {500, 500, 500} options.sizeMin = {150, 150, 150}
	options.spawnOffsetY = 600
	options.textureTransitionIndex = 1
	AddTornadoEffect(1016, "Tornado, Inverted", options)

	options = EHT.Util.CloneTable(baseOptions)
	options.aspectRatioX = 1 options.aspectRatioY = 0.5
	options.centerOffsetTransitionMultiplier = 20
	options.color = {0.7, 0.7, 0.7, 1}
	options.distributionY = 1
	options.interval = 1800000
	options.maxScale = 0.8 options.minScale = 0.8
	options.maxCenterOffset = 0.2
	options.maxCenterOffsetAngle = math.rad(720) options.minCenterOffsetAngle = -math.rad(720)
	options.rotationBaseFactor = 180
	options.rotationIncrementFactor = 6
	options.size = {800, 800, 800}
	options.texture = TEXTURES.WHIRLPOOL_4
	options.textureTransitionIndex = 0
	AddTornadoEffect(1019, "Whirlwind", options)
end

do
	local et = addSkyWindow(1017, CAT.BUILD, "Space (Transparent)", 40000000, 1, 1, true)
	et.MetaParams = { GetMetaParamByName( "Pattern Scale % (X)" ), GetMetaParamByName( "Pattern Scale % (Y)" ) }
	local reset = et.Reset
	et.Reset = function( self )
		local scaleX = zo_clamp( ( tonumber( self:GetMetaData( "Pattern Scale % (X)" ) ) or 100 ) / 100, 0.1, 10 )
		local scaleY = zo_clamp( ( tonumber( self:GetMetaData( "Pattern Scale % (Y)" ) ) or 100 ) / 100, 0.1, 10 )
		self.TextureScaleX, self.TextureScaleY = scaleX, scaleY
		reset( self )
	end
end

do
	local et = addSkyWindow(1018, CAT.ANIM, "Space, Warp (Transparent)", 15000, 0.025, 1, true, TEXTURES.STARS_2)
	et.MetaParams = { GetMetaParamByName( "Pattern Scale % (X)" ), GetMetaParamByName( "Pattern Scale % (Y)" ) }
	local reset = et.Reset
	et.Reset = function( self )
		local scaleX = zo_clamp( ( tonumber( self:GetMetaData( "Pattern Scale % (X)" ) ) or 100 ) / 100, 0.1, 10 )
		local scaleY = zo_clamp( ( tonumber( self:GetMetaData( "Pattern Scale % (Y)" ) ) or 100 ) / 100, 0.1, 10 )
		self.TextureScaleX, self.TextureScaleY = scaleX, scaleY
		reset( self )
	end
end

local function AddTimeOfDayActionEffectType(id, name, visibleStartHour, visibleEndHour, onActionStateChanged)
	return EHT.EffectType:New( id, name, {
		AutoPreview = false,
		Category = CAT.ACTION,
		CanPitch = false,
		Global = true,
		ResetOnColor = false,
		ResetOnOrient = false,
		ResetOnPosition = false,
		ResetOnScale = false,
		MetaParams =
		{
			{
				Name = "Target Effect", Deserializer = EHT.EffectDeserializers.Int8, Serializer = EHT.EffectSerializers.Int8
			}
		},

		Init = function( self )
			self.OnActionStateChanged = onActionStateChanged
			self.TargetEffects = EHT.Effect:GetById( tonumber( self:GetMetaData( "Target Effect" ) ), true )

			self:SetAutoColorEnabled( false )
			self:SetAutoOrientationEnabled( false )
			self:SetAutoPositionEnabled( false )
			self:SetAutoSizeEnabled( false )

			self:SetColor( 1, 1, 1, 0.5 )
			self:SetSize( 20, 20, 20 )
			self:SpawnAtPlayer( 0 )
		end,

		Update = function( self )
			local hour = TamrielTime.Hour
			local visible
			if visibleStartHour > visibleEndHour then
				visible = hour >= visibleStartHour or hour <= visibleEndHour
			else
				visible = hour >= visibleStartHour and hour <= visibleEndHour
			end

			if visible ~= self.AreTargetEffectsVisible then
				CullTargetEffectList( self.TargetEffects )
				self.AreTargetEffectsVisible = visible
				self.OnActionStateChanged( self, visible, self.TargetEffects )
			end
		end,

		OnMetaDataChanged = function( self, field, prevValue, newValue )
			if "Target Effect" == field then
				self.OnActionStateChanged( self, nil, self.TargetEffects )
				CullTargetEffectList( self.TargetEffects )
				self.IsActionActive = nil
				self.TargetEffects = EHT.Effect:GetById( newValue, true )
			end
		end,

		Reset = function( self, reason )
			self.TargetEffects = EHT.Effect:GetById( tonumber( self:GetMetaData( "Target Effect" ) ), true )
			self.AreTargetEffectsVisible = nil
			self:Update()
		end,

		Destroy = function( self )
			self.AreTargetEffectsVisible = nil
			CullTargetEffectList( self.TargetEffects )
			self.OnActionStateChanged( self, nil, self.TargetEffects )
		end,
	} )
end

do
	local LERP_INTERVAL = 3000

	do
		local function Action( self, active, effects )
			local r, g, b, a = self:GetColor()

			for _, effect in ipairs( effects ) do
				if nil == active then
					effect:UnmodifyColor()
					effect:SetHidden( false )
				elseif active then
					EHT.EffectLerp:New( effect, "Color", LERP_INTERVAL, function( effect, key, lerp )
						effect:ModifyColor( 0, 0, 0, 0, 1 - lerp )
						effect:SetHidden( false )
					end, function( effect )
						effect:UnmodifyColor()
					end )
				else
					EHT.EffectLerp:New( effect, "Color", LERP_INTERVAL, function( effect, key, lerp )
						effect:ModifyColor( 0, 0, 0, 0, lerp )
						effect:SetHidden( false )
					end, function( effect, key, lerp )
						effect:SetHidden( true )
						effect:UnmodifyColor()
					end )
				end
			end
		end

		AddTimeOfDayActionEffectType( 1020, "Hide at day time", 21, 4, Action )
		AddTimeOfDayActionEffectType( 1021, "Hide at night time", 5, 20, Action )
	end
end

-- 2021-07-02
-- /sc StartChatInput(tostring(GetTimeStamp()))
EHT.EffectType:SetDefaultDateAdded(1625208216)

local function AddWormholeEffect(options)
	local numP = 35

	return EHT.EffectType:New(options.index, options.name, {
		Category = options.category or CAT.ANIM,
		CanPitch = true,
		AutoSizeEnabled = false,
		AutoPositionEnabled = false,
		ResetOnScale = true,
		ResetOnPosition = true,
		Init = function(self)
			local maxIntervalMS, minIntervalMS = options.maxIntervalMS, options.minIntervalMS
			local offsetMS = math.random(0, maxIntervalMS)
			local maxOffsetMS, minOffsetMS = offsetMS + options.maxIntervalOffsetMS, offsetMS + options.minIntervalOffsetMS
			local maxScale, minScale = options.maxScale, options.minScale
			local texture = options.texture
			local colors = options.colors
			local numColors = colors and #colors or 0

			for index = 1, numP do
				local progress = index / numP
				local scale = zo_lerp(minScale, maxScale, progress)
				local r, g, b, a = 1, 1, 1, 1
				if numColors > 0 then
					local rightColorIndex = math.min(numColors, math.ceil(progress * numColors) + 1)
					local leftColorIndex = rightColorIndex - 1
					local rightColor = colors[rightColorIndex]
					local leftColor = colors[leftColorIndex]
					local progressMod = ((progress - 0.01) * numColors) % 1
					r = zo_lerp(leftColor[1], rightColor[1], progressMod)
					g = zo_lerp(leftColor[2], rightColor[2], progressMod)
					b = zo_lerp(leftColor[3], rightColor[3], progressMod)
					a = zo_lerp(leftColor[4], rightColor[4], progressMod)
				end

				local p = self:AddParticle(texture,		0, 0, 0,		0, 0, 0,		r, g, b, a,		scale, scale,	true, false, false)
				p.IntervalMS = zo_lerp(minIntervalMS, maxIntervalMS, progress)
				p.IntervalOffsetMS = zo_lerp(maxOffsetMS, minOffsetMS, progress)
			end

			self:SetColor(1, 1, 1, 1)
			self:SetSize(400, 400, 400)
			self:SetOrientation(0, 0, 0)
			self:SpawnAtPlayer(210)
		end,
		Update = function( self )
			local maxAlpha, minAlpha = options.maxAlpha or 1, options.minAlpha or 0
			local alphaInterval = options.alphaIntervalMS and GetLinearInterval(options.alphaIntervalMS)
			local sampleInterval = options.sampleIntervalMS and GetLinearInterval(options.sampleIntervalMS)
			local rad360 = -RAD360

			for index, p in ipairs(self.Particles) do
				local interval = GetLinearInterval(p.IntervalMS, p.IntervalOffsetMS)
				p:SetTextureRotation(rad360 * interval)
				if alphaInterval then
					local alphaProgress = EaseInOut2((alphaInterval + (index / numP)) % 1)
					p:SetAlpha(zo_lerp(minAlpha, maxAlpha, alphaProgress))
				end
				if sampleInterval then
					p:SetSampleProcessing(zo_lerp(0.5, 1.5, EaseInOut2((sampleInterval + (index / numP)) % 1)))
				end
			end
		end,
		Reset = function( self )
			local width, _, depth = self:GetSize()
			if width and depth then
				depth = math.max(2 * numP, depth)
				self:Update()

				local numPP = numP - 1
				for index, p in ipairs(self.Particles) do
					local offset = zo_lerp(-0.5, 0.5, (index - 1) / numPP)
					local x, y, z = EHT.World.Rotate(0, 0, offset * depth, self.Pitch, self.Yaw, self.Roll)
					p:SetPosition(self.X + x, self.Y + y, self.Z + z)
					p:SetSize(width, width)
				end
			end
		end,
	} )
end

do
	local options =
	{
		index = 1022,
		name = "Wormhole, Vortex",
		category = CAT.ANIM,
		maxIntervalMS = 3000,
		minIntervalMS = 1000,
		maxIntervalOffsetMS = 3000,
		minIntervalOffsetMS = 1000,
		maxScale = 1.0,
		minScale = 0.75,
		sampleIntervalMS = 2000,
		texture = TEXTURES.WHIRLPOOL_5,
	}
	AddWormholeEffect(options)
end

do
	local options =
	{
		index = 1023,
		name = "Wormhole, Spiral",
		category = CAT.ANIM,
		maxIntervalMS = 3000,
		minIntervalMS = 1000,
		maxIntervalOffsetMS = 3000,
		minIntervalOffsetMS = 1000,
		maxScale = 1.0,
		minScale = 1.0,
		alphaIntervalMS = 2000,
		texture = TEXTURES.WHIRLPOOL_5,
	}
	AddWormholeEffect(options)
end

do
	local options =
	{
		index = 1024,
		name = "Rainbow Tunnel",
		category = CAT.ANIM,
		maxAlpha = 1,
		minAlpha = 0.5,
		maxIntervalMS = 3000,
		minIntervalMS = 3000,
		maxIntervalOffsetMS = 3000,
		minIntervalOffsetMS = 0,
		maxScale = 1.0,
		minScale = 1.0,
		alphaIntervalMS = 2000,
		sampleIntervalMS = 2500,
		texture = TEXTURES.WHIRLPOOL_5,
		colors =
		{
			{0.75, 0, 1, 1},
			{0.5, 0.25, 1, 1},
			{0, 0, 1, 1},
			{0, 1, 0, 1},
			{1, 1, 0, 1},
			{1, 0.5, 0, 1},
			{1, 0, 0, 1},
		},
	}
	AddWormholeEffect(options)
end

--[[
	local function Action( self, active )
		local furnitureId = self:GetMetaData( "Furniture" )
		local furnitureState = EHT.Housing.GetFurnitureState( furnitureId )

		if furnitureState then
			if active and furnitureState ~= state then
				EHT.Housing.SetFurnitureState( furnitureId, state )
			else
				if inactiveState and not active and furnitureState ~= inactiveState then
					EHT.Housing.SetFurnitureState( furnitureId, inactiveState )
				end
			end
		end
	end
]]

--[[
do
	local function AddSphereEffect( id, name, options )
		local et = EHT.EffectType:New( id, name, {
			Category = CAT.GEO,
			CanPitch = false,
			ResetOnOrientation = false,
			Init = function( self )
				self.Options = options
				self.DensityAltitude = options.DensityAltitude or 18
				self.DensityAzimuth = options.DensityAzimuth or 36
				self.Texture = self.Options.Texture or TEXTURES.SOLID

				--local sizeY = 0.5 * EHT.World:GetCircumferenceSegmentSize( self.DensityAltitude, 0.25 * self.SizeY, 0.25 * self.SizeY, 0.25 )
				local sizeY = 1 / self.DensityAltitude
				--local sizeY = ( 0.5 * EHT.World:GetCircumferenceSegmentSize( self.DensityAltitude, self.SizeY, self.SizeY, 0.25 ) ) / self.SizeY
				local altitudeIncrement = RAD180 / ( self.DensityAltitude - 1 )
				local column, row = 0, 0

				for altitude = 0.5 * altitudeIncrement, RAD180, altitudeIncrement do
					row = row + 1

					local offsetY = math.sin( altitude - RAD90 )
					local offsetXZ = math.sin( altitude )
					local densityAzimuth = math.max( 6, self.DensityAzimuth * offsetXZ )
					local pitch = RAD90 - altitude
					--local sizeX = 0.5 * EHT.World:GetCircumferenceSegmentSize( self.DensityAzimuth, 0.25 * self.SizeX, 0.25 * self.SizeX, 0.5 )
					local sizeX = 1 / self.DensityAzimuth
					--local sizeX = EHT.World:GetCircumferenceSegmentSize( self.DensityAzimuth, self.SizeX, self.SizeX, 1 ) / ( self.SizeX * offsetXZ )
					local colorY = 0.35 + 0.65 * ( altitude / RAD180 )
					local sizeOffsetY = 0.01 * ( row % 2 )

					for azimuth = 0, RAD360, RAD360 / densityAzimuth do
						column = column + 1

						local offsetX, offsetZ = offsetXZ * math.sin( azimuth ), offsetXZ * math.cos( azimuth )
						local yaw = math.atan2( offsetX, offsetZ )
						local color = colorY * ( 1 - 0.25 * ( azimuth / RAD360 ) )
						local sizeOffsetX = 0.01 * ( column % 2 )

						self:AddParticle( self.Texture,		offsetX, offsetY, offsetZ,		pitch, yaw, 0,		color, color, color, 1,		sizeX + sizeOffsetX, sizeY + sizeOffsetY,		true, false, false )
					end
				end

				self:SetColor( unpack( self.Options.Color or { 1, 1, 1, 1, } ) )
				self:SetSize( 200, 200, 200 )
				self:SetOrientation( 0, 0, 0 )
				self:SpawnAtPlayer( self.Options.SpawnY or 200 )
			end,
			Reset = function( self )
				self:Update()
			end,
		} )
		return et
	end

	AddSphereEffect( 992, "Sphere", { Texture = TEXTURES.CLOUDS_1 } )
end
]]
--[[
local function AddRadarEffect( id, name, options )
	local et = EHT.EffectType:New( id, name, {
		Category = CAT.ANIM,
		CanPitch = false,
		ResetOnColor = false,
		ResetOnOrientation = false,
		ResetOnPosition = true,
		ResetOnScale = true,
		OrderDrawLevelByIndex = true,
		Init = function( self )
			self.MaxVisibleDistance = 100000
			self.EffectiveRadius = 500
			self.BeaconTexture = options.BeaconTexture or TEXTURES.BOUNDING_BOX
			self.ActiveValue = 0
			self.AlphaDistance = 15000
			self.IsActive = false
			self.LastUpdate = nil
			self.IsRenderingEnabled = true
			self.NumBeacons = options.NumBeacons or 700
			self.NumBeaconItems = 0
			self.TransitionIntervalMS = options.TransitionIntervalMS or 600
			self.FadeIntervalMS = options.FadeIntervalMS or 250
			self.FadeInterval = self.FadeIntervalMS / self.TransitionIntervalMS

			self.MungeIntervalMS = 8000
			self.Munge1, self.Munge2 = 2400, 1

			self.ObjectInterval1, self.ObjectIntervalOffset1 = 4000, 0
			self.ObjectInterval2, self.ObjectIntervalOffset2 = 2500, 400
			self.ObjectMargin1, self.ObjectMargin2 = 0.02, 0.015
			self.ObjectInset = 0

			self.FullscreenFade = self:AddParticle2D( TEXTURES.SOLID, 0, 0, 0, 0, 0, 0,		0, 0, 0, 1,		1, 1,	false, false, false )
			self.FullscreenFade:SetHidden( true )

			-- Prepare the maximum number of beacon particles to allow for seamless transitions into and out of the active state.
			self.Beacons = { }
			for index = 1, self.NumBeacons do
				local r = 0.9 + 0.1 * math.sin( ( ( index % 8 ) / 8 ) * RAD360 )
				local g = 0.9 + 0.1 * math.sin( ( ( 2 + index % 5 ) / 5 ) * RAD360 )
				local b = 0.9 + 0.1 * math.sin( ( ( 5 + index % 10 ) / 10 ) * RAD360 )
				p = self:AddParticle( self.BeaconTexture,		0, 0, 0,		RAD90, 0, 0,	r, g, b, 0,		1, 1,	false, false, false )
				p.Modulo = index % 4
				table.insert( self.Beacons, p )
			end

			self.FullscreenMunge = self:AddParticle2D( TEXTURES.SMOKE_1_TILE, 0, 0, 0, 0, 0, 0,		1, 1, 1, 1,		1, 1,	false, false, true )
			self.FullscreenMunge:SetHidden( true )
			self.FullscreenMunge:SetAutoColorEnabled( false )
			self.FullscreenMunge:SetDodge( true )
			self.FullscreenMunge:SetSampleProcessing( 1.5 )
			self.FullscreenMunge:SetColor( 0, 0, 0, 0 )
			self.FullscreenMunge:SetDrawLevel( 1 )
			self.FullscreenMunge.Texture:SetDrawLayer( DL_BACKGROUND )

			self:SetAutoPositionEnabled( false )
			self:SetAutoSizeEnabled( false )
			self:SetCameraFacing( true )
			self:SetColor( 1, 0.15, 0, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SetSize( self.EffectiveRadius, self.EffectiveRadius, self.EffectiveRadius )
			self:SpawnAtPlayer( 0.5 * self.EffectiveRadius )
		end,
		Update = function( self )
			local ft = GetFrameTimeMilliseconds()
			local activeValue = self.ActiveValue
			local activeValueCoefficient = 0
			local lastUpdate = self.LastUpdate or ft
			self.LastUpdate = ft

			if self:GetPlayerDistance() <= self.EffectiveRadius then
				activeValueCoefficient = 1
			else
				activeValueCoefficient = -1
			end
			
			if 0 ~= activeValueCoefficient then
				activeValue = zo_clamp( activeValue + activeValueCoefficient * ( ( ft - lastUpdate ) / self.TransitionIntervalMS ), 0, 1 )
				self.ActiveValue = activeValue
			end

			local generateBeacons = false
			local resetBeacons = false

			if self.FadeInterval > activeValue then
				if not self.IsRenderingEnabled then
					self.IsRenderingEnabled = true
					EHT.UI.SetWorldRenderingEnabled( true )
					resetBeacons = true
				end
			else
				if self.IsRenderingEnabled then
					self.IsRenderingEnabled = false
					EHT.UI.SetWorldRenderingEnabled( false )
					generateBeacons = true
					resetBeacons = true
				end
			end

			if resetBeacons then
				for index, beacon in ipairs( self.Beacons ) do
					beacon:SetHidden( true )
					beacon.FurnitureId = nil
				end
			end

			if 0 < activeValue and self.FadeInterval > activeValue then
				self.FullscreenFade:SetAlpha( ( 1 / self.FadeInterval ) * activeValue )
				self.FullscreenFade:SetHidden( false )
			else
				self.FullscreenFade:SetHidden( true )
			end

			if self.FadeInterval > activeValue then
				self.FullscreenMunge:SetHidden( true )
			else
				local mungeInterval = GetLinearInterval( self.MungeIntervalMS )
				local sine = math.sin( mungeInterval * RAD360 )
				local mungeColor = 0.5 * sine
				local wave = 0.02 * sine

				self.FullscreenMunge:SetTextureCoords( wave + self.Munge1, wave, mungeInterval, mungeInterval + self.Munge2 )
				self.FullscreenMunge:SetColor( 0.5 + mungeColor, 0.5, 0.5 - mungeColor, 0.9 )
				self.FullscreenMunge:SetHidden( false )
			end

			if generateBeacons then
				local items = { }
				local id = GetNextPlacedHousingFurnitureId( nil )

				while id do
					local x, y, z = EHT.Housing.GetFurnitureCenter( id )
					local distance = zo_distance3D( x, y, z, CameraX, CameraY, CameraZ )
					if distance <= self.MaxVisibleDistance then
						local item = { id = id, distance = distance, x = x, y = y, z = z, }
						table.insert( items, item )
					end
					id = GetNextPlacedHousingFurnitureId( id )
				end

				table.sort( items, function( left, right )
					return left.distance < right.distance
				end )

				local beaconItems = { }
				self.BeaconItems = beaconItems

				local maxItemIndex = math.min( #items, self.NumBeacons )
				if 0 < maxItemIndex then
					for index = maxItemIndex, 1, -1 do
						local item = items[ index ]
						if index > self.NumBeacons then
							break
						end
						item.distanceAlpha = zo_lerp( 1, 0, zo_clamp( item.distance / self.MaxVisibleDistance, 0, 1 ) )
						item.sizeX, item.sizeY, item.sizeZ = EHT.Housing.GetFurnitureLocalDimensions( item.id )
						table.insert( beaconItems, item )
					end
				end

				self.NumBeaconItems = #beaconItems
				for index, item in ipairs( self.BeaconItems ) do
					local beacon = self.Beacons[ index ]
					beacon:SetAlpha( 0 )
					beacon:SetSampleProcessing( 0.1 + item.distanceAlpha )
					beacon:SetPosition( item.x, item.y, item.z )
					beacon.sizeX, beacon.sizeY, beacon.sizeZ = item.sizeX, item.sizeY, item.sizeZ
					--beacon:SetSize( 0.6 * ( item.sizeX + item.sizeZ ), 1.2 * item.sizeY )
					beacon:SetHidden( false )
				end

				local minIndex = #beaconItems + 1
				if minIndex <= self.NumBeacons then
					for index = minIndex, self.NumBeacons do
						self.Beacons[ index ]:SetHidden( true )
					end
				end
			end

			if self.FadeInterval <= activeValue then
				local i1 = GetEasedInterval( self.ObjectInterval1, self.ObjectIntervalOffset1 )
				local i2 = GetEasedInterval( self.ObjectInterval2, self.ObjectIntervalOffset2 )
				local uv1, uv2, uv3, uv4 = self.ObjectMargin1 * i1, self.ObjectMargin1 * i2, self.ObjectMargin2 * i1, self.ObjectMargin2 * i2

				local i3 = GetEasedInterval( self.ObjectInterval1 * 1.3, self.ObjectIntervalOffset1 )
				local i4 = GetEasedInterval( self.ObjectInterval2 * 1.3, self.ObjectIntervalOffset2 * 1.5 )
				local uv5, uv6, uv7, uv8 = self.ObjectMargin1 * i3, self.ObjectMargin1 * i4, self.ObjectMargin2 * i3, self.ObjectMargin2 * i4

				local inset1 = self.ObjectInset
				local inset2 = 1 - inset1

				local uvs =
				{
					{ inset1 + uv1, inset1 - uv3, },
					{ inset2 + uv2, inset1 - uv4, },
					{ inset1 + uv1, inset2 + uv3, },
					{ inset2 + uv2, inset2 + uv4, },

					{ inset1 + uv7, inset1 - uv5, },
					{ inset2 + uv8, inset1 - uv6, },
					{ inset1 + uv7, inset2 + uv5, },
					{ inset2 + uv8, inset2 + uv6, },
				}

				local alpha = VariableEaseIn( ( 1 / ( 1 - self.FadeInterval ) ) * ( activeValue - self.FadeInterval ), 2 )
				for index = 1, self.NumBeaconItems do
					local beacon = self.Beacons[ index ]
					local item = self.BeaconItems[ index ]
					local itemAlpha = item and alpha or 0
					itemAlpha = itemAlpha * ( 1 - zo_distance3D( beacon.X, beacon.Y, beacon.Z, PlayerX, PlayerY, PlayerZ ) / self.AlphaDistance )
					beacon:SetAlpha( itemAlpha )

					if 0 < itemAlpha then
						local tex = beacon.Texture
						local mod = beacon.Modulo
						if 0 == mod then
							tex:SetVertexUV( 1, unpack( uvs[1] ) )
							tex:SetVertexUV( 2, unpack( uvs[2] ) )
							tex:SetVertexUV( 4, unpack( uvs[3] ) )
							tex:SetVertexUV( 8, unpack( uvs[4] ) )
						elseif 1 == mod then
							tex:SetVertexUV( 2, unpack( uvs[1] ) )
							tex:SetVertexUV( 1, unpack( uvs[2] ) )
							tex:SetVertexUV( 8, unpack( uvs[3] ) )
							tex:SetVertexUV( 4, unpack( uvs[4] ) )
						elseif 2 == mod then
							tex:SetVertexUV( 1, unpack( uvs[5] ) )
							tex:SetVertexUV( 2, unpack( uvs[6] ) )
							tex:SetVertexUV( 4, unpack( uvs[7] ) )
							tex:SetVertexUV( 8, unpack( uvs[8] ) )
						else
							tex:SetVertexUV( 2, unpack( uvs[5] ) )
							tex:SetVertexUV( 1, unpack( uvs[6] ) )
							tex:SetVertexUV( 8, unpack( uvs[7] ) )
							tex:SetVertexUV( 4, unpack( uvs[8] ) )
						end

						local dx, dy, dz = CameraX - beacon.X, CameraY - beacon.Y, CameraZ - beacon.Z
						local nx, ny, nz = NormalVector( dx, dy, dz )
						local sx, sy, sz = beacon.sizeX * nx, beacon.sizeY * ny, beacon.sizeZ * nz
						--beacon:SetPosition( GuiRender3DPositionToWorldPosition( tex:Convert3DLocalPositionToWorldPosition( 0.01 * sx, 0.01 * sy, 0.01 * sz ) ) )
						beacon:SetSize( sx + sz, sy )
					end
				end
			end
		end,
		Reset = function( self )
			local radius = math.max( self:GetSize() )
			self.EffectiveRadius = radius
			--self:Update()
		end,
		Destroy = function( self )
			if not self.IsRenderingEnabled then
				EHT.UI.SetWorldRenderingEnabled( true )
			end
		end,
		OnVisibilityChanged = function( self, hidden )
			if hidden then
				if not self.IsRenderingEnabled then
					EHT.UI.SetWorldRenderingEnabled( true )
				end
			else
				if not self.IsRenderingEnabled then
					EHT.UI.SetWorldRenderingEnabled( false )
				end
			end
		end,
	} )
	return et
end

AddRadarEffect( 992, "Night Vision", { BeaconTexture = TEXTURES.MUNGE_SPOT } )
]]
--[[
local function AddStarEffect( id, name, options )
	local et = EHT.EffectType:New( id, name, {
		Category = CAT.ANIM,
		CanPitch = true,
		Init = function( self )
			self.Interval = options.interval or 10000
			self.IntervalOffset = math.random( 2000 ) + 2000 * self.Index
			self.Density = options.density
			self.Layers = options.layers
			self.Stars = { }
			local minSize, maxSize = 1 / ( self.Density / 2 ), 1 / self.Density

			for starIndex = 1, self.Density do
				local star = { }
				self.Stars[starIndex] = star

				local offsetX, offsetY, offsetZ = 0, 0, 0
				local size = 1
				if 1 < self.Density then
					local starRatio = ( starIndex - 1 ) / ( self.Density - 1 )
					size = zo_lerp( maxSize, minSize, starRatio )
					offsetX, offsetY, offsetZ = 0.5 * math.sin( starRatio * RAD270 ), -0.5 + ( starIndex % 2 == 0 and starRatio or ( 1 - starRatio ) ), 0.5 * math.cos( starRatio * RAD180 )
				end

				local colorInterval = ( starIndex - 1 ) / ( self.Density - 1 )
				local r = 0.85 + 0.15 * math.sin( RAD360 * colorInterval )
				local g = 0.85 + 0.15 * math.sin( RAD360 * ( ( colorInterval + 0.33 ) % 1 ) )
				local b = 0.85 + 0.15 * math.sin( RAD360 * ( ( colorInterval + 0.66 ) % 1 ) )
				for layerIndex = 1, self.Layers do
					local c = 0.5 + 0.5 * ( ( layerIndex - 1 ) / ( self.Layers - 1 ) )
					local p = self:AddParticle( options.texture or TEXTURES.STARBURST_3,		offsetX, offsetY, offsetZ,		RAD90, 0, 0,	c * r, c * g, c * b, 1,		size, size,		true, false, false )
					table.insert( star, p )
				end
			end

			self:SetCameraFacing( true )
			self:SetColor( unpack( options.color ) )
			self:SetContrast( options.contrast )
			self:SetSize( 200, 200, 200 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( options.spawnY or 150 )
		end,
		Update = function( self )
			local interval = GetLinearInterval( self.Interval, self.IntervalOffset )
			local numP = self.Layers - 1

			for layerIndex = 1, self.Layers do
				local ratio = 1 - ( ( layerIndex - 1 ) / numP )
				local period = ( interval + ratio ) % 1
				local alpha = EaseOutIn2( period )
				local ratioAlpha = ratio * alpha
				local baseAngle = ratio * RAD90
				local size = 1 - 0.3 * ratio
				local sizeX, sizeY
				if layerIndex % 2 == 0 then
					sizeX, sizeY = size, size + 0.05 * alpha
				else
					sizeY, sizeX = size, size + 0.05 * alpha
				end

				for starIndex, star in ipairs( self.Stars ) do
					local p = star[layerIndex]

					p:RotateCoords( baseAngle + alpha * RAD15, 0.5, 0.5, sizeX, sizeY )
					p:SetSampleProcessing( 0.5 + ratioAlpha )
					p:SetColorOffsets( nil, nil, nil, 0.35 + 0.65 * ratioAlpha )
				end
			end
			
			self:Update()
		end,
	} )
	return et
end

AddStarEffect( 990, "Star, Sparkling", {
	color = { 1, 0.9, 0.25, 1 },
	contrast = 1.5,
	density = 1,
	layers = 3,
	interval = 9000,
	texture = TEXTURES.STARBURST_3,
} )

AddStarEffect( 991, "Star Cluster, Sparkling", {
	color = { 1, 0.9, 0.25, 1 },
	contrast = 1.5,
	density = 5,
	layers = 3,
	interval = 9000,
	texture = TEXTURES.STARBURST_3,
} )
]]
-- /script EVENT_MANAGER:RegisterForUpdate( "test", 1000, function() d( eff(1).Options.MinOffsetX ) end )
-- /script eff(1).Options.OnUpdate=function(self,opt,interval) local int=1-math.abs(-1 + 2 * ( ( 16 * interval ) % 1 ) ) local radius = int opt.MinOffsetX, opt.MinOffsetY, opt.MaxOffsetX, opt.MaxOffsetY = radius, radius, radius, radius opt.ScaleX=0.1 + 0.1 * int opt.ScaleY=0.5*opt.ScaleX d(opt.ScaleX) end
-- /script eff(1).Options.OnUpdate=function(self,opt,interval) opt.PeriodMultiplier = 10 + math.abs( -1 + 2 * ( (5 * interval) % 1) ) end

--[[
do
	local activated, deactivated = { }, { }
	local registered = false
	local speed = 0.01

	local function Update()
		for effect, _ in pairs( activated ) do
			if not effect.Active or effect.Deleted then
				activated[effect] = nil
			else
				local tx, ty, tz = effect:GetPositionModifier()
				ty = math.sin( RAD180 * GetLinearInterval( effect.LevitationInterval ) ) * effect.LevitationRange
				effect:ModifyPosition( tx, ty, tz )
			end
		end

		for effect, _ in pairs( deactivated ) do
			if not effect.Active or effect.Deleted then
				deactivated[effect] = nil
			else
				local tx, ty, tz = effect:GetPositionModifier()
				if -1 < tx and 1 > tx and -1 < ty and 1 > ty and -1 < tz and 1 > tz then
					deactivated[effect] = nil
				else
					effect:ModifyPosition( tx, zo_lerp( ty, 0, speed ), tz )
				end
			end
		end
	end

	local function Action( self, active, effects )
		if not registered then
			registered = true
			EVENT_MANAGER:RegisterForUpdate( "EHT_ActionFX_Levitate", 1, Update )
		end

		for _, effect in ipairs( effects ) do
			effect.LevitationRange = zo_clamp( self.SizeY, 20, 1000 )
			effect.LevitationInterval = zo_lerp( 4500, 15000, 1 - EaseOut2( effect.LevitationRange / 1000 ) )

			if nil == active then
				effect:UnmodifyPosition()
				activated[effect] = nil
				deactivated[effect] = nil
			elseif active and not activated[effect] then
				activated[effect] = true
				deactivated[effect] = nil
			elseif not active and activated[effect] then
				deactivated[effect] = true
				activated[effect] = nil
			end
		end
	end

	AddActionEffect( 982, "Levitate", Action, false, true )
end

do
	local activated, deactivated = { }, { }
	local registered = false
	local speed = 0.1

	local function Update()
		for effect, _ in pairs( activated ) do
			if not effect.Active or effect.Deleted then
				activated[effect] = nil
			else
				local tx, ty, tz = effect:GetPositionModifier()
				tx = math.sin( RAD360 * GetLinearInterval( effect.SwirlInterval ) ) * effect.SwirlRange
				tz = math.cos( RAD360 * GetLinearInterval( effect.SwirlInterval ) ) * effect.SwirlRange
				effect:ModifyPosition( tx, ty, tz )
			end
		end

		for effect, _ in pairs( deactivated ) do
			if not effect.Active or effect.Deleted then
				deactivated[effect] = nil
			else
				local tx, ty, tz = effect:GetPositionModifier()
				if -1 < tx and 1 > tx and -1 < ty and 1 > ty and -1 < tz and 1 > tz then
					effect:ModifyPosition( 0, ty, 0 )
					deactivated[effect] = nil
				else
					effect:ModifyPosition( zo_lerp( tx, 0, speed ), ty, zo_lerp( tz, 0, speed ) )
				end
			end
		end
	end

	local function Action( self, active, effects )
		if not registered then
			registered = true
			EVENT_MANAGER:RegisterForUpdate( "EHT_ActionFX_Swirl", 1, Update )
		end

		for _, effect in ipairs( effects ) do
			effect.SwirlRange = zo_clamp( self.SizeX, 20, 1000 )
			effect.SwirlInterval = zo_lerp( 4500, 15000, 1 - EaseOut2( effect.SwirlRange / 1000 ) )
			effect.SwirlRange = effect.SwirlRange / 2

			if nil == active then
				effect:UnmodifyPosition()
				activated[effect] = nil
				deactivated[effect] = nil
			elseif active and not activated[effect] then
				activated[effect] = true
				deactivated[effect] = nil
			elseif not active and activated[effect] then
				deactivated[effect] = true
				activated[effect] = nil
			end
		end
	end

	AddActionEffect( 983, "Swirl", Action, true, false )
end
]]
---[ Library Effects ]---

do
	local canShowBook = true

	function EHT.Effect:GetCanShowLoreBook()
		return canShowBook
	end

	function EHT.Effect:SetCanShowLoreBook( value )
		canShowBook = value
	end

	do
		-- Choose a Lore Book

		local function ShowLoreBook( self )
			if EHT.Effect:GetCanShowLoreBook() and 0 ~= self.CategoryIndex and 0 ~= self.CollectionIndex and 0 ~= self.BookIndex then
				EHT.UI.ShowSpecificBook( self.CategoryIndex, self.CollectionIndex, self.BookIndex, false )
			else
				EHT.UI.ShowBook( "", string.format( "|c000000\nThe pages of this %s are seemingly blank...", self.EffectType.BookDefaultName or "" ) )
			end
		end

		local function initFunc( self )
			local ps = self.Particles
			local cover = self.EffectType.TextureCover

			self:AddParticle( cover,				0, 0, 3,		0, 0, 0,						1, 1, 1, 1,		1, 1,		true, false, false )
			self:AddParticle( cover,				0, 0, -3,		0, 0, 0,						1, 1, 1, 1,		1, 1,		true, false, false )
			self:AddParticle( cover,				-0.5, 0, 0,		0, 0.5*math.pi, 0,				1, 1, 1, 1,		1, 1,		true, false, false )
			self:AddParticle( TEXTURES.TOME_1_P,	0.5, 0, 0,		0, 0.5*math.pi, 0,				1, 1, 1, 1,		1, 1,		true, false, false )
			self:AddParticle( TEXTURES.TOME_1_P,	0, 0.5, 0,		0.5*math.pi, 0.5*math.pi, 0,	1, 1, 1, 1,		1, 1,		true, false, false )
			self:AddParticle( TEXTURES.TOME_1_P,	0, -0.5, 0,		0.5*math.pi, 0.5*math.pi, 0,	1, 1, 1, 1,		1, 1,		true, false, false )

			self:SetSize( (881/999)*30, 30, 30 )
			self:SetOrientation( 0, 0, 0 )
			self:SetColor( 0.7, 0.7, 0.7, 1 )
			self:SpawnAtPlayer( 120 )

			self.ReticleRadius = 0.8 * math.max( self:GetSize() )
			self.CurrentBook = self
			EHT.Effect:SetCanShowLoreBook( true )
		end

		local function resetFunc( self )
			local categoryIndex = tonumber( self:GetMetaData( "Lore Category" ) ) or 0
			local collectionIndex = tonumber( self:GetMetaData( "Lore Collection" ) ) or 0
			local bookIndex = tonumber( self:GetMetaData( "Lore Book" ) ) or 0
			local bookName = GetLoreBookInfo( categoryIndex, collectionIndex, bookIndex )
			if "" == bookName then bookName = self.EffectType.BookDefaultName or "" end

			self.CategoryIndex = categoryIndex
			self.CollectionIndex = collectionIndex
			self.BookIndex = bookIndex
			self.BookName = bookName

			local sx, sy, sz = self:GetSize()
			self:SetSize( sx, sz, sz )

			local r, g, b = self:GetColor()
			local c = 0.5 + 0.5 * ( ( r + g + b ) / 3 )
			local ps = self.Particles
			local numP = #ps

			self.ReticleRadius = 0.8 * math.max( self:GetSize() )
			self:Update()

			ps[3]:SetSize( 6, sz )
			ps[6]:SetTextureCoords( 0, 1, 1, 0 )

			for index = 4, numP do
				local p = ps[index]
				p:SetColor( c, c, c, 1 )
				p:SetSize( 6, 5 <= index and sx or sz )
			end
		end

		local function updateFunc( self )
			if EHT.Housing.IsHUDMode() and not IsGameCameraUIModeActive() and EHT.UI.IsBookHidden() and 500 > self:GetPlayerDistance() and EHT.UI.IsLorebookSelectionDialogHidden() and self.ReticleRadius >= GetMinReticleDistance( self.Particles[1]:GetPosition() ) then
				if self.lastClickCheck and EHT.LastMouseClick >= self.lastClickCheck then
					ShowLoreBook( self )
				elseif not self.Prompted then
					EHT.UI.ShowInteractionPrompt( "EHT_SHOW_GUEST_JOURNAL", "Read " .. ( self.BookName or "" ), function() ShowLoreBook( self ) end )
					self.Prompted = true
				end
			elseif self.Prompted then
				self.Prompted = false
				EHT.UI.HideInteractionPrompt()
			end

			self.lastClickCheck = FrameTime
		end

		local function destroyFunc( self )
			if self == self.CurrentBook then
				self.CurrentBook = nil
			end

			EHT.UI.HideInteractionPrompt()
		end

		local function AddLibraryEffect( id, name, defaultName, textureCover, colorR, colorG, colorB )
			local et = EHT.EffectType:New( id, name, {
				MetaParams = {
					{ Name = "Lore Book", Deserializer = EHT.EffectDeserializers.Int4, Serializer = EHT.EffectSerializers.Int4 },
					{ Name = "Lore Collection", Deserializer = EHT.EffectDeserializers.Int4, Serializer = EHT.EffectSerializers.Int4 },
					{ Name = "Lore Category", Deserializer = EHT.EffectDeserializers.Int4, Serializer = EHT.EffectSerializers.Int4 },
				},
				Category = CAT.LIBRARY,
				CanPitch = true,
				ResetOnColor = true,
				ResetOnOrient = true,
				ResetOnPosition = true,
				ResetOnScale = true,
				BookDefaultName = defaultName,
				TextureCover = textureCover,
				Init = initFunc,
				Reset = resetFunc,
				Update = updateFunc,
				Destroy = destroyFunc
			} )
			return et
		end

		EHT.EffectType:SetDefaultDateAdded( 1572415295 )

		AddLibraryEffect( 8000, "Any Single Volume, Worn", "worn book", TEXTURES.TOME_1_S )
		AddLibraryEffect( 8001, "Any Single Volume, Inset", "book", TEXTURES.TOME_2_S )
		AddLibraryEffect( 8002, "Any Single Volume, Intricate", "intricate book", TEXTURES.TOME_3_S )
	end

	do
		-- Custom Book

		local TITLE_FORMAT = "|c333300%s"
		local BODY_FORMAT = "|c000000%s"

		local function ShowCustomBook( self )
			if EHT.Effect:GetCanShowLoreBook() then
				local bookTitle = self.BookTitle or "Personal Journal"
				local bookMessage = self.BookMessage or "The pages are blank."
				EHT.UI.ShowBook( string.format( TITLE_FORMAT, bookTitle ), string.format( BODY_FORMAT, bookMessage ) )
			end
		end

		local function initFunc( self )
			local ps = self.Particles
			local cover = self.EffectType.TextureCover

			self:AddParticle( cover,				0, 0, 3,		0, 0, 0,						1, 1, 1, 1,		1, 1,		true, false, false )
			self:AddParticle( cover,				0, 0, -3,		0, 0, 0,						1, 1, 1, 1,		1, 1,		true, false, false )
			self:AddParticle( cover,				-0.45, 0, 0,	0, 0.5*math.pi, 0,				1, 1, 1, 1,		1, 1,		true, false, false )
			self:AddParticle( TEXTURES.TOME_1_P,	0.45, 0, 0,		0, 0.5*math.pi, 0,				1, 1, 1, 1,		1, 1,		true, false, false )
			self:AddParticle( TEXTURES.TOME_1_P,	0, 0.45, 0,		0.5*math.pi, 0.5*math.pi, 0,	1, 1, 1, 1,		1, 1,		true, false, false )
			self:AddParticle( TEXTURES.TOME_1_P,	0, -0.45, 0,	0.5*math.pi, 0.5*math.pi, 0,	1, 1, 1, 1,		1, 1,		true, false, false )

			self:SetSize( (881/999)*30, 30, 30 )
			self:SetOrientation( 0, 0, 0 )
			self:SetColor( 0.4, 0.25, 0.11, 1 )
			self:SpawnAtPlayer( 120 )

			self.ReticleRadius = 0.8 * math.max( self:GetSize() )
			self.CurrentBook = self
			EHT.Effect:SetCanShowLoreBook( true )
		end

		local function resetFunc( self )
			local THICKNESS = 6

			self.BookTitle = self:GetMetaData( "Title" ) or self.EffectType.BookDefaultName
			self.BookMessage = self:GetMetaData( "Message" ) or ""

			local sx, sy, sz = self:GetSize()
			self:SetSize( sx, sz, sz )

			local r, g, b = self:GetColor()
			local c = zo_lerp( 0.2, 0.4, math.max( r, g, b ) )
			local pr, pg, pb = c, c, c - 0.12
			local ps = self.Particles
			local numP = #ps

			self.ReticleRadius = 0.8 * math.max( self:GetSize() )
			self:Update()
			
			local _, normalY = self:GetNormalVector(0, 1, 0)
			normalY = normalY % 0.5
			normalY = math.abs(0.25 - normalY)
			normalY = normalY * 4
			normalY = 1 - normalY
			local innerOffset = 2 + 2 * normalY

			ps[3]:SetSize( THICKNESS - innerOffset, sz - innerOffset )

			for index = 1, 3 do
				local p = ps[index]
				p:SetVertexColors( 2, r * 0.9, g * 0.9, b * 0.9, 1 )
				p:SetVertexColors( 5, r * 0.7, g * 0.7, b * 0.7, 1 )
				p:SetVertexColors( 8, r,       g,       b,       1 )
			end

			ps[6]:SetTextureCoords( 0, 1, 1, 0 )

			for index = 4, 6 do
				local p = ps[index]
				p:SetCanModifyColor( true )
				p:SetVertexColors( 1, pr,       pg,       pb,       1 )
				p:SetVertexColors( 2, pr * 0.8, pg * 0.8, pb * 0.8, 1 )
				p:SetVertexColors( 4, pr * 0.6, pg * 0.6, pb * 0.6, 1 )
				p:SetVertexColors( 8, pr * 0.5, pg * 0.5, pb * 0.5, 1 )
				p:SetCanModifyColor( false )
				p:SetSize( THICKNESS - innerOffset, (4 == index and sz or sx) - innerOffset )
			end
		end

		local function updateFunc( self )
			if EHT.Housing.IsHUDMode() and not IsGameCameraUIModeActive() and EHT.UI.IsBookHidden() and 500 > self:GetPlayerDistance() and EHT.UI.IsLorebookSelectionDialogHidden() and self.ReticleRadius >= GetMinReticleDistance( self.Particles[1]:GetPosition() ) then
				if self.lastClickCheck and EHT.LastMouseClick >= self.lastClickCheck then
					ShowCustomBook( self )
				elseif not self.Prompted then
					EHT.UI.ShowInteractionPrompt( "EHT_SHOW_GUEST_JOURNAL", "Read " .. ( self.BookTitle or "" ), function() ShowCustomBook( self ) end )
					self.Prompted = true
				end
			elseif self.Prompted then
				self.Prompted = false
				EHT.UI.HideInteractionPrompt()
			end

			self.lastClickCheck = FrameTime
		end

		local function destroyFunc( self )
			if self == self.CurrentBook then
				self.CurrentBook = nil
			end

			EHT.UI.HideInteractionPrompt()
		end

		local function AddBookEffect( id, name, defaultName, textureCover, colorR, colorG, colorB )
			local et = EHT.EffectType:New( id, name, {
				MetaParams = {
					{
						Name = "Message",
						Deserializer = EHT.EffectDeserializers.StringVar,
						Serializer = EHT.EffectSerializers.StringVar,
					},
					{
						Name = "Title",
						Deserializer = EHT.EffectDeserializers.StringVar,
						Serializer = EHT.EffectSerializers.StringVar,
					},
				},
				Category = CAT.LIBRARY,
				CanPitch = true,
				AutoSizeEnabled = false,
				ResetOnColor = true,
				ResetOnOrient = true,
				ResetOnPosition = true,
				ResetOnScale = true,
				BookDefaultName = defaultName,
				TextureCover = textureCover,
				Init = initFunc,
				Reset = resetFunc,
				Update = updateFunc,
				Destroy = destroyFunc
			} )
			return et
		end

		EHT.EffectType:SetDefaultDateAdded( 1598240704 )

		AddBookEffect( 8501, "Custom Book, Worn", "worn journal", TEXTURES.TOME_1_S )
		AddBookEffect( 8502, "Custom Book, Inset", "personal journal", TEXTURES.TOME_2_S )
		AddBookEffect( 8503, "Custom Book, Intricate", "intricate journal", TEXTURES.TOME_3_S )
	end

end

---[ Portal Effects ]---

EHT.EffectType:SetDefaultDateAdded( 1551473040 )

do

	local jump

	local function IsJumpValid()
		if not jump or not jump.StartTime then
			return false
		end

		if	 jump.HouseId == GetCurrentZoneHouseId() and
			(jump.Owner == GetCurrentHouseOwner() or
				((not jump.Owner or "" == jump.Owner) and
				 EHT.Housing.IsOwner())) then
			EHT.Effect.OnPortalJumpComplete()
			return
		end
		
		if not jump.Px then
			jump.Px, jump.Py, jump.Pz = PlayerX, PlayerY, PlayerZ
		end

		if	24000 < ( FrameTime - jump.StartTime ) or
			jump.Px ~= PlayerX or
			jump.Py ~= PlayerY or
			jump.Pz ~= PlayerZ then
			return false
		end

		return true
	end

	local function JumpConfirmed()
		if not jump then return end

		if not IsJumpValid() then
			jump = nil
			return
		end

		--_, jump.Effect = EHT.EffectUI.AddEffect( "Reserved: Jumping" )
		EHT.UsingPortal = true

		EVENT_MANAGER:RegisterForUpdate( "EHT.Effect.MonitorPortalJump", 250, EHT.Effect.MonitorPortalJump )

		if not jump.HouseId then
			HousingEditorJumpToSafeLocation()
		elseif GetDisplayName() == jump.Owner then
			local msg = string.format( "|c00ffffTraveling to your |cffff00%s", jump.HouseName or "home" )

			d( msg )
			if EHT.GetBooleanSetting("EnablePortalDestinationOSD" ) then EHT.UI.ShowHint( msg ) end

			StopAllMovement()

			if 0 == jump.HouseId then
				RequestJumpToHouse( GetHousingPrimaryHouse() )
			else
				RequestJumpToHouse( jump.HouseId )
			end
		else
			local the = jump.HouseName and "the " == string.sub( string.lower( jump.HouseName ), 1, 4 ) and "" or "the "
			local msg = string.format( "|c00ffffTraveling to %s|cffff00%s|c00ffff of |cffff00%s", the, jump.HouseName or "home", jump.Owner or "someone" )

			d( msg )
			if EHT.GetBooleanSetting("EnablePortalDestinationOSD" ) then EHT.UI.ShowHint( msg ) end

			StopAllMovement()

			if 0 == jump.HouseId then
				JumpToHouse( jump.Owner )
			else
				JumpToSpecificHouse( jump.Owner, jump.HouseId )
			end
		end

	end

	local function CancelPortalJump( index )
		EHT.UI.HideHint()

		if jump and jump.Index == index then
			--if jump.Effect then
				--jump.Effect:Delete()
			--end

			EVENT_MANAGER:UnregisterForUpdate( "EHT.Effect.MonitorPortalJump" )

			jump = nil
			EHT.UsingPortal = false

			EHT.UI.HideAllDialogs()
		end
	end

	local function ConfirmPortalJump( index, houseName, houseId, owner )
		if not jump and EHT.Housing.IsHUDMode() then
			jump = { Index = index, HouseName = houseName, HouseId = houseId, Owner = owner, StartTime = FrameTime }
			local message

			if not jump.HouseId then
				HousingEditorJumpToSafeLocation()
				return false
			end

			StopAllMovement()

			if ( not owner and not houseId ) or ( EHT.Housing.IsOwner() and EHT.GetSetting( "AutoUsePortals" ) ) or ( not EHT.Housing.IsOwner() and EHT.GetSetting( "AutoUseHostPortals" ) ) then
				zo_callLater( JumpConfirmed, 500 )
				return true
			end

			message = string.format( "Travel to %s %s?", ( not owner or GetDisplayName() == owner ) and "your" or string.format( "%s's", owner ), houseName )
			EHT.UI.ShowConfirmationDialog( "", message, JumpConfirmed )

			return true
		else
			return false
		end
	end

	function EHT.Effect.MonitorPortalJump()
		if not IsJumpValid() then
			EVENT_MANAGER:UnregisterForUpdate( "EHT.Effect.MonitorPortalJump" )
			if jump then
				CancelPortalJump( jump.Index )
			end

			return
		end
	end

	function EHT.Effect.OnPortalJumpComplete()
		if EHT.UsingPortal then
			EssentialHousingHub:IncUMTD("n_ptl", 1)
			if jump then
				CancelPortalJump( jump.Index )
			end
		end
	end

	local function AddPortalEffect( id, name, houseId, houseName, image )
		EHT.EffectType:New( id, name, {
			Category = CAT.PORTALS,
			CanPitch = true,
			OrderDrawLevelByIndex = true,
			ResetOnOrient = true,
			ResetOnPosition = true,
			ResetOnScale = true,

			Init = function( self )
				self.Rings, self.Interval = 4, 3000
				self.IntervalOffset = math.random( 0, self.Interval )
				self.PlayerInside = true

				if image then
					local p = self:AddParticle( TEXTURES.CIRCLE_SOFT_2,	0, 0, 0,			0, 0, 0,	0.5, 0.5, 0.5, 1,	0.9, 0.9,	true, false, false )
					p:SetSampleProcessing( 0, 1 )

					for index = 1, self.Rings do
						p = self:AddParticle( TEXTURES.WHIRLPOOL_1,		0, 0, 3 * index,	0, 0, 0,	1, 1, 1, 0,			1.2, 1.2,	true, true, false )
						p:SetSampleProcessing( 0.8, 0 )
					end

					local sampling = houseId and 1 or 0.6

					p = self:AddParticle( image,	0, 0, 3 * ( 1 + self.Rings ),			0, 0, 0,	1, 1, 1, 0,			1, 1,		true, false, false )
					p:SetDodge( true )
					p:SetTextureCoords( 0, 0.7, 0, 0.75 )
					p:SetSampleProcessing( 0.85 * sampling, 0 )
					p:SetDesaturation( 1 )

					p = self:AddParticle( image,	0, 0, 3 * ( 2 + self.Rings ),			0, 0, 0,	1, 1, 1, 0,			1, 1,		true, false, false )
					p:SetDodge( true )
					p:SetTextureCoords( 0, 0.7, 0, 0.75 )
					p:SetSampleProcessing( sampling, 0 )
					p:SetDesaturation( 0 )
				else
					local p = self:AddParticle( TEXTURES.CIRCLE,				0, 0, 0,	0, 0, 0,	1, 1, 1, 0.5,		1, 1,		true, false, false )
					p:SetHidden( true )
				end

				self:SetSize( 600, 600, 600 )
				self:SetColor( 1, 1, 1, 1 )
				self:SpawnAtPlayer( 300 )
			end,

			Update = function( self )
				if image then
					local r, g, b, a = self:GetColor()
					local ps = self.Particles
					local tci = GetEasedInterval( TCO or 16000, self.IntervalOffset )
					local i = GetEasedInterval( 4000, self.IntervalOffset )
					local i2 = GetEasedInterval( 3200, self.IntervalOffset + 330 )
					local i3 = i
					local uv1, uv2, uv3, uv4 = 0.01 * i, 0.01 * i2, 0.02 * i, 0.02 * i2
					local c1, c2 = 0.8 - 0.1 * i, 0.8 - 0.1 * i2
					local ii = 1 / self.Rings
					local tcmin, tcmax = 0.05, 0.65
					if not houseId then
						tcmin, tcmax = 0, 1
					end
					local m, p, tex, ti

					p = ps[2 + self.Rings]
					tex = p.Texture
					tex:SetVertexUV( 1, tcmin + uv1, tcmin - uv3 )
					tex:SetVertexUV( 2, tcmax + uv2, tcmin - uv4 )
					tex:SetVertexUV( 4, tcmin + uv1, tcmax + uv3 )
					tex:SetVertexUV( 8, tcmax + uv2, tcmax + uv4 )
					p:SetVertexColors( 5, 1, 1, 1, c1 )
					p:SetVertexColors( 10, 1, 1, 1, c2 )

					tcmin, tcmax = tcmin + tci * 0.05, tcmax - tci * 0.05
					uv1, uv2 = 0.4 * uv1, 0.4 * uv2
					p = ps[3 + self.Rings]
					p:SetColor( 1, 1, 1, -i3 )
					tex = p.Texture
					tex:SetVertexUV( 1, tcmin - uv1, tcmin )
					tex:SetVertexUV( 2, tcmax - uv2, tcmin )
					tex:SetVertexUV( 4, tcmin - uv1, tcmax )
					tex:SetVertexUV( 8, tcmax - uv2, tcmax )

					i3 = zo_clamp( -i3, 0, 1 )
					p = self.Particles[1]
					p:SetColor( 0.5 * r + i3, 0.5 * g + i3, 0.5 * b + i3, a )
					p:SetSampleProcessing( 0, 1 - 0.7 * i3 )

					i = 1 - GetLinearInterval( self.Interval, self.IntervalOffset )

					for index = 1, self.Rings do
						p = ps[index + 1]
						m = index % 4
						ti = i

						p:SetColor( r, g, b, zo_clamp( math.sin( ( 0.01 + 0.98 * i ) * math.pi ), 0, 0.3 ) )
						p:SetSampleProcessing( 0.8 - 0.8 * i, 0 )

						if 0 == m then		p:SetTextureCoords( -ti, 1 + ti, -ti, 1 + ti )
						elseif 1 == m then	p:SetTextureCoords( 1 + ti, -ti, -ti, 1 + ti )
						elseif 2 == m then	p:SetTextureCoords( -ti, 1 + ti, 1 + ti, -ti )
						elseif 3 == m then	p:SetTextureCoords( 1 + ti, -ti, 1 + ti, -ti )
						end

						i = ( i + ii ) % 1
					end
				else
					self.Particles[1]:SetHidden( not EHT.Housing.IsSelectionMode() and not EHT.Housing.IsPlacementMode() )
				end

				if houseName and self.MaxLen then
					local x, y, z = self:GetPosition()
					local lenX, lenY, lenZ, maxLen = self.LenX, self.LenY, self.LenZ, self.MaxLen
					local playerX, playerY, playerZ = PlayerX, PlayerY + 100, PlayerZ

					local playerDistance = zo_distance3D( playerX, playerY, playerZ, x, y, z )
					local collision = false

					if playerDistance <= maxLen then
						local pitch, yaw, roll = self:GetOrientation()
						local pX, pY, pZ = EHT.World.Rotate( playerX - x, playerY - y, playerZ - z, -pitch, -yaw, -roll )

						if	pX >= -lenX and pX <= lenX and
							pY >= -lenY and pY <= lenY and
							pZ >= -lenZ and pZ <= lenZ then
							collision = true

							if not self.PlayerInside then
								self.PlayerInside = true
								ConfirmPortalJump( id, houseName, houseId, GetCurrentHouseOwner() )
							end
						end
					end

					if not collision and self.PlayerInside then
						self.PlayerInside = false
						CancelPortalJump( id )
					end
				end
			end,

			Reset = function( self )
				self:Update()

				self.LenX, self.LenY, self.LenZ, self.MaxLen = nil, nil, nil, nil
				local lenX, lenY, lenZ = self:GetSize()
				if not lenX then return end

				lenX, lenY, lenZ = 100 + 0.5 * ( lenX or 100 ), 100 + 0.5 * ( lenZ or 100 ), 120
				local maxLen = math.max( lenX, lenY, lenZ )
				self.LenX, self.LenY, self.LenZ, self.MaxLen = lenX, lenY, lenZ, maxLen
			end,

			Destroy = function( self )
				CancelPortalJump( id )
			end,
		} )
	end

	local function AddCustomPortalEffect( id, name )
		EHT.EffectType:New( id, name, {
			Category = CAT.PORTALS,
			CanPitch = true,
			OrderDrawLevelByIndex = true,
			ResetOnOrient = true,
			ResetOnPosition = true,
			ResetOnScale = true,

			MetaParams = {
				{
					Name = "HouseId",
					Deserializer = EHT.EffectDeserializers.Int4,
					Serializer = EHT.EffectSerializers.Int4,
				},
				{
					Name = "Owner",
					Deserializer = EHT.EffectDeserializers.StringVar,
					Serializer = EHT.EffectSerializers.StringVar,
				},
			},

			Init = function( self )
				self.Rings, self.Interval = 4, 3200
				self.IntervalOffset = math.random( 0, self.Interval )
				self.PlayerInside = true
				self.MaxTexCoord, self.MinTexCoord = 0.65, 0.05

				local p = self:AddParticle( TEXTURES.CIRCLE_SOFT_2,	0, 0, 0,			0, 0, 0,	0.5, 0.5, 0.5, 1,	0.9, 0.9,	true, false, false )
				p:SetSampleProcessing( 0, 1 )

				for index = 1, self.Rings do
					p = self:AddParticle( TEXTURES.WHIRLPOOL_1,		0, 0, 3 * index,	0, 0, 0,	1, 1, 1, 0,			1.2, 1.2,	true, true, false )
					p:SetSampleProcessing( 0.8, 0 )
				end

				p = self:AddParticle( TEXTURES.NEBULA_1,	0, 0, 3 * ( 1 + self.Rings ),			0, 0, 0,	1, 1, 1, 0,			1, 1,		true, false, false )
				p:SetDodge( true )
				p:SetTextureCoords( self.MinTexCoord, self.MaxTexCoord, self.MinTexCoord, self.MaxTexCoord )
				p:SetSampleProcessing( 0.85, 0 )
				p:SetDesaturation( 1 )

				p = self:AddParticle( TEXTURES.NEBULA_1,	0, 0, 3 * ( 2 + self.Rings ),			0, 0, 0,	1, 1, 1, 0,			1, 1,		true, false, false )
				p:SetDodge( true )
				p:SetTextureCoords( self.MinTexCoord, self.MaxTexCoord, self.MinTexCoord, self.MaxTexCoord )
				p:SetSampleProcessing( 1, 0 )
				p:SetDesaturation( 0 )

				self:SetSize( 600, 600, 600 )
				self:SetColor( 1, 1, 1, 1 )
				self:SpawnAtPlayer( 300 )
			end,

			Update = function( self )
				local r, g, b, a = self:GetColor()
				local ps = self.Particles
				local i = GetEasedInterval( 4000, self.IntervalOffset )
				local i2 = GetEasedInterval( 3200, self.IntervalOffset + 330 )
				local i3 = i
				local uv1, uv2, uv3, uv4 = 0.01 * i, 0.01 * i2, 0.02 * i, 0.02 * i2
				local c1, c2 = 0.8 - 0.1 * i, 0.8 - 0.1 * i2
				local ii = 1 / self.Rings
				local m, p, tex, ti
				local maxTC, minTC = self.MaxTexCoord, self.MinTexCoord

				p = ps[2 + self.Rings]
				tex = p.Texture
				tex:SetVertexUV( 1, minTC + uv1, minTC - uv3 )
				tex:SetVertexUV( 2, maxTC + uv2, minTC - uv4 )
				tex:SetVertexUV( 4, minTC + uv1, maxTC + uv3 )
				tex:SetVertexUV( 8, maxTC + uv2, maxTC + uv4 )
				p:SetVertexColors( 1, 1, 1, 1, c1 )
				p:SetVertexColors( 2, 1, 1, 1, c2 )
				p:SetVertexColors( 4, 1, 1, 1, c1 )
				p:SetVertexColors( 8, 1, 1, 1, c2 )

				uv1, uv2 = 0.4 * uv1, 0.4 * uv2
				p = ps[3 + self.Rings]
				p:SetColor( 1, 1, 1, -i3 )
				tex = p.Texture
				tex:SetVertexUV( 1, minTC - uv1, minTC )
				tex:SetVertexUV( 2, maxTC - uv2, minTC )
				tex:SetVertexUV( 4, minTC - uv1, maxTC )
				tex:SetVertexUV( 8, maxTC - uv2, maxTC )

				i3 = zo_clamp( -i3, 0, 1 )
				p = self.Particles[1]
				p:SetColor( 0.5 * r + i3, 0.5 * g + i3, 0.5 * b + i3, a )
				p:SetSampleProcessing( 0, 1 - 0.7 * i3 )

				i = 1 - GetLinearInterval( self.Interval, self.IntervalOffset )

				for index = 1, self.Rings do
					p = ps[index + 1]
					m = index % 4
					ti = i

					p:SetColor( r, g, b, zo_clamp( math.sin( ( 0.01 + 0.98 * i ) * math.pi ), 0, 0.3 ) )
					p:SetSampleProcessing( 0.8 - 0.8 * i, 0 )

					if 0 == m then		p:SetTextureCoords( -ti, 1 + ti, -ti, 1 + ti )
					elseif 1 == m then	p:SetTextureCoords( 1 + ti, -ti, -ti, 1 + ti )
					elseif 2 == m then	p:SetTextureCoords( -ti, 1 + ti, 1 + ti, -ti )
					elseif 3 == m then	p:SetTextureCoords( 1 + ti, -ti, 1 + ti, -ti )
					end

					i = ( i + ii ) % 1
				end

				if self.HouseId and self.HouseName and "" ~= self.HouseName and self.MaxLen then
					local x, y, z = self:GetPosition()
					local lenX, lenY, lenZ, maxLen = self.LenX, self.LenY, self.LenZ, self.MaxLen
					local playerX, playerY, playerZ = GetPlayerWorldPositionInHouse()
					playerY = playerY + 100

					local playerDistance = zo_distance3D( playerX, playerY, playerZ, x, y, z )
					local collision = false

					if playerDistance <= maxLen then
						local pitch, yaw, roll = self:GetOrientation()
						local pX, pY, pZ = EHT.World.Rotate( playerX - x, playerY - y, playerZ - z, -pitch, -yaw, -roll )

						if	pX >= -lenX and pX <= lenX and
							pY >= -lenY and pY <= lenY and
							pZ >= -lenZ and pZ <= lenZ then
							collision = true

							if not self.PlayerInside then
								self.PlayerInside = true
								ConfirmPortalJump( id, self.HouseName, self.HouseId, self.Owner )
							end
						end
					end

					if not collision and self.PlayerInside then
						self.PlayerInside = false
						CancelPortalJump( id )
					end
				end
			end,

			Reset = function( self )
				self:Update()

				local houseId = tonumber( self:GetMetaData( "HouseId" ) )
				local owner = tostring( self:GetMetaData( "Owner" ) )
				local house = EHT.Housing.GetHouseById( houseId )
				local home1, home2 = self.Particles[ #self.Particles ], self.Particles[ #self.Particles - 1 ]

				if house and owner then
					self.MaxTexCoord, self.MinTexCoord = 0.65, 0.05
					home1:SetTextureFile( house.Image )
					home2:SetTextureFile( house.Image )
					self.HouseName, self.HouseId, self.Owner = house.Name, houseId, owner
				elseif 0 == houseId and owner and "" ~= owner then
					self.MaxTexCoord, self.MinTexCoord = 0.65, 0.05
					home1:SetTextureFile( TEXTURES.PORTAL_PRIMARY )
					home2:SetTextureFile( TEXTURES.PORTAL_PRIMARY )
					self.HouseName, self.HouseId, self.Owner = "Primary Home", houseId, owner
				else
					self.MaxTexCoord, self.MinTexCoord = 1.2, -0.2
					home1:SetTextureFile( TEXTURES.ICON_BUILD )
					home2:SetTextureFile( TEXTURES.ICON_BUILD )
					self.HouseName, self.HouseId, self.Owner = nil, nil, nil
				end

				self.LenX, self.LenY, self.LenZ, self.MaxLen = nil, nil, nil, nil
				local lenX, lenY, lenZ = self:GetSize()
				if not lenX then return end

				lenX, lenY, lenZ = 100 + 0.5 * ( lenX or 100 ), 100 + 0.5 * ( lenZ or 100 ), 120
				local maxLen = math.max( lenX, lenY, lenZ )
				self.LenX, self.LenY, self.LenZ, self.MaxLen = lenX, lenY, lenZ, maxLen
			end,

			Destroy = function( self )
				CancelPortalJump( id )
			end,
		} )
	end

	do
		local houses = EHT.Housing.GetAllHouses()

		for index, house in pairs( houses ) do
			AddPortalEffect( 4500 + house.Id, string.format( "Portal, %s", house.Name ), house.Id, house.Name, house.Image )
		end
	end

	-- 03/05/2019
	EHT.EffectType:SetDefaultDateAdded( 1551732257 )

	AddPortalEffect( 4498, "Passage of Return, Invisible", nil, "" )
	AddPortalEffect( 4499, "Passage of Return", nil, "", TEXTURES.SKY_STARS_8 )
	AddCustomPortalEffect( 4500, "Calibrated Portal" )

end

---[ Text Effects ]---

-- 03/05/2019
EHT.EffectType:SetDefaultDateAdded( 1551732257 )

local function AddTextEffect(id, name, defaultColor, texFont, texWidth, texHeight, charWidth, charHeight, charOffsetX, charOffsetY)
	local function CreateCharacter( self, c )
		local charParticleWidth, charParticleHeight = self.CharParticleWidth, self.CharParticleHeight
		local b = string.byte( c )
		local x1, y1 = self.CharTexOffsetX, self.CharTexOffsetY
		local x2, y2

		if 65 <= b and 90 >= b then
			x1, y1 = x1 + self.CharTexWidth * ( b - 65 ), y1
		elseif 97 <= b and 122 >= b then
			x1, y1 = x1 + self.CharTexWidth * ( b - 97 ), y1 + self.CharTexHeight * 1
		elseif 33 <= b and 58 >= b then
			x1, y1 = x1 + self.CharTexWidth * ( b - 33 ), y1 + self.CharTexHeight * 2
		elseif 59 <= b and 64 >= b then
			x1, y1 = x1 + self.CharTexWidth * ( b - 59 ), y1 + self.CharTexHeight * 3
		elseif 91 <= b and 96 >= b then
			x1, y1 = x1 + self.CharTexWidth * ( 6 + ( b - 91 ) ), y1 + self.CharTexHeight * 3
		elseif 123 <= b and 126 >= b then
			x1, y1 = x1 + self.CharTexWidth * ( 12 + ( b - 123 ) ), y1 + self.CharTexHeight * 3
		else
			return nil
		end

		x2, y2 = x1 + self.CharTexWidth, y1 + self.CharTexHeight

		local p = self:AddParticle( texFont,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		charParticleWidth, charParticleHeight,		true, false, false )
		p:SetTextureCoords( x1, x2, y1, y2 )

		return p
	end

	EHT.EffectType:New( id, name, {
		Category = CAT.TEXT,
		CanPitch = true,
		ResetOnOrient = true,
		ResetOnPosition = true,
		ResetOnScale = true,
		ResetOnColor = true,
		MetaParams = {
			{
				Name = "Message",
				Deserializer = EHT.EffectDeserializers.StringVar,
				Serializer = EHT.EffectSerializers.StringVar,
			},
		},
		Init = function( self )
			self:SetSize( 220, 40, 40 )
			self:SetColor(unpack(defaultColor))
			self:SpawnAtPlayer( 200 )
			self.CharTexWidth, self.CharTexHeight = charWidth / texWidth, charHeight / texHeight
			self.CharTexOffsetX, self.CharTexOffsetY = charOffsetX / texWidth, charOffsetY / texHeight
		end,
		Reset = function( self )
			self:DeleteParticles()

			local message = self:GetMetaData( "Message" )
			if not message or "" == message then
				message = name
				if "Text, " == string.sub(message, 1, 6) then
					message = string.sub(message, 7)
				end
				self:SetMetaData( "Message", message )
			end

			local curColumn, curRow, maxColumn, maxRow = 0, 1, 0, 1
			local numChars = #message
			local c

			for index = 1, numChars do
				c = string.sub( message, index, index )

				if "\n" == c then
					curColumn = 0
					curRow = curRow + 1
					if curRow > maxRow then maxRow = curRow end
				else
					curColumn = curColumn + 1
					if curColumn > maxColumn then maxColumn = curColumn end
				end
			end

			self.MaxColumn, self.MaxRow = maxColumn, maxRow

			local sizeX, sizeY, sizeZ = self:GetSize()
			sizeY = math.max( sizeY, sizeZ )

			local charParticleWidth, charParticleHeight = 1 / ( maxColumn ), 1 / ( maxRow )
			local charParticleSpacingWidth, charParticleSpacingHeight = 0, 0
			local offsetX, offsetY = -0.5, ( 1 >= maxRow and 0 or 0.5 )
			local p

			self.CharParticleWidth, self.CharParticleHeight = charParticleWidth, charParticleHeight
			self.CharParticleSpacingWidth, self.CharParticleSpacingHeight = charParticleSpacingWidth, charParticleSpacingHeight

			curColumn, curRow = 0, 0

			for index = 1, numChars do
				c = string.sub( message, index, index )
				p = CreateCharacter( self, c )

				if p then
					p:SetPositionOffsets( offsetX + curColumn * ( charParticleWidth + charParticleSpacingWidth ), offsetY + curRow * ( -charParticleHeight - charParticleSpacingHeight ), 0 )
				end

				if "\n" == c then
					curColumn = 0
					curRow = curRow + 1
				else
					curColumn = curColumn + 1
				end
			end

			self:Update()
		end,
	} )
end

AddTextEffect(4400, "Text, Courier New", {1, 1, 1, 1}, TEXTURES.FONT_1, 1024, 1024, 38.4, 72.7, 0, 0)
AddTextEffect(4401, "Text, Courier New Bold", {1, 1, 1, 1}, TEXTURES.FONT_1, 1024, 1024, 32, 55, 0, 300)
AddTextEffect(4402, "Text, Consolas", {1, 1, 1, 1}, TEXTURES.FONT_2, 1024, 1024, 29, 48, 0, 0)
AddTextEffect(4403, "Text, Consolas Bold", {1, 1, 1, 1}, TEXTURES.FONT_2, 1024, 1024, 29, 48, 0, 250)
AddTextEffect(4404, "Text, Lucida Console", {1, 1, 1, 1}, TEXTURES.FONT_3, 1024, 1024, 32, 49, 0, 0)
AddTextEffect(4405, "Text, Serif", {1, 1, 1, 1}, TEXTURES.FONT_3, 1024, 1024, 30, 49, 0, 250)
AddTextEffect(4406, "Text, Daedric", {1, 0, 0, 1}, TEXTURES.FONT_4, 1024, 1024, 1024/26, 48, -1, 0)

local charAtlasIndices = {}
do
	local cellIndex = 0
	for charIndex = 65, 90 do
		cellIndex = cellIndex + 1
		charAtlasIndices[charIndex] = cellIndex
	end
	for charIndex = 97, 122 do
		cellIndex = cellIndex + 1
		charAtlasIndices[charIndex] = cellIndex
	end
	for charIndex = 33, 64 do
		cellIndex = cellIndex + 1
		charAtlasIndices[charIndex] = cellIndex
	end
	for charIndex = 91, 96 do
		cellIndex = cellIndex + 1
		charAtlasIndices[charIndex] = cellIndex
	end
	for charIndex = 123, 126 do
		cellIndex = cellIndex + 1
		charAtlasIndices[charIndex] = cellIndex
	end
end

local function AddTextEffect2(effectIndex, effectName, defaultColor, textureFile, texWidth, texHeight, cellWidth, cellHeight, charWidths)
	local cell =
	{
		u = cellWidth / texWidth,
		v = cellHeight / texHeight,
		spacer = 0.2,
		numPerRow = math.floor(texWidth / cellWidth),
	}

	local charAtlasData = {}
	for charIndex, charWidth in ipairs(charWidths) do
		local charData =
		{
			cellIndex = charIndex - 1,
			cellOffset = charWidth.offset / cellWidth,
			cellWeight = 0,
			cellWidth = 0,
			u1 = 0,
			u2 = 0,
			v1 = 0,
			v2 = 0,
		}
		charAtlasData[charIndex] = charData

		local cellRow = math.floor(charData.cellIndex / cell.numPerRow)
		local cellColumn = charData.cellIndex % cell.numPerRow
		charData.cellWidth = charWidth.width / cellWidth
		charData.cellWeight = (charWidth.width + charWidth.offset) / cellWidth
		charData.u1 = cell.u * cellColumn
		charData.u2 = charData.u1 + cell.u * charData.cellWidth
		charData.v1 = cell.v * cellRow
		charData.v2 = cell.v * (cellRow + 1)
	end

	local function GetOrCreateCharacter(self, c)
		local byteValue = string.byte(c)
		local cellIndex = charAtlasIndices[byteValue]
		local charData = charAtlasData[cellIndex]
		if not cellIndex or not charData then
			return nil
		end

		local pIndex = self.nextParticleIndex
		self.nextParticleIndex = pIndex + 1

		local p = self.Particles[pIndex]
		if not p then
			p = self:AddParticle(textureFile,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		0, 0,		true, false, false)
		end

		p:SetTextureCoords(charData.u1, charData.u2, charData.v1, charData.v2)
		p.charCode, p.charData = c, charData

		return p, charData
	end

	EHT.EffectType:New(effectIndex, effectName, {
		Category = CAT.TEXT,

		CanPitch = true,
		ResetOnOrient = true,
		ResetOnPosition = true,
		ResetOnScale = true,
		ResetOnColor = true,

		MetaParams = {
			{
				Name = "Message",
				Deserializer = EHT.EffectDeserializers.StringVar,
				Serializer = EHT.EffectSerializers.StringVar,
			},
		},

		Init = function(self)
			self.nextParticleIndex = 1
			self:SetSize(220, 60, 60)
			self:SetColor(unpack(defaultColor))
			self:SpawnAtPlayer(200)
		end,

		Reset = function(self)
			self:DeleteParticles()

			local message = self:GetMetaData("Message")
			if not message or "" == message then
				message = effectName
				if "Text, " == string.sub(message, 1, 6) then
					message = string.sub(message, 7)
				end
				self:SetMetaData("Message", message)
			end

			local sizeX, sizeY, sizeZ = self:GetSize()
			sizeY = math.max( sizeY, sizeZ )

			local currentRow = 1
			local currentRowWeight = 0
			local maxRowWeight = 0
			local numChars = #message
			local rowParticles = {}
			local SPACE_PARTICLE = 0

			self.nextParticleIndex = 1
			for index = 1, numChars do
				local c = string.sub(message, index, index)
				local p, charData = GetOrCreateCharacter(self, c)

				local particles = rowParticles[currentRow]
				if not particles then
					particles = {}
					rowParticles[currentRow] = particles
				end

				if p then
					currentRowWeight = currentRowWeight + charData.cellWeight
					table.insert(particles, p)
				else
					if "\n" == c then
						if currentRowWeight > maxRowWeight then
							maxRowWeight = currentRowWeight
						end
						currentRow = currentRow + 1
						currentRowWeight = 0
					else
						currentRowWeight = currentRowWeight + cell.spacer
						table.insert(particles, SPACE_PARTICLE)
					end
				end
			end

			do
				local numParticles = #self.Particles
				if self.nextParticleIndex <= numParticles then
					for index = numParticles, self.nextParticleIndex, -1 do
						self:DeleteParticle(index)
					end
				end
			end

			if currentRowWeight > maxRowWeight then
				maxRowWeight = currentRowWeight
			end

			local numRows = #rowParticles
			local rowScaleY = 1 / numRows
			local rowScaleOffsetY = 0.5 * rowScaleY

			for rowIndex, particles in ipairs(rowParticles) do
				local rowOffsetX = -0.5
				local rowOffsetY = 0.5 - rowScaleY * (rowIndex - 1) - rowScaleOffsetY

				for pIndex, p in ipairs(particles) do
					local cellWeight, offsetX = 0, 0
					if p == SPACE_PARTICLE then
						cellWeight = cell.spacer
					else
						cellWeight = p.charData.cellWidth
						if 0 ~= p.charData.cellOffset then
							offsetX = p.charData.cellOffset / maxRowWeight
						end
					end
					local scaleX = cellWeight / maxRowWeight
					local scaleY = rowScaleY

					if p ~= SPACE_PARTICLE then
						p:SetPositionOffsets(rowOffsetX + scaleX * 0.5 + offsetX, rowOffsetY, 0)
						p:SetSizeOffsets(scaleX, scaleY)
					end

					rowOffsetX = rowOffsetX + scaleX + offsetX
				end
			end

			self:Update()
		end,
	} )
end

-- 2021-07-18
EHT.EffectType:SetDefaultDateAdded(1626597994)
-- /sc StartChatInput(tostring(GetTimeStamp()))

do
	local CHARACTER_WIDTHS =
	{
		{	width = 123,	offset = 0,	},	--	A
		{	width = 113,	offset = 0,	},	--	B
		{	width = 91,		offset = 0,	},	--	C
		{	width = 118,	offset = 0,	},	--	D
		{	width = 124,	offset = 0,	},	--	E
		{	width = 122,	offset = 0,	},	--	F
		{	width = 112,	offset = 0,	},	--	G
		{	width = 117,	offset = 0,	},	--	H
		{	width = 73,		offset = 0,	},	--	I
		{	width = 77,		offset = 0,	},	--	J
		{	width = 132,	offset = 0,	},	--	K
		{	width = 119,	offset = 0,	},	--	L
		{	width = 194,	offset = 0, },	--	M
		{	width = 125,	offset = 0,	},	--	N
		{	width = 97,		offset = 0,	},	--	O
		{	width = 114,	offset = 0,	},	--	P
		{	width = 99,		offset = 0,	},	--	Q
		{	width = 135,	offset = 0,	},	--	R
		{	width = 127,	offset = 0,	},	--	S
		{	width = 110,	offset = 0,	},	--	T
		{	width = 133,	offset = 0,	},	--	U
		{	width = 138,	offset = 0,	},	--	V
		{	width = 185,	offset = 0,	},	--	W
		{	width = 140,	offset = 0,	},	--	X
		{	width = 102,	offset = 0,	},	--	Y
		{	width = 153,	offset = 0,	},	--	Z
		{	width = 57,		offset = 0,	},	--	a
		{	width = 56,		offset = 0,	},	--	b
		{	width = 47,		offset = 0,	},	--	c
		{	width = 60,		offset = 0,	},	--	d
		{	width = 55,		offset = 0,	},	--	e
		{	width = 41,		offset = 0,	},	--	f
		{	width = 66,		offset = 0, },	--	g
		{	width = 59,		offset = 0,	},	--	h
		{	width = 27,		offset = 0, },	--	i
		{	width = 43,		offset = 0,	},	--	j
		{	width = 59,		offset = 0,	},	--	k
		{	width = 25,		offset = 0, },	--	l
		{	width = 87,		offset = 0,	},	--	m
		{	width = 61,		offset = 0,	},	--	n
		{	width = 60,		offset = 0,	},	--	o
		{	width = 66,		offset = 0, },	--	p
		{	width = 60,		offset = 0,	},	--	q
		{	width = 49,		offset = 0,	},	--	r
		{	width = 64,		offset = 0,	},	--	s
		{	width = 37,		offset = 0,	},	--	t
		{	width = 55,		offset = 0,	},	--	u
		{	width = 54,		offset = 0,	},	--	v
		{	width = 83,		offset = 0,	},	--	w
		{	width = 57,		offset = 0,	},	--	x
		{	width = 57,		offset = 0,	},	--	y
		{	width = 47,		offset = 0,	},	--	z
		{	width = 28,		offset = 0,	},	--	!
		{	width = 39,		offset = 0,	},		
		{	width = 61,		offset = 0,	},		
		{	width = 61,		offset = 0,	},		
		{	width = 93,		offset = 0,	},	--	%
		{	width = 125,	offset = 0,	},	--	&
		{	width = 17,		offset = 0,	},		
		{	width = 40,		offset = 0,	},		
		{	width = 39,		offset = 0,	},		
		{	width = 58,		offset = 0,	},		
		{	width = 74,		offset = 0,	},		
		{	width = 17,		offset = 0,	},		
		{	width = 49,		offset = 0,	},		
		{	width = 19,		offset = 0,	},		
		{	width = 72,		offset = 0,	},		
		{	width = 96,		offset = 0,	},	--	0
		{	width = 48,		offset = 0,	},		
		{	width = 100,	offset = 0,	},		
		{	width = 80,		offset = 0,	},		
		{	width = 103,	offset = 0,	},		
		{	width = 88,		offset = 0,	},		
		{	width = 84,		offset = 0,	},		
		{	width = 98,		offset = 0,	},		
		{	width = 74,		offset = 0,	},	--	8
		{	width = 88,		offset = 0,	},		
		{	width = 21,		offset = 0,	},	--	;
		{	width = 22,		offset = 0,	},		
		{	width = 83,		offset = 0,	},		
		{	width = 87,		offset = 0,	},		
		{	width = 84,		offset = 0,	},		
		{	width = 60,		offset = 0,	},		
		{	width = 97,		offset = 0,	},		
		{	width = 30,		offset = 0,	},		
		{	width = 67,		offset = 0,	},	--	\
		{	width = 30,		offset = 0,	},		
		{	width = 76,		offset = 0,	},		
		{	width = 84,		offset = 0,	},		
		{	width = 31,		offset = 0,	},		
		{	width = 38,		offset = 0,	},		
		{	width = 18,		offset = 0,	},		
		{	width = 38,		offset = 0,	},		
		{	width = 85,		offset = 0,	},	--	~
	}

	local PADDING_PX = 10
	for charIndex, charData in ipairs(CHARACTER_WIDTHS) do
		charData.width = charData.width + PADDING_PX
	end

	AddTextEffect2(4407, "Text, Cardinal", {1, 0, 0, 1}, TEXTURES.FONT_5, 4096, 1024, 215.578947, 204.8, CHARACTER_WIDTHS)
end

do
	local CHARACTER_WIDTHS =
	{
		{	width = 125,	offset = 0,	},	--	A
		{	width = 85,		offset = 0,	},	--	B
		{	width = 89, 	offset = 0,	},	--	C
		{	width = 103,	offset = 0,	},	--	D
		{	width = 70, 	offset = 0,	},	--	E
		{	width = 68, 	offset = 0,	},	--	F
		{	width = 118,	offset = 0,	},	--	G
		{	width = 100,	offset = 0,	},	--	H
		{	width = 43,		offset = 0,	},	--	I
		{	width = 64,		offset = 0,	},	--	J
		{	width = 100,	offset = 0,	},	--	K
		{	width = 83, 	offset = 0,	},	--	L
		{	width = 111,	offset = 0, },	--	M
		{	width = 109,	offset = 0,	},	--	N
		{	width = 125,	offset = 0,	},	--	O
		{	width = 100,	offset = 0,	},	--	P
		{	width = 125,	offset = 0,	},	--	Q
		{	width = 84, 	offset = 0,	},	--	R
		{	width = 82, 	offset = 0,	},	--	S
		{	width = 84, 	offset = 0,	},	--	T
		{	width = 100,	offset = 0,	},	--	U
		{	width = 123,	offset = 0,	},	--	V
		{	width = 127,	offset = 0,	},	--	W
		{	width = 110,	offset = 0,	},	--	X
		{	width = 80, 	offset = 0,	},	--	Y
		{	width = 92, 	offset = 0,	},	--	Z
		{	width = 97,		offset = 0,	},	--	a
		{	width = 95,		offset = 0,	},	--	b
		{	width = 73,		offset = 0,	},	--	c
		{	width = 98,		offset = 0,	},	--	d
		{	width = 92,		offset = 0,	},	--	e
		{	width = 68,		offset = 0,	},	--	f
		{	width = 99,		offset = 0, },	--	g
		{	width = 80,		offset = 0,	},	--	h
		{	width = 46,		offset = 0, },	--	i
		{	width = 60,		offset = 0,	},	--	j
		{	width = 82,		offset = 0,	},	--	k
		{	width = 45,		offset = 0, },	--	l
		{	width = 120,	offset = 0,	},	--	m
		{	width = 80,		offset = 0,	},	--	n
		{	width = 95,		offset = 0,	},	--	o
		{	width = 95,		offset = 0, },	--	p
		{	width = 95,		offset = 0,	},	--	q
		{	width = 50,		offset = 0,	},	--	r
		{	width = 70,		offset = 0,	},	--	s
		{	width = 71,		offset = 0,	},	--	t
		{	width = 80,		offset = 0,	},	--	u
		{	width = 86,		offset = 0,	},	--	v
		{	width = 120,	offset = 0,	},	--	w
		{	width = 72,		offset = 0,	},	--	x
		{	width = 84,		offset = 0,	},	--	y
		{	width = 67,		offset = 0,	},	--	z
		{	width = 50,		offset = 0,	},	--	!
		{	width = 64,		offset = 0,	},		
		{	width = 84,		offset = 0,	},		
		{	width = 71,		offset = 0,	},		
		{	width = 89,		offset = 0,	},	--	%
		{	width = 86, 	offset = 0,	},	--	&
		{	width = 31,		offset = 0,	},		
		{	width = 52,		offset = 0,	},		
		{	width = 47,		offset = 0,	},		
		{	width = 53,		offset = 0,	},		
		{	width = 73,		offset = 0,	},		
		{	width = 43,		offset = 0,	},		
		{	width = 54,		offset = 0,	},		
		{	width = 47,		offset = 0,	},		
		{	width = 51,		offset = 0,	},		
		{	width = 84,		offset = 0,	},	--	0
		{	width = 58,		offset = 0,	},		
		{	width = 94, 	offset = 0,	},		
		{	width = 84,		offset = 0,	},		
		{	width = 95, 	offset = 0,	},		
		{	width = 92,		offset = 0,	},		
		{	width = 98,		offset = 0,	},		
		{	width = 78,		offset = 0,	},		
		{	width = 88,		offset = 0,	},	--	8
		{	width = 107,	offset = 0,	},		
		{	width = 44,		offset = 0,	},	--	;
		{	width = 40,		offset = 0,	},		
		{	width = 74,		offset = 0,	},		
		{	width = 68,		offset = 0,	},		
		{	width = 100,	offset = 0,	},		
		{	width = 67,		offset = 0,	},		
		{	width = 169,	offset = 0,	},		
		{	width = 43,		offset = 0,	},		
		{	width = 67,		offset = 0,	},	--	\
		{	width = 50,		offset = 0,	},		
		{	width = 60,		offset = 0,	},		
		{	width = 50,		offset = 0,	},		
		{	width = 32,		offset = 0,	},		
		{	width = 56,		offset = 0,	},		
		{	width = 30,		offset = 0,	},		
		{	width = 53,		offset = 0,	},		
		{	width = 47,		offset = 0,	},	--	~
	}

	AddTextEffect2(4408, "Text, Graffiti", {1, 0.5, 0, 1}, TEXTURES.FONT_6, 4096, 1024, 215.578947, 204.8, CHARACTER_WIDTHS)
end

---[ Map Effects ]---

-- 06/11/2019
EHT.EffectType:SetDefaultDateAdded( 1560285089 )

local function AddMapEffect( id, name, mapIndex )
	local et = EHT.EffectType:New( id, name, {
		Category = CAT.MAP,
		CanPitch = true,
		OrderDrawLevelByIndex = true,
		ResetOnOrient = true,
		ResetOnPosition = true,
		ResetOnScale = true,

		Init = function( self )
			self.MapTilesX, self.MapTilesY = GetMapNumTilesForMapId( mapIndex )
			self.MapTileStart, self.MapTileEnd = 1, self.MapTilesX * self.MapTilesY

			local tileIndex, tileX, tileY = 1, 1 / self.MapTilesX, 1 / self.MapTilesY
			local tileTexture, p

			for indexY = self.MapTilesY, 1, -1 do
				for indexX = 1, self.MapTilesX do
					tileTexture = GetMapTileTextureForMapId( mapIndex, tileIndex )
					self:AddParticle( tileTexture,		-0.5 + ( indexX - 0.5 ) * tileX, -0.5 + ( indexY - 0.5 ) * tileY, 0,	0, 0, 0,	1, 1, 1, 1,		tileX, tileY,		true, false, false )
					tileIndex = tileIndex + 1
				end
			end

			self:AddParticle( TEXTURES.PARCHMENT_4,				0, 0, 2,		0, 0, 0,	1, 1, 1, 1,		1.02, 1.02,		true, false, false )

			self:SetSize( 496, 288, 288 )
			self:SetColor( 1, 1, 1, 1 )
			self:SpawnAtPlayer( 200 )
		end,

		Reset = function( self )
			self:Update()

			local p, x, y, pitch, yaw, roll
			local offset = math.rad( 0.026 )

			for index = self.MapTileStart, self.MapTileEnd do
				p = self.Particles[index]

				x, y = p:GetSize()
				p:SetSize( 1 + x, 1 + y )

				pitch, yaw, roll = p:GetOrientation()
				p:SetOrientation( pitch + offset, yaw + offset, roll )
			end
		end,
	} )
end

AddMapEffect(6027, "Tamriel", 27)
AddMapEffect(6001, "Glenumbra", 1)
AddMapEffect(6010, "Rivenspire", 10)
AddMapEffect(6012, "Stormhaven", 12)
AddMapEffect(6030, "Alik'r Desert", 30)
AddMapEffect(6020, "Bangkorai", 20)
AddMapEffect(6009, "Grahtwood", 9)
AddMapEffect(6022, "Malabal Tor", 22)
AddMapEffect(6026, "Shadowfen", 26)
AddMapEffect(6013, "Deshaan", 13)
AddMapEffect(6007, "Stonefalls", 7)
AddMapEffect(6125, "The Rift", 125)
AddMapEffect(6061, "Eastmarch", 61)
AddMapEffect(6016, "Cyrodiil", 16)
AddMapEffect(6143, "Auridon", 143)
AddMapEffect(6300, "Greenshade", 300)
AddMapEffect(6256, "Reaper's March", 256)
AddMapEffect(6075, "Bal Foyen", 75)
AddMapEffect(6201, "Stros M'Kai", 201)
AddMapEffect(6227, "Betnikh", 227)
AddMapEffect(6258, "Khenarthi's Roost", 258)
AddMapEffect(6074, "Bleakrock Isle", 74)
AddMapEffect(6255, "Coldharbour", 255)
AddMapEffect(6439, "The Aurbis", 439)
AddMapEffect(7126, "Craglorn", 1126)
AddMapEffect(6660, "Imperial City", 660)
AddMapEffect(6667, "Wrothgar", 667)
AddMapEffect(6994, "Hew's Bane", 994)
AddMapEffect(7006, "Gold Coast", 1006)
AddMapEffect(7060, "Vvardenfell", 1060)
AddMapEffect(7313, "Clockwork City", 1313)
AddMapEffect(7349, "Summerset", 1349)
AddMapEffect(7429, "Artaeum", 1429)
AddMapEffect(7484, "Murkmire", 1484)
AddMapEffect(7552, "Norg-Tzel", 1552)
AddMapEffect(7555, "Northern Elsweyr", 1555)
AddMapEffect(7654, "Southern Elsweyr", 1654)
AddMapEffect(7719, "Western Skyrim", 1719)
AddMapEffect(7747, "Blackreach: Greymoor Caverns", 1747)
AddMapEffect(7782, "Blackreach", 1782)
AddMapEffect(7850, "Blackreach: Arkthzand Cavern", 1850)
AddMapEffect(7814, "The Reach", 1814)
--[[
do
	local id, name

	for index = 1, GetNumMaps() do
		SetMapToMapListIndex( index )
		id = GetCurrentMapId()
		name = GetMapName()

		if id and 0 ~= id and name and "" ~= name then
			AddMapEffect( 6000 + id, name, id )
		end
	end
end

/script t={} local id, name for index = 1, GetNumMaps() do SetMapToMapListIndex( index ) id = GetCurrentMapId() name = GetMapName() if id and 0 ~= id and name and "" ~= name then table.insert(t,string.format("AddMapEffect(%d, %q, %d)",6000+id,name,id)) end end d(t)
/script EHT.SavedVars.MapIDs=table.concat(t, "\n")
]]
---[ Custom Templates ]---

function EHT.Effect.CreatePlayerNPC( template )
	local id, effectName, textureFile = template.Id, template.Name, GetCustomTemplateTexture( template.Id )
	local TexWidth, TexHeight = template.TexWidth or 2048, template.TexHeight or 2048
	local CellWidth, CellHeight = template.CellWidth or 320, template.CellHeight or 1024
	local LocalWidth, LocalHeight = template.LocalWidth or 320, template.LocalHeight or 840
	local CellsX, CellsY, CellInterval, LoopPauseCells, MidpointPauseCells = template.CellsX or 6, template.CellsY or 1, template.CellInterval or 500, template.LoopPauseCells or 0, template.MidpointPauseCells or 0
	local MaxCells = template.MaxCells or template.CellsX
	local DefaultWidth, DefaultHeight = template.DefaultWidth or 90, template.DefaultHeight or 235
	local staticPrimary = true == template.StaticPrimaryCell
	local saturation = template.Saturation or 0
	local loopReverse = true == template.LoopForwardReverse
	local glowBase, glowIntensity, glowInterval = template.GlowBase, template.GlowIntensity, template.GlowInterval
	local alphaMasks = template.CellAlphaMasks or { }
	local cellSampling = template.CellSampling or { }
	local defaultGreeting = template.DefaultGreeting or "Hello, %s. Edit me to configure a greeting for you and your guests."

	local function Say( name, msg )
		name = name or effectName
		EHT.Subtitles:QueueMessages( name, msg )
	end

	EHT.EffectType:New( id, effectName .. ", NPC", {
		Category = CAT.NPC,
		Submitter = template.Submitter,
		CanPitch = true,
		OrderDrawLevelByIndex = true,
		ResetOnColor = true,
		MetaParams = {
			{
				Name = "Name",
				Deserializer = EHT.EffectDeserializers.StringVar,
				Serializer = EHT.EffectSerializers.StringVar,
			},
			{
				Name = "Message",
				Deserializer = EHT.EffectDeserializers.StringVar,
				Serializer = EHT.EffectSerializers.StringVar,
			},
		},
		Init = function( self )
			local maxCells = MaxCells or CellsX
			local p, x1, x2, y1, y2
			local cells = 0
			local sample

			self.CellInterval = CellInterval
			self.IntervalOffset = math.random( 0, 10000 )
			self.GlowIntensity, self.GlowInterval = glowIntensity, glowInterval

			for indexY = 1, ( CellsY or 1 ) do
				for index = 1, CellsX do
					x1, x2 = ( index - 1 ) * ( CellWidth / TexWidth ), ( index - 1 ) * ( CellWidth / TexWidth ) + ( LocalWidth / TexWidth )
					p = self:AddParticle( textureFile,		0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	true, false, false )

					y1, y2 = ( indexY - 1 ) * ( LocalHeight / TexHeight ), indexY * ( LocalHeight / TexHeight )
					p:SetTextureCoords( x1, x2, y1, y2 )

					cells = cells + 1
					p.MaxAlpha = alphaMasks[cells] or 1

					sample = cellSampling[cells]
					if sample then
						p:SetSampleProcessing( sample[1], sample[2] )
					end

					if cells >= maxCells then break end
				end
			end

			if 0 < MidpointPauseCells then
				local i = #self.Particles

				for index = 1, MidpointPauseCells do
					self:CloneParticle(self.Particles[i])
				end
			end

			if loopReverse and 1 < cells then
				local cIndex = cells - 1

				while 1 <= cIndex do
					self:CloneParticle(self.Particles[cIndex])
					cIndex = cIndex - 1
				end
			end

			if 0 < LoopPauseCells then
				for index = 1, LoopPauseCells do
					self:CloneParticle(self.Particles[1])
				end
			end

			for index = 1, #self.Particles do
				self.Particles[index].MaxAlpha = self.Particles[index].MaxAlpha or 1
			end

			self:SetMetaData( "Name", self:GetMetaData( "Name" ) or effectName )
			self:SetSize( DefaultWidth, DefaultHeight, DefaultHeight )
			self:SetColor( template.R or 0.7, template.G or 0.7, template.B or 0.7, template.A or 1 )
			self:SetOrientation( 0, 0, 0 )
			self:SpawnAtPlayer( 118 )
		end,
		Update = function( self )
			local a, p
			local maxCells = #self.Particles
			local cellInterval = self.CellInterval
			local rgb = 1

			if self.GlowIntensity and self.GlowInterval then
				rgb = ( self.GlowBase or 1 ) + self.GlowIntensity * GetLoopInterval( self.GlowInterval )
			end

			if true == template.NonSinusoidal then
				local activeCell = 1 + math.floor( ( maxCells - 1 ) * GetLinearInterval( maxCells * cellInterval, self.IntervalOffset ) )
				p = self.Particles[activeCell]
				p:SetAlpha( p.MaxAlpha or 1 )
				p:SetSampleProcessing( rgb )

				for index = 1, maxCells do
					if index ~= activeCell then
						if not staticPrimary or 1 ~= index then
							self.Particles[index]:SetAlpha( 0 )
						end
					end
				end
			else
				for index = 1, maxCells do
					a = -( maxCells - 1.85 ) + maxCells * GetLoopInterval( maxCells * cellInterval, self.IntervalOffset + index * cellInterval )
					p = self.Particles[index]
					p:SetSampleProcessing( rgb )

					if staticPrimary and 1 == index then
						p:SetAlpha( p.MaxAlpha or 1 )
					else
						p:SetAlpha( a * p.MaxAlpha )
					end
				end
			end

			if EHT.Housing.IsHUDMode() then
				if not self.Greeted then
					local inRange = 1000 > zo_distance3D( self.X, self.Y, self.Z, PlayerX, PlayerY, PlayerZ )

					if inRange then
						local message = self:GetMetaData( "Message" )

						if EHT.Housing.IsOwner() and ( not message or "" == message ) then
							message = string.format( defaultGreeting, GetDisplayName() )
						end

						if message and "" ~= EHT.Util.Trim( message ) then
							self.Greeted = message
							Say( self:GetMetaData( "Name" ), message )
						end
					end
				end
			end
		end,
		Reset = function( self )
			local r, g, b, a = self:GetColor()
			r, g, b = r + saturation, g + saturation, b + saturation

			self:Update()
			self.Greeted = nil

			for index = 1, #self.Particles do
				if staticPrimary and 1 == index then
					self.Particles[index]:SetColor( 1, 1, 1, a )
				else
					self.Particles[index]:SetColor( r, g, b, a )
				end
			end
		end,
	} )
end

EHT.EffectType:SetDefaultDateAdded( nil )

do

	local BEHAVIORS = {

		Perspective = {

			Init = function( self, templateId, texture, template )
				self.OrderDrawLevelByIndex = true
				self.AlphaCoeff = 1.8

				local texturePrefix, textureSuffix = string.sub( texture, 1, -5 ), string.sub( texture, -4, -1 )
				local texture1, texture2 = string.format( "%s_1%s", texturePrefix, textureSuffix ), string.format( "%s_2%s", texturePrefix, textureSuffix )

				self:AddParticle( texture1,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )
				self:AddParticle( texture2,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )
			end,

			Update = function( self )
				local a = self:GetViewingSide()
				local a2 = 1 - a

				self.Particles[1]:SetAlpha( self.AlphaCoeff + math.log( a ) )
				self.Particles[2]:SetAlpha( self.AlphaCoeff + math.log( a2 ) )
			end,

		},

		Fan = {

			Init = function( self, templateId, texture, template )
				local pitch = math.rad( -5 )
				local texture2 = GetCustomTemplateTexture( template.Id, 2 )
				local texture3 = GetCustomTemplateTexture( template.Id, 3 )
				local z = 0.1
				local p

				p = self:AddParticle( texture3,	-0.2, -0.05, -z,	-pitch, 0, 0,		1, 1, 1, 0,				0.7, 0.9,	true, false, false )
				p:SetAutoColorEnabled( false )

				p = self:AddParticle( texture3,	0.2, -0.2, z,		-pitch, 0, 0,		0.6, 0.6, 0.6, 0,		0.7, 0.6,	true, false, false )
				p:SetAutoColorEnabled( false )

				p = self:AddParticle( texture,	-0.2, -0.05, -z,	-pitch, 0, 0,		1, 1, 1, 1,				0.7, 0.9,	true, false, false )
				p:SetAutoColorEnabled( false )

				p = self:AddParticle( texture,	0.2, -0.2, z,		-pitch, 0, 0,		0.6, 0.6, 0.6, 1,		0.7, 0.6,	true, false, false )
				p:SetAutoColorEnabled( false )

				p = self:AddParticle( texture2,	-0.2, -0.05, -z,	-pitch, 0, 0,		1, 1, 1, 0.8,			0.7, 0.9,	true, false, false )
				p:SetSampleProcessing( 3, 0 )

				p = self:AddParticle( texture2,	0.2, -0.2, z,		-pitch, 0, 0,		0.65, 0.65, 0.65, 0.8,	0.7, 0.6,	true, false, false )
				p:SetSampleProcessing( 3, 0 )

				self.MaxDim = 1
				self:SetSize( 1, 1, 1 )
			end,

			Update = function( self )
				local r, g, b, a = self:GetColor()

				for i = 1, 2 do
					local p = self.Particles[i]
					p:AutoUpdateDrawLevel( true )
					local dl = p:GetDrawLevel()

					self.Particles[i + 2]:SetDrawLevel( dl + 1 )
					self.Particles[i + 4]:SetDrawLevel( dl + 2 )
				end

				local n = math.abs( self.Particles[1]:GetCameraNormal() )
				local da = zo_clamp( ( -0.5 * self.FocusDistance + self.Particles[1]:GetPlayerDistance() ) / self.FocusDistance, 0, 1 )

				a = 0.5 + 0.5 * zo_clamp( n, 0, 1 )
				self.Particles[3]:SetColor( a, a, a, 1.5 - da )
				self.Particles[1]:SetColor( a, a, a, da )
				self.Particles[5]:SetColor( r * a, g * a, b * a, 0.8 * a )

				a = 0.7 * a
				self.Particles[4]:SetColor( a, a, a, 1.5 - da )
				self.Particles[2]:SetColor( a, a, a, da )
				self.Particles[6]:SetColor( r * a, g * a, b * a, 0.8 * a )
			end,

			Reset = function( self )
				if not self.Particles or not self.Particles[1] then
					return
				end

				self.FocusDistance = math.max( 1.35 * math.max( self:GetSize() ), 500 )
				self:Update()
			end,

		},

		Tile = {

			Init = function( self, templateId, texture, template )
				self.TileSizeX, self.TileSizeY = template.TileSizeX, template.TileSizeY
				self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, true )
			end,

			Reset = function( self )
				if not self.Particles or not self.Particles[1] then
					return
				end

				local p = self.Particles[1]
				p:Tile( self.TileSizeX, self.TileSizeY )
			end,

		},

		Shining = {

			Init = function( self, templateId, texture, template )
				self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )

				if template.Count and 1 ~= template.Count then
					texture = GetCustomTemplateTexture( template.Id, 2 )
				end

				local p = self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )
				p:SetDesaturation( 1 )
				p:SetDodge( true )
				p:SetSampleProcessing( 1, 0 )

				if template.TextureCoords then
					for index = 1, #self.Particles do
						self.Particles[index]:SetTextureCoords( template.TextureCoords[1], template.TextureCoords[2], template.TextureCoords[3], template.TextureCoords[4] )
					end
				end

				self.IntervalDuration = 9000
				self.IntervalOffset = math.random( 0, 9000 )
				self.AlphaMinThreshold = 0.5
				self.AlphaThresholdScale = 2
				self.MaxAlpha = 0.6
			end,

			Update = function( self )
				local p = self.Particles[2]
				local interval1, interval2, interval3 = GetLoopInterval( self.IntervalDuration, self.IntervalOffset ), GetLoopInterval( self.IntervalDuration, self.IntervalOffset + 200 ), GetLoopInterval( self.IntervalDuration, self.IntervalOffset + 400 )
				interval1, interval2, interval3 = zo_clamp( ( interval1 - self.AlphaMinThreshold ) * self.AlphaThresholdScale, 0, self.MaxAlpha ), zo_clamp( ( interval2 - self.AlphaMinThreshold ) * self.AlphaThresholdScale, 0, self.MaxAlpha ), zo_clamp( ( interval3 - self.AlphaMinThreshold ) * self.AlphaThresholdScale, 0, self.MaxAlpha )

				p:SetVertexColors( 1, 1, 1, 1, interval1 )
				p:SetVertexColors( 2 + 4, 1, 1, 1, interval2 )
				p:SetVertexColors( 8, 1, 1, 1, interval3 )
			end,

		},

		MaskedGlowing = {

			Init = function( self, templateId, texture, template )
				self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )

				if template.Count and 1 ~= template.Count then
					texture = GetCustomTemplateTexture( template.Id, 2 )
				end

				local p = self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )
				p:SetSampleProcessing( 1, 0 )
				p:SetAdditive( true )

				if template.TextureCoords then
					for index = 1, #self.Particles do
						self.Particles[index]:SetTextureCoords( template.TextureCoords[1], template.TextureCoords[2], template.TextureCoords[3], template.TextureCoords[4] )
					end
				end

				self.IntervalDuration = 10000
				self.AlphaThresholdScale = 3
				self.MaxAlpha = 1
				self.MinAlpha = 0
				self.OffsetAlpha = -1
			end,

			Update = function( self )
				local i = zo_clamp( self.OffsetAlpha + GetLoopInterval( self.IntervalDuration, 0 ) * self.AlphaThresholdScale, self.MinAlpha, self.MaxAlpha )
				local p = self.Particles[2]
				p:SetDesaturation( 1 - i )
				p:SetAlpha( i )
			end,

			Reset = function( self )
				if not self.Particles or not self.Particles[1] then
					return
				end

				self:Update()
				self.Particles[1]:SetColor( 1, 1, 1, 1 )
			end

		},

		Cloth = {

			Init = function( self, templateId, texture, template )
				self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )

				self.Interval = 4000
				self.IntervalOffset = 500
				self.IntervalRandom = math.random( 1, self.Interval )
				self:Update()
			end,

			Update = function( self )

				local i, i2 = GetEasedInterval( self.Interval, self.IntervalRandom ), GetEasedInterval( self.Interval, self.IntervalRandom + self.IntervalOffset )
				local uv1, uv2, uv3, uv4 = 0.01 * i, 0.01 * i2, 0.02 * i, 0.02 * i2
				local c1, c2 = 0.95 - 0.05 * i, 0.95 - 0.05 * i2
				local r, g, b = self:GetColor()
				local p = self.Particles[1]
				local tex = p.Texture

				tex:SetVertexUV( 1, -0.05 + uv1, -0.05 - uv3 )
				tex:SetVertexUV( 2, 1.05 + uv2, -0.05 - uv4 )
				tex:SetVertexUV( 4, -0.05 + uv1, 1.05 + uv3 )
				tex:SetVertexUV( 8, 1.05 + uv2, 1.05 + uv4 )
				p:SetVertexColors( 1, r * c1, g * c1, b * c1, 1 )
				p:SetVertexColors( 2, r * c2, g * c2, b * c2, 1 )
				p:SetVertexColors( 4, r * c1, g * c1, b * c1, 1 )
				p:SetVertexColors( 8, r * c2, g * c2, b * c2, 1 )

			end,

		},

		Banner = {

			Init = function( self, templateId, texture, template )
				self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )

				self.Interval = 4000
				self.IntervalOffset = 500
				self.IntervalRandom = math.random( 1, self.Interval )
				self:Update()
			end,

			Update = function( self )

				local i, i2 = GetEasedInterval( self.Interval, self.IntervalRandom ), GetEasedInterval( self.Interval, self.IntervalRandom + self.IntervalOffset )
				local uv1, uv2, uv3, uv4 = 0.02 * i, 0.02 * i2, 0.03 * i, 0.03 * i2
				local c1, c2 = 0.8 - 0.2 * i, 0.8 - 0.2 * i2
				local r, g, b = self:GetColor()
				local p = self.Particles[1]
				local tex = p.Texture

				tex:SetVertexUV( 4, -0.1 + uv1, 1.1 + uv3 )
				tex:SetVertexUV( 8, 1.1 + uv2, 1.1 + uv4 )
				p:SetVertexColors( 4, r * c1, g * c1, b * c1, 1 )
				p:SetVertexColors( 8, r * c2, g * c2, b * c2, 1 )

			end,

		},

		Ethereal = {

			Init = function( self, templateId, texture, template )
				self.OrderDrawLevelByIndex = true
				self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, true, false )

				local p = self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 0,  1, 1,  true, false, false )
				p:SetDodge( true )
				p:SetSampleProcessing( 1, 1 )

				self.IntervalDuration = 9000
				self.IntervalOffset = math.random( 0, 9000 )
			end,

			Update = function( self )
				local interval1, interval2, interval3 = GetEasedInterval( self.IntervalDuration, self.IntervalOffset ), GetEasedInterval( self.IntervalDuration, self.IntervalOffset + 200 ), GetEasedInterval( self.IntervalDuration, self.IntervalOffset + 400 )
				local coeff = 0.5

				interval1, interval2, interval3 = zo_clamp( 0.5 + coeff * interval1, 0, 1 ), zo_clamp( 0.5 + coeff * interval2, 0, 1 ), zo_clamp( 0.5 + coeff * interval3, 0, 1 )

				local p2 = self.Particles[2]
				if p2 then
					p2:SetTextureRotation( 0.025 * GetEasedInterval( self.IntervalDuration ) * math.pi, self.IntervalOffset + 200 )
					p2:SetVertexColors( 1, 1, 1, 1, interval1 )
					p2:SetVertexColors( 2 + 4, 1, 1, 1, interval2 )
					p2:SetVertexColors( 8, 1, 1, 1, interval3 )
				end

				local p1 = self.Particles[1]
				if p1 then
					p1:SetAlpha( 0.5 + 0.5 * zo_clamp( interval2, 0, 1 ) )
				end
			end,

		},

		Billboard = {

			Update = function( self )
				local pitch, yaw, roll = self:GetOrientation()

				if 0 == pitch and 0 == roll then
					for index = 1, #self.Particles do
						self.Particles[index]:SetOrientation( nil, CameraHeading, nil )
					end
				end
			end,

		},

		Flipbook = {

			Init = function( self, templateId, texture, template )
				template.Count = #template.TextureCoords
				self.OrderDrawLevelByIndex = true

				for index = 1, template.Count do
					self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 0,  1, 1,  true, false, false )
				end

				self.Interval = template.Interval or 1000
				self.IntervalOffset = math.random( template.Interval )
			end,

			Update = function( self )
				local numP = #self.Particles
				local i = zo_clamp( 1 + math.floor( GetLinearInterval( self.Interval, self.IntervalOffset ) * numP ), 1, numP )

				self.Particles[i]:SetAlpha( 1 )

				for index = 1, numP do
					if index ~= i then
						self.Particles[index]:SetAlpha( 0 )
					end
				end
			end,

		},

		MaskedColor = {

			Init = function( self, templateId, texture, template )
				self.OrderDrawLevelByIndex = true
				self.TintRatio = template.TintRatio or 1
				self.TintAlpha = template.TintAlpha or 1

				local p = self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )
				p:SetAutoColorEnabled( false )
				p:SetColor( 1, 1, 1 )

				texture = GetCustomTemplateTexture( template.Id, 2 )
				local p = self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )
				p:SetAutoColorEnabled( false )
				p:SetSampleProcessing( 1, 0 )
				p:SetAdditive( true )
				p:SetColor( 1, 1, 1 )

				if template.TextureCoords then
					for index = 1, #self.Particles do
						self.Particles[index]:SetTextureCoords( template.TextureCoords[1], template.TextureCoords[2], template.TextureCoords[3], template.TextureCoords[4] )
					end
				end
			end,

			Reset = function( self )
				if not self.Particles or not self.Particles[1] then
					return
				end

				self:Update()
				self.Particles[1]:SetColor( 1, 1, 1 )

				local tintRange = self.TintRatio
				local tintBase = 1 - tintRange
				local r, g, b, a = self:GetColor()

				self.Particles[2]:SetColor( tintBase + tintRange * r, tintBase + tintRange * g, tintBase + tintRange * b, self.TintAlpha )
			end

		},

		Pattern = {

			MetaParams = {
				GetMetaParamByName( "Pattern Scale % (X)" ),
				GetMetaParamByName( "Pattern Scale % (Y)" )
			},

			Init = function( self, templateId, texture, template )
				self.TargetWidth, self.TargetHeight = template.SizeX, template.SizeY
				self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, true )
			end,
			
			Reset = function( self )
				if not self.Particles or not self.Particles[1] then
					return
				end

				local targetWidth, targetHeight = self.TargetWidth, self.TargetHeight

				self:Update()

				local sx, sy, sz = self:GetSize()
				sy = math.max( sy, sz )

				local scaleX = tonumber( self:GetMetaData( "Pattern Scale % (X)" ) )
				local scaleY = tonumber( self:GetMetaData( "Pattern Scale % (Y)" ) )

				if scaleX then
					scaleX = scaleX / 100
				else
					scaleX = 1
				end

				if scaleY then
					scaleY = scaleY / 100
				else
					scaleY = 1
				end

				local scaledX, scaledY = scaleX * targetWidth, scaleY * targetHeight
				local x1, x2 = 0, sx / scaledX
				local y1, y2 = 0, sy / scaledY

				self.Particles[1]:SetTextureCoords( x1, x2, y1, y2 )
			end,

		},

	}

	local function AddCustomTemplateEffect( template )

		local behavior = BEHAVIORS[ template.Behavior ]
		local init, update, reset, metaParams

		if behavior then
			init, update, reset, metaParams = behavior.Init, behavior.Update, behavior.Reset, behavior.MetaParams
		end

		if not init then
			init = function( self, templateId, texture )
				self:AddParticle( texture,  0, 0, 0,  0, 0, 0,  1, 1, 1, 1,  1, 1,  true, false, false )
			end
		end

		if not reset then
			reset = function( self )
				self:Update()
			end
		end

		return EHT.EffectType:New( template.Id, template.Name, {

			AutoPreview = template.AutoPreview,
			Category = ( template.Category or "Player Submissions" ),
			CanPitch = false ~= template.CanPitch,
			Template = template,
			Submitter = template.Submitter,
			MetaParams = metaParams,
			AutoUpdateDrawLevel = false ~= template.AutoUpdateDrawLevel,
			OrderDrawLevelByIndex = false ~= template.OrderDrawLevelByIndex,

			Init = function( self )

				local texture = GetCustomTemplateTexture( template.ImageId or template.Id )

				init( self, template.Id, texture, template )

				if template.TextureCoords and 1 <= #template.TextureCoords then
					if "table" == type( template.TextureCoords[1] ) then
						for index = 1, ( template.Count or 1 ) do
							self.Particles[index]:SetTextureCoords( template.TextureCoords[index][1], template.TextureCoords[index][2], template.TextureCoords[index][3], template.TextureCoords[index][4] )
						end
					else
						for index = 1, ( template.Count or 1 ) do
							self.Particles[index]:SetTextureCoords( template.TextureCoords[1], template.TextureCoords[2], template.TextureCoords[3], template.TextureCoords[4] )
						end
					end
				end

				local rgb = template.RGB or { 1, 1, 1 }
				self:SetColor( rgb[1], rgb[2], rgb[3], 1 )

				if template.Additive then
					self.Particles[1]:SetAdditive( true )
				end

				if template.SampleAlpha then
					self.Particles[1]:SetAdditive( template.SampleAlpha )
				end

				if template.Size then
					self:SetSize( template.Size, template.Size, template.Size )
				elseif template.SizeX then
					self:SetSize( template.SizeX, template.SizeY or template.SizeX, template.SizeZ or template.SizeX )
				end

				self:SetOrientation( template.Pitch, template.Yaw, template.Roll )
				self:SpawnAtPlayer( 0.5 * ( template.Size or template.SizeY or template.SizeX ), nil == template.Yaw )

			end,

			Update = update,
			Reset = reset,

		} )

	end


	for _, template in ipairs( CUSTOM_TEMPLATES ) do
		if template.DateAdded then
			EHT.EffectType:SetDefaultDateAdded( template.DateAdded )
		end

		if not template.Callback then
			AddCustomTemplateEffect( template )
		else
			template.Callback( template )
		end
	end


end

---[ Reserved Effects ]---

do
-- /sc EHT.EffectUI.AddEffect( "Reserved: Jumping" )
	local options =
	{
		autoAdjustTtl = false,
		respawnOnResize = false,
		category = CAT.NONE,
		cameraFacing = false,
		orderDrawLevelByIndex = false,
		emissionInterval = 6000,
		emissionFrequency = 100,
		minEmissions = 1,
		maxEmissions = 10,
		minVelocityY = 150,
		maxVelocityY = 300,
		sizeX = 130,
		sizeY = 200,
		minSize = 1,
		maxSize = 1,
		minSizeY = 20,
		maxSizeY = 20,
		minGrowth = 1,
		maxGrowth = 8,
		pulseInterval = 2,
		vectorPattern = EHT.ParticleEmitter.PATTERNS.LINEAR,
	}
	local et = CreateParticleEmitter( 10001, "Reserved: Jumping", options )
	et.UniqueClass = "Reserved: Jumping"
	et.Reserved = true
	local initFunc = et.Init
	et.Init = function( self, ... )
		initFunc( self, ... )
		self:SpawnAtPlayer( 140, true, 100 )
	end
end

do
-- /sc EHT.EffectUI.AddEffect( "Reserved: Guestbook" )
	local currentGuestbook
	local prompted = false
	local canShowGuestbook = false
	local lastSummonHouseId, lastSummonHouseOwner

	local function showGuestbook()
		if EHT.Effect:CanShowGuestbook() then
			EHT.UI.ShowGuestbook()
		end
	end

	function EHT.Effect:CanShowGuestbook()
		return canShowGuestbook
	end
	
	function EHT.Effect:GetCurrentGuestbookEffect()
		return currentGuestbook
	end

	function EHT.Effect:SummonGuestbook( force )
		local houseId = EHT.Housing.GetHouseId()
		local owner = EHT.Housing.GetHouseOwner()
		
		if houseId and 0 ~= houseId and owner and "" ~= owner and EssentialHousingHub:IsOpenHouse( houseId, owner ) then
			local isOwner = EHT.Housing.IsOwner()
			local hideSigned = EHT.GetSetting( "HideSignedGuestJournals" )
			if	force or (
					( isOwner and not EHT.GetSetting( "HideMyGuestJournals" ) ) or
					( not isOwner and ( not hideSigned or not EssentialHousingHub:HasSignedGuestbook() ) )
				) then
				if not force then
					if lastSummonHouseId == houseId and lastSummonHouseOwner == owner then
						return
					end

					if hideSigned and EssentialHousingHub:HasLocalPlayerRecentlySignedGuestJournal() then
						return
					end
				end

				lastSummonHouseId, lastSummonHouseOwner = houseId, owner
				EHT.EffectUI.AddEffect( "Reserved: Guestbook" )
				return true
			end
		end

		return false
	end

	function EHT.Effect:DismissGuestbook()
		if currentGuestbook then
			currentGuestbook:Delete()
		end

		if prompted then
			EHT.UI.HideInteractionPrompt()
			prompted = false
		end
	end

	local et = EHT.EffectType:New( 10002, "Reserved: Guestbook", {
		Category = CAT.NONE,
		OrderDrawLevelByIndex = true,
		ResetOnColor = false,
		ResetOnOrient = false,
		ResetOnPosition = false,
		ResetOnScale = false,
		--Reserved = true,
		--UniqueClass = "Reserved: Guestbook",

		Init = function( self )
			EHT.Effect:DismissGuestbook()

			self.IntervalMS = 4000
			self.SpawnMS = GetFrameTimeMilliseconds()

			self:AddParticle( TEXTURES.ICON_GUESTBOOK,	0, 0, 0,			0, 0, 0,	1, 1, 1, 1,		1, 1,		true, false, false )
			self:AddParticle( TEXTURES.ICON_QUILL,		0.02, -10, 22,		0, 0, 0,	1, 1, 1, 1,		0.3, 0.4,	true, false, false )

			self:SetSize( 42, 50, 50 )
			self:SetColor( 1, 1, 1, 1 )
			self:SetOrientation( 0, 0, 0 )
			self:MoveToPlayer( 0, -30, -300, true )
			self.ReticleRadius = 0.8 * math.max( self:GetSize() )
			self.SpawnPosition = { self:GetPosition() }

			currentGuestbook = self
		end,

		Update = function( self )
			local spawn = FrameTime - self.SpawnMS
			local interval = GetEasedInterval( self.IntervalMS )
			local samplingOffset, yawOffset = 0, 0
			local p1, p2 = self.Particles[1], self.Particles[2]

			if spawn < 5000 then
				samplingOffset = 10 - 10 * EaseIn2( math.min( 1, spawn / 3000 ) )

				local plumeFade = math.min( 1, ( spawn - 2800 ) / 1000 )
				p2:SetColorOffsets( 1, 1, 1, 0 < plumeFade and EaseOut2( 1 - plumeFade ) or 0 )

				local yOffset
				if 2500 > spawn then
					yOffset = 230 * EaseOut2( 1 - math.min( 1, spawn / 2500 ) )
				else
					local subinterval = EaseIn2( 1 - math.min( 1, ( spawn - 2500 ) / 2000 ) )
					yOffset = 210 + 20 * subinterval
				end

				local tx1 = 2 / 256
				local tx2 = 1 - tx1
				if 1700 > spawn then
					p1:SetTextureCoords( tx1, tx2, 0, 0.1 )
					p1:SetSizeOffsets( 1, 0.1 )
				else
					if not self.UnrollSoundPlayed then
						self.UnrollSoundPlayed = true
						if EHT.GetSetting( "EnableGuestJournalAudio" ) then
							PlaySound( "LevelUpReward_Fanfare" )
						end
					end

					local subinterval = math.min( 1, ( spawn - 1700 ) / 800 )
					p1:SetTextureCoords( tx1, tx2, 0, 0.1 + subinterval * 0.9 )
					p1:SetSizeOffsets( 1, 0.1 + subinterval * 0.9 )
				end

				yawOffset = EaseOut2( 1 - math.min( 1, spawn / 3000 ) ) * 2 * RAD360

				local x, y, z = unpack( self.SpawnPosition )
				self:SetPosition( x, y + yOffset, z )
			end

			local currentHour = EHT.Util.GetInGameTime()
			local currentYaw = yawOffset + CameraHeading
			local baseSampling = 1.2
			
			if currentHour > 12 then
				local hourSampling = 0.5 - math.abs(-0.5 + (((RAD270 - currentYaw) % RAD360) / RAD360))
				baseSampling = baseSampling - hourSampling
			else
				local hourSampling = 0.5 - math.abs(-0.5 + (((RAD90 - currentYaw) % RAD360) / RAD360))
				baseSampling = baseSampling - hourSampling
			end

			p1:SetSampleProcessing( baseSampling + 0.12 * (1 - interval) + samplingOffset )
			p2:SetSampleProcessing( 0.95 + 0.1 * interval )
			p2:SetOrientationOffsets( 0.1 * math.pi * GetEasedInterval( 900 ), -0.2 * math.pi + 0.015 * math.pi * GetEasedInterval( 1000 ), 0.015 * math.pi * GetEasedInterval( 800 ) )

			self:SetOrientation( 0.05 * math.pi * interval - 0.1 * math.pi, currentYaw, 0 )
			
			local currentX, currentY, currentZ = self:GetPosition()
			local targetX, targetY, targetZ = PlayerX, PlayerY, PlayerZ
			targetX, targetZ = targetX - 300 * math.sin(CameraHeading), targetZ - 300 * math.cos(CameraHeading)
			targetY = targetY + 120

			local minDistance = self.isFollowingPlayer and 100 or 400
			if minDistance < zo_distance3D(currentX, currentY, currentZ, targetX, targetY, targetZ) then
				local interX = currentX + (targetX - currentX) * 0.005
				local interY = currentY + (targetY - currentY) * 0.005
				local interZ = currentZ + (targetZ - currentZ) * 0.005
				self:SetPosition(interX, interY, interZ)
				self.isFollowingPlayer = true
			else
				self.isFollowingPlayer = false
			end
			
			self:Update()
			
			if EHT.Housing.IsHUDMode() and not IsGameCameraUIModeActive() and EHT.UI.IsBookHidden() and 700 > self:GetPlayerDistance() and self.ReticleRadius >= GetMinReticleDistance( self.Particles[1]:GetPosition() ) and EHT.UI.IsLorebookSelectionDialogHidden() then
				canShowGuestbook = true

				if self.lastClickCheck and EHT.LastMouseClick >= self.lastClickCheck then
					showGuestbook()
				elseif not prompted then
					EHT.UI.ShowInteractionPrompt( "EHT_SHOW_GUEST_JOURNAL", "Show Guest Journal", showGuestbook )
					prompted = true
				end
			elseif prompted then
				canShowGuestbook = false
				prompted = false

				EHT.UI.HideInteractionPrompt()
			end

			self.lastClickCheck = FrameTime
		end,

		Reset = function( self )
		end,

		Destroy = function( self )
			if self == currentGuestbook then
				canShowGuestbook = false
				currentGuestbook = nil
			end

			if EHT.GetSetting( "EnableGuestJournalAudio" ) then
				PlaySound( "CrownCrates_Cards_Reveal_All" )
			end

			EHT.UI.HideInteractionPrompt()
		end
	} )

	et.UniqueClass = "Reserved: Guestbook"
	et.Reserved = true
end

do
	EHT.TargetFurnitureEffect = { }
-- /sc EHT.EffectUI.AddEffect( "Reserved: Target Furniture" )
	local et = EHT.EffectType:New( 10003, "Reserved: Target Furniture", {
		Category = CAT.NONE,
		CanPitch = true,
		OrderDrawLevelByIndex = true,
		ResetOnOrient = true,
		ResetOnPosition = true,
		ResetOnScale = true,
		Reserved = true,
		ProximityTTL = 5000,
		MaxTTL = 15000,

		Init = function( self )
			self:SetAutoColorEnabled( false )
			self:SetAutoOrientationEnabled( false )
			self:SetAutoPositionEnabled( false )
			self:SetAutoSizeEnabled( false )

			self:SetSize( 1, 1, 1 )
			self:SetColor( 0.65, 1, 1, 1 )

			local p = self:AddParticle( TEXTURES.ICON_BREADCRUMB,	0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	false, false, true )
			p:SetColor( 0.65, 1, 1, 1 )

			self.SelfDestructMS = FrameTime + self.EffectType.MaxTTL
			self.NextUpdateMS = 0
		end,

		Update = function( self )
			local p = self.Particles[1]
			local proximityTTL = self.EffectType.ProximityTTL

			if self.FurnitureId then
				if self.NextUpdateMS <= FrameTime then
					local fx, fy, fz = EHT.Housing.GetFurnitureCenter( self.FurnitureId )
					if 0 ~= fx and 0 ~= fy and 0 ~= fz then
						-- Position
						local cx, cy, cz = PlayerX, PlayerY - 75, PlayerZ
						local x, y, z = 0.5 * ( cx + fx ), 0.5 * ( cy + fy ), 0.5 * ( cz + fz )
						local distance = zo_distance3D( cx, cy, cz, fx, fy, fz )
						local cappedDistance = math.max( 10, distance - 50 )

						-- Orientation
						local dx, dy, dz = cx - fx, cy - fy, cz - fz
						local yaw = math.atan2( dx, dz )
						local pitch = math.atan2( math.sin( yaw ) * dx + math.cos( yaw ) * dz, dy )

						p:SetPosition( x, y, z )
						p:SetOrientation( pitch, yaw, 0 )
						p:SetSize( 40, cappedDistance )
						p:SetColor( 0.65, 1, 1, 1 )
						p:SetSampleProcessing( 2 )
						self.TexturePatternInstances = cappedDistance * 0.0125

						local proximityDestructMS = FrameTime + proximityTTL
						if proximityDestructMS < self.SelfDestructMS then
							if not self.SelfDestructDistance then
								local maxDimension = math.max( EHT.Housing.GetFurnitureDimensions( self.FurnitureId ) )
								self.SelfDestructDistance = 1000 + maxDimension
							end

							local distance2D = zo_distance( cx, cz, fx, fz )
							if distance2D < self.SelfDestructDistance then
								self.SelfDestructMS = proximityDestructMS
							end
						end
					end

					self.NextUpdateMS = FrameTime + 750
				end

				local selfDestructAlpha
				local selfDestructMS = self.SelfDestructMS - FrameTime
				if selfDestructMS <= proximityTTL then
					selfDestructAlpha = VariableEaseIn( math.max( 0, selfDestructMS / proximityTTL ), 1.5 )
					if 0 == selfDestructAlpha then
						self:Delete()
						return
					end
				end

				local interval = 1 - GetLinearInterval( 1500 )
				local ty1, ty2 = interval, ( self.TexturePatternInstances or 0 ) + interval
				p:SetTextureCoords( 0, 1, ty1, ty2 )
				local alphaP = 0.25 + 0.75 * ( 1 - math.sin( RAD180 * GetLinearInterval( 1250 ) ) )
				if selfDestructAlpha then
					p:SetAlpha( alphaP * selfDestructAlpha )
				else
					p:SetAlpha( alphaP )
				end
				
				local trackingInterval = GetLinearInterval( 2000 )
				if self.TrackingFurniture and trackingInterval > 0.5 then
					self.TrackingFurniture = false
					ResetHousingEditorTrackedFurnitureId()
				elseif not self.TrackingFurniture and trackingInterval <= 0.5 then
					self.TrackingFurniture = true
					SetHousingEditorTrackedFurnitureId( self.FurnitureId )
				end
			end
		end,

		Destroy = function( self )
			ResetHousingEditorTrackedFurnitureId()

			for key, effect in pairs( EHT.TargetFurnitureEffect ) do
				if effect == self then
					EHT.TargetFurnitureEffect[key] = nil
				end
			end
		end,
	} )

	function EHT.EffectUI.ClearTargetFurniture( key )
--[[
		local effect = EHT.TargetFurnitureEffect[ key ]
		if effect then
			local id = effect.FurnitureId
			effect:Delete()
			EHT.TargetFurnitureEffect[ key ] = nil
			return id
		end
]]
	end

	function EHT.EffectUI.SetTargetFurniture( key, furnitureId )
--[[
		if EHT.TargetFurnitureEffect[ key ] then
			local previousFurnitureId = EHT.EffectUI.ClearTargetFurniture( key )
			if previousFurnitureId and string.fromId64( previousFurnitureId ) == string.fromId64( furnitureId ) then
				return false
			end
		end

		local id = EHT.Housing.FindFurnitureId( furnitureId )
		if id then
			local record, effect = EHT.EffectUI.AddEffect( "Reserved: Target Furniture" )
			effect.FurnitureId = id
			EHT.TargetFurnitureEffect[ key ] = effect
			return true
		end
		
		return false
]]
	end
end

do
	local poiIntervalMS = 6000
	local poiVerticalOffset = 275
	local poiEffects = { }
	local tcx1, tcx2 = 0, 1
	local tcy1, tcy2 = 0, 1

	EHT.TradeskillTypeNames = { }
	EHT.Effect.POIFurnitureCategoryEffectTypes = { }
	EHT.Effect.POITradeskillEffectTypes = { }

	local function SetPOIFurnitureId( self, furnitureId )
		self.FurnitureId = furnitureId
	end
	
	local function OnUpdatePOIEffects()
		if nil == next( poiEffects ) then
			EVENT_MANAGER:UnregisterForUpdate( "EHT.OnUpdatePOIEffects" )
			return
		end

		local interval = -0.1 * VariableEase( GetLinearInterval( poiIntervalMS ), 2 )
		tcy1, tcy2 = interval, interval + 1.1
	end

	local function AddPOIEffect( id, defaultColor, effectTypeName, texture, textureCoords, realTimeUpdating )
		local et = EHT.EffectType:New( id, effectTypeName, {
			Category = CAT.NONE,
			CanPitch = true,
			OrderDrawLevelByIndex = true,
			ResetOnOrient = true,
			ResetOnPosition = true,
			ResetOnScale = true,
			Reserved = true,
			Init = function( self )
				poiEffects[self] = true
				self.RealTimeUpdating = realTimeUpdating
				self:SetAutoColorEnabled( false )
				self:SetAutoOrientationEnabled( false )
				self:SetAutoPositionEnabled( false )
				self:SetAutoSizeEnabled( false )
				self:SetCameraFacing( true )
				self:SetSize( 64, 64, 64 )
				self:SetColor( 1, 1, 1, 1 )

				self.Icon = self:AddParticle( texture,	0, 0, 0,	0, 0, 0,	1, 1, 1, 1,		1, 1,	false, false, false )
				self.Icon:SetHidden( true )
				self.Icon:SetSampleProcessing( 1.6 )

				if textureCoords then
					local x1, x2, y1, y2 = unpack( textureCoords )
					self.Icon:SetTextureCoords( x1, x2, y1, y2 )
					self.IconTC = { x1 - 0.1, x2 + 0.1 }
				else
					self.IconTC = { -0.1, 1.1 }
				end

				local color = EHT.Util.CloneTable( defaultColor )
				local desaturation = 0
				if EHT.GetSetting( "EnablePOIColors" ) then
					desaturation = 0
				else
					color = { 1, 1, 1, 1, }
					desaturation = 1
				end

				if "number" == type( color[1] ) then
					local r, g, b, a = unpack( color )
					color = { }
					for i = 0, 3 do
						local c = 1
						table.insert( color, { r * c, g * c, b * c, a } )
					end
				end

				local alpha = EHT.Effect.POIEffectAlpha
				self.Icon:SetColor( unpack( color[1] ) )
				self.Icon:SetAlpha( alpha )
				self.Icon:SetDesaturation( desaturation )

				for i = 1, 4 do
					local c = color[i]
					self.Icon:SetVertexColors( 2 ^ i, c[1], c[2], c[3], c[4] * alpha )
				end

				self.FurnitureId = nil
				self.IsFurnitureValid = nil
				self.NextUpdateMS = 0
				self.SetFurnitureId = SetPOIFurnitureId

				EVENT_MANAGER:RegisterForUpdate( "EHT.OnUpdatePOIEffects", 1, OnUpdatePOIEffects )
			end,
			Update = function( self )
				if self.FurnitureId then
					local icon = self.Icon

					if self.NextUpdateMS <= FrameTime then
						local x, y, z, pitch, yaw, roll = EHT.Housing.FastGetFurniturePositionAndOrientation( self.FurnitureId )
						if 0 == x and 0 == y and 0 == z then
							icon:SetHidden( true )

							self.IsFurnitureValid = nil
						else
							x, y, z = EHT.Housing.GetFurnitureCenter( self.FurnitureId, x, y, z, pitch, yaw, roll )
							x, y, z = EHT.Housing.GetFurnitureEdgeFromCenter( self.FurnitureId, 0, -1, 0, x, y, z, pitch, yaw, roll )
							y = y + poiVerticalOffset

							icon:SetPosition( x, y, z )
							icon:SetHidden( false )

							self.IsFurnitureValid = true
						end

						self.NextUpdateMS = self.RealTimeUpdating and 1 or ( FrameTime + 5000 )
					end

					if self.IsFurnitureValid then
						local cameraDepth = icon:GetCameraDepth()
						local width = GetWorldDimensionsOfViewFrustumAtDepth( cameraDepth )
						local scale = 0.5 * ( width / EHT.Effect.ViewWidth )
						local size = EHT.Effect.POIEffectDimensions + scale * EHT.Effect.POIEffectDimensions
						icon:SetSize( size, size * 1.1 )
						icon:SetTextureCoords( tcx1, tcx2, tcy1, tcy2 )
					end
				end
			end,
			Destroy = function( self )
				poiEffects[self] = nil
			end,
		} )

		return et
	end

	local function AddTradeskillPOIEffect( id, defaultColor, tradeskillType, name, texture, textureCoords )
		local effectTypeName = string.format( "Reserved: POI, %s", name )
		local UPDATE_PERIODICALLY = false
		local et = AddPOIEffect( id, defaultColor, effectTypeName, texture, textureCoords, UPDATE_PERIODICALLY )

		local skillType, skillIndex = GetCraftingSkillLineIndices( tradeskillType )
		local skillName = GetSkillLineInfo( skillType, skillIndex )
		if "" == skillName then
			skillName = name
		end
		EHT.TradeskillTypeNames[ tradeskillType ] = skillName

		local keywords = { }
		table.insert( keywords, skillName )
		for keywordIndex, keyword in ipairs( keywords ) do
			keywords[keywordIndex] = string.lower( keyword )
		end

		EHT.Effect.POITradeskillEffectTypes[ tradeskillType ] =
		{
			TradeskillType = tradeskillType,
			Keywords = keywords,
			Name = effectTypeName,
			Type = et,
		}
	end

	local function AddFurnitureCategoryPOIEffect( id, defaultColor, categoryId, name, texture, textureCoords )
		local effectTypeName = string.format( "Reserved: POI, %s", name )
		local UPDATE_REAL_TIME = true
		local et = AddPOIEffect( id, defaultColor, effectTypeName, texture, textureCoords, UPDATE_REAL_TIME )

		EHT.Effect.POIFurnitureCategoryEffectTypes[ categoryId ] =
		{
			FurnitureCategoryId = categoryId,
			Keywords = { },
			Name = effectTypeName,
			Type = et,
		}
	end

	local CRAFTING_TYPE_STYLE = 10
	local CRAFTING_TYPE_TRANSMUTE = 11
	local COLOR =
	{
		{ 1, 1, 0.9, 1 },
		{ 0.8, 0.6, 0.2, 1 },
		{ 0.22, 0.08, 0, 1 },
		{ 0.2, 0.06, 0, 1 },
	}

	AddTradeskillPOIEffect( 10100, COLOR, CRAFTING_TYPE_ALCHEMY, "Alchemy", TEXTURES.ICON_POI_ALCHEMY )
	AddTradeskillPOIEffect( 10101, COLOR, CRAFTING_TYPE_BLACKSMITHING, "Blacksmithing", TEXTURES.ICON_POI_SMITHING )
	AddTradeskillPOIEffect( 10102, COLOR, CRAFTING_TYPE_CLOTHIER, "Clothing", TEXTURES.ICON_POI_CLOTHING )
	AddTradeskillPOIEffect( 10103, COLOR, CRAFTING_TYPE_STYLE, "Dye", TEXTURES.ICON_POI_STYLE )
	AddTradeskillPOIEffect( 10104, COLOR, CRAFTING_TYPE_ENCHANTING, "Enchant", TEXTURES.ICON_POI_ENCHANTING )
	AddTradeskillPOIEffect( 10105, COLOR, CRAFTING_TYPE_JEWELRYCRAFTING, "Jewelry", TEXTURES.ICON_POI_JEWELRY )
	AddTradeskillPOIEffect( 10106, COLOR, CRAFTING_TYPE_PROVISIONING, "Provisioning", TEXTURES.ICON_POI_PROVISIONING )
	AddTradeskillPOIEffect( 10107, COLOR, CRAFTING_TYPE_TRANSMUTE, "Transmute", TEXTURES.ICON_POI_RETRAIT )
	AddTradeskillPOIEffect( 10108, COLOR, CRAFTING_TYPE_WOODWORKING, "Woodworking", TEXTURES.ICON_POI_WOODWORKING )

	AddFurnitureCategoryPOIEffect( 10120, COLOR, EHT.CONST.FURNITURE_CATEGORY_ID.ASSISTANT_BANKERS, "Banker", TEXTURES.ICON_POI_BANKER )
	AddFurnitureCategoryPOIEffect( 10121, COLOR, EHT.CONST.FURNITURE_CATEGORY_ID.ASSISTANT_MERCHANTS, "Merchant", TEXTURES.ICON_POI_MERCHANT )
--[[
	AddTradeskillPOIEffect( 10100, { 0.0, 0.75, 0.0, 1 }, CRAFTING_TYPE_ALCHEMY, "Alchemy", TEXTURES.ICON_POI_ALCHEMY )
	AddTradeskillPOIEffect( 10101, { 0.8, 0.15, 0.0, 1 }, CRAFTING_TYPE_BLACKSMITHING, "Blacksmithing", TEXTURES.ICON_POI_SMITHING )
	AddTradeskillPOIEffect( 10102, { 0.5, 0.5, 0.5, 1 }, CRAFTING_TYPE_CLOTHIER, "Clothing", TEXTURES.ICON_POI_CLOTHING )
	local dyeColors =
	{
		{ 1.0, 0.5, 0.0, 1 },
		{ 0.0, 0.5, 1.0, 1 },
		{ 1.0, 0.0, 1.0, 1 },
		{ 1.0, 0.0, 1.0, 1 },
	}
	AddTradeskillPOIEffect( 10103, dyeColors, CRAFTING_TYPE_STYLE, "Dye", TEXTURES.ICON_POI_STYLE, { -0.15, 1.15, -0.15, 1.15 } )
	AddTradeskillPOIEffect( 10104, { 0.4, 0.1, 1.0, 1 }, CRAFTING_TYPE_ENCHANTING, "Enchant", TEXTURES.ICON_POI_ENCHANTING )
	AddTradeskillPOIEffect( 10105, { 0.9, 0.9, 0.0, 1 }, CRAFTING_TYPE_JEWELRYCRAFTING, "Jewelry", TEXTURES.ICON_POI_JEWELRY )
	AddTradeskillPOIEffect( 10106, { 0.8, 0.4, 0.0, 1 }, CRAFTING_TYPE_PROVISIONING, "Provisioning", TEXTURES.ICON_POI_PROVISIONING )
	local transmuteColors =
	{
		{ 0.0, 0.85, 1.0, 1 },
		{ 0.7, 0.0, 1.0, 1 },
		{ 0.7, 0.0, 1.0, 1 },
		{ 0.7, 0.0, 1.0, 1 },
	}
	AddTradeskillPOIEffect( 10107, transmuteColors, CRAFTING_TYPE_TRANSMUTE, "Transmute", TEXTURES.ICON_POI_RETRAIT )
	AddTradeskillPOIEffect( 10108, { 0.5, 0.2, 0.0, 1 }, CRAFTING_TYPE_WOODWORKING, "Woodworking", TEXTURES.ICON_POI_WOODWORKING )

	AddFurnitureCategoryPOIEffect( 10120, { 1, 0.8, 0, 1 }, EHT.CONST.FURNITURE_CATEGORY_ID.ASSISTANT_BANKERS, "Banker", TEXTURES.ICON_POI_BANKER )
	AddFurnitureCategoryPOIEffect( 10121, { 1, 1, 1, 1 }, EHT.CONST.FURNITURE_CATEGORY_ID.ASSISTANT_MERCHANTS, "Merchant", TEXTURES.ICON_POI_MERCHANT )
]]
end

function EHT.Effect:GetPOIEffectTypeNameByItemOrSet( link, setFilters )
	local furnitureDataId = GetItemLinkFurnitureDataId( link )
	if not furnitureDataId or 0 == furnitureDataId then
		furnitureDataId = GetCollectibleFurnitureDataId( GetCollectibleIdFromLink( link ) )
	end
	local categoryId, subcategoryId = GetFurnitureDataCategoryInfo( furnitureDataId )

	if ( categoryId and 0 ~= categoryId ) or ( subcategoryId and 0 ~= subcategoryId ) then
		for _, effectTypeInfo in pairs( EHT.Effect.POIFurnitureCategoryEffectTypes ) do
			if	( categoryId and 0 ~= categoryId and effectTypeInfo.FurnitureCategoryId == categoryId ) or
				( subcategoryId and 0 ~= subcategoryId and effectTypeInfo.FurnitureCategoryId == subcategoryId ) then
				return effectTypeInfo.Name
			end
		end
	end

	local itemName = string.lower( GetItemLinkName( link ) )
	local itemSetName = string.lower( EHT.Housing.GetFurnitureLinkSetName( link ) )

	for _, effectTypeInfo in pairs( EHT.Effect.POITradeskillEffectTypes ) do
		for _, keyword in ipairs( effectTypeInfo.Keywords ) do
			if string.find( itemName, keyword ) then
				if not setFilters then
					return effectTypeInfo.Name
				else
					for _, setFilter in ipairs( setFilters ) do
						if effectTypeInfo.TradeskillType == setFilter.craftType and itemSetName == string.lower( setFilter.name ) then
							return effectTypeInfo.Name
						end
					end
					return nil
				end
			end
		end
	end

	return nil
end

function EHT.EffectUI.RefreshPOIEffects()
	EVENT_MANAGER:UnregisterForUpdate( "EHT.QueueRefreshPOIEffects" )
	EVENT_MANAGER:RegisterForUpdate( "EHT.QueueRefreshPOIEffects", 2000, EHT.EffectUI.RefreshPOIEffectsProcess )
end

if EHT.IsDev then
	SLASH_COMMANDS[ "/refreshpois" ] = EHT.EffectUI.RefreshPOIEffects
end

function EHT.EffectUI.RefreshPOIEffectsProcess()
	EVENT_MANAGER:UnregisterForUpdate( "EHT.QueueRefreshPOIEffects" )

	if not EHT.Housing.IsHouseZone() then
		return
	end

	if not EHT.Util.IsItemSetDiscoveryComplete() then
		-- Item set discovery is pending; queue and check again.
		EHT.EffectUI.RefreshPOIEffects()
		return
	end

	-- Delete old POI marker effects.
	if EHT.POIEffects then
		for _, effect in ipairs( EHT.POIEffects ) do
			effect:Delete()
		end
	end

	EHT.POIEffects = { }
	--EHT.Effect.NumActivePOIEffects = 0

	if EHT.EffectUI.IsPreviewingEffects() then
		return
	end

	local showPOIs = EHT.GetSetting( "ShowPOIs" )
	local showAssistantPOIs = EHT.GetSetting( "ShowAssistantPOIs" )
	local showBasicStationPOIs = EHT.GetSetting( "ShowCraftingStationPOIs" )
	local showWritPOIs = EHT.GetSetting( "ShowMasterWritPOIs" )

	-- Abort if no POIs are enabled.
	if not showPOIs or ( not showAssistantPOIs and not showBasicStationPOIs and not showWritPOIs ) then
		return
	end

	EHT.Effect.POIEffectDimensions = zo_lerp( 25, 100, EHT.GetSetting( "POIMarkerScale" ) or 0.5 )
	EHT.Effect.POIEffectAlpha = zo_lerp( 0.5, 1, EHT.GetSetting( "POIMarkerAlpha" ) or 0.5 )

	-- Instantiate new Assistant POI effects.
	if showAssistantPOIs then
		local POIs = EHT.Housing.GetAllAssistants()
		for _, POI in ipairs( POIs ) do
			local link = POI.Link
			local effectTypeName = EHT.Effect:GetPOIEffectTypeNameByItemOrSet( link )
			if effectTypeName then
				local effectRecord, effect = EHT.EffectUI.AddEffect( effectTypeName )
				effect:SetFurnitureId( EHT.Housing.FindFurnitureId( POI.Id ) )
				table.insert( EHT.POIEffects, effect )
			end
		end
	end

	-- Instantiate new Station POI effects.
	if showBasicStationPOIs or showWritPOIs then
		local setFilters = EHT.Util.GetMasterWritSetFilters() or { }
		local POIs = EHT.Housing.GetAllCraftingStations()
		for _, POI in ipairs( POIs ) do
			local link = POI.Link
			local itemName = GetItemLinkName( link )
			local itemSetFilters

			if string.find( itemName, "%(" ) then
				itemSetFilters = setFilters
			end

			if ( showBasicStationPOIs and not itemSetFilters ) or ( showWritPOIs and itemSetFilters ) then
				local effectTypeName = EHT.Effect:GetPOIEffectTypeNameByItemOrSet( link, itemSetFilters )
				if effectTypeName then
					local effectRecord, effect = EHT.EffectUI.AddEffect( effectTypeName )
					effect:SetFurnitureId( EHT.Housing.FindFurnitureId( POI.Id ) )
					table.insert( EHT.POIEffects, effect )
				end
			end
		end
	end
end

---[ Utilities ]---

if EHT.IsDev then
	SLASH_COMMANDS[ "/deff" ] = function( index )

		index = tonumber( index )
		if not index then
			d( "Effect index is required." )
			return
		end

		local effect = EffectList[index]
		if not effect then
			df( "Effect index %d does not exist.", index )
			return
		end

		local houseId = GetCurrentZoneHouseId()
		local collectibleId = GetCollectibleIdForHouse( houseId )
		local houseName = GetCollectibleName( collectibleId )
		local x, y, z = effect:GetPosition()
		local pitch, yaw, roll = effect:GetOrientation()
		local sizeX, sizeY, sizeZ = effect:GetSize()

		local s = string.format(
			"\t[\"%d\"] = { X = %d, Y = %d, Z = %d, SizeX = %d, SizeY = %d, SizeZ = %d, Pitch = math.rad( %d ), Yaw = math.rad( %d ), Roll = math.rad( %d ) }, -- %s",
			houseId, x, y, z, sizeX, sizeY, sizeZ, math.deg( pitch ), math.deg( yaw ), math.deg( roll ), houseName
		)

		CHAT_SYSTEM:StartTextEntry( s, CHAT_CHANNEL_SAY )
	end

	SLASH_COMMANDS[ "/sky" ] = function( param )
		if "" == param then
			EHT.EffectUI.AddEffect( "Aurora Borealis, Polar" )
		end

		zo_callLater( function()
			local e

			for index, eff in ipairs( EHT.Effect:GetAll() ) do
				if eff.EffectType.UniqueClass == "Sky Overlay" then e = eff break end
			end

			if not e then
				d( "No environmental sky effect found." )
			else
				local houseId, _, _, houseName = EHT.Housing.GetHouseInfo()
				local s = string.format( "[\"%d\"] = { X = %d, Y = %d, Z = %d, SizeX = %d, SizeY = %d, SizeZ = %d, Pitch = nil, Yaw = nil, Roll = nil }, -- %s",
					houseId, e.X, ( 0 < e.Y and e.Y or 1 ), e.Z, e.SizeX, e.SizeY, e.SizeZ, houseName )
				StartChatInput( s )
			end
		end, 500 )
	end

	SLASH_COMMANDS[ "/scenery" ] = function( param )
		if "" == param then
			EHT.EffectUI.AddEffect( "Mountains, Craglorn" )
		end

		zo_callLater( function()
			local e
			for index, eff in ipairs( EHT.Effect:GetAll() ) do
				if eff.EffectType.UniqueClass == CAT.SCENE then e = eff break end
			end

			if not e then
				d( "No environmental scenery effect found." )
			else
				local houseId, _, _, houseName = EHT.Housing.GetHouseInfo()
				local s = string.format( "[\"%d\"] = { X = %d, Y = %d, Z = %d, SizeX = %d, SizeY = %d, SizeZ = %d, Pitch = nil, Yaw = nil, Roll = nil }, -- %s",
					houseId, e.X, ( 0 < e.Y and e.Y or 1 ), e.Z, e.SizeX, e.SizeY, e.SizeZ, houseName )
				StartChatInput( s )
			end
		end, 500 )
	end

	do
		local testingFX = false
		local effectKey, effectType, effect, effectRecord

		local function CancelTestFXSharing()
			EVENT_MANAGER:UnregisterForUpdate( "TestFXSharing" )

			if effectRecord then
				EHT.Data.DeleteEffectRecord( effectRecord )
			end

			if effect then
				effect:Delete()
			end

			effectKey = nil
			effectType = nil
			effect = nil
			effectRecord = nil
			testingFX = false
			d( "Test ended." )
		end

		SLASH_COMMANDS[ "/testfxsharing" ] = function( param )
			local effectTypes = EHT.EffectType:GetAll()

			if testingFX then
				CancelTestFXSharing()
				return
			else
				testingFX = true
				d( "Test starting." )
			end

			EVENT_MANAGER:RegisterForUpdate( "TestFXSharing", 500, function()
				if effect then
					local messages = EHT.Effect:SerializeChatcast( false, nil, nil, false )

					if type( messages ) ~= "table" or #messages < 1 then
						d( "|cff8800* Effect type failed to serialize *" )
						CancelTestFXSharing()
						return
					end

					if effectRecord then
						EHT.Data.DeleteEffectRecord( effectRecord )
					end
					effect:Delete()

					effect = nil
					effectRecord = nil
				else
					effectKey, effectType = next( effectTypes, effectKey )

					if not effectKey or not effectType then
						CancelTestFXSharing()
						return
					end

					local effectTypeName = effectType:GetName()
					df( "Testing #%d: %s", tonumber( effectKey ) or -1, effectTypeName or "nil" )

					effectRecord, effect = EHT.EffectUI.AddEffect( effectTypeName, true )
				end
			end )
		end
	end

	do
		local testingFX = false
		local effectKey, effectType, testEffects
		local perfPhaseCounter, perfStartMS

		local function DeleteTestFX()
			if testEffects then
				for index, testEffect in ipairs( testEffects ) do
					local effectRecord, effect = testEffect[1], testEffect[2]
					effect:Delete()
					EHT.Data.DeleteEffectRecord( effectRecord, true )
				end
			end
			testEffects = nil
		end

		local function CancelTestFXPerf()
			EVENT_MANAGER:UnregisterForUpdate( "TestFXPerf" )
			SetShouldRenderWorld( true )

			DeleteTestFX()
			effectKey = nil
			effectType = nil
			testingFX = false

			d( "Test ended." )
		end
		
		SLASH_COMMANDS[ "/fxperfreport" ] = function( param )
			local perfData = EHT.SavedVars.FXPerf
			if not perfData then
				d( "No performance data collected." )
				return
			end

			local function CompareEffectPerf( left, right )
				return left[3] > right[3]
			end

			table.sort( perfData, CompareEffectPerf )

			local numEffects = #perfData
			local maxEffects = tonumber( param ) or 10
			maxEffects = math.min( maxEffects, numEffects )

			for index, data in ipairs(perfData) do
				df( "|c44aaaa%.2f%% |c88ffff%s|cffffff (#%d)|r", data[3], data[2], data[1] )
				if index >= maxEffects then
					break
				end
			end
			df( "|cffffff%d of %d effect(s) shown|r", maxEffects, numEffects )
		end

		SLASH_COMMANDS[ "/testfxperf" ] = function( param )
			local effectTypes = EHT.EffectType:GetAll()

			if "reset" == string.lower( param ) then
				DeleteTestFX()
				CancelTestFXPerf()
				EHT.SavedVars.LastFXPerfKey = nil
				EHT.SavedVars.FXPerf = nil
			end

			if testingFX then
				CancelTestFXPerf()
				return
			else
				SetShouldRenderWorld( false )
				EHT.SavedVars.FXPerf = EHT.SavedVars.FXPerf or { }
				perfPhaseCounter = 0

				effectKey = tonumber( param )
				if effectKey then
					effectKey = effectKey - 1
				else
					effectKey = tonumber( EHT.SavedVars.LastFXPerfKey )
				end

				testingFX = true
				d( "Test starting." )
			end

			EVENT_MANAGER:RegisterForUpdate( "TestFXPerf", 1000, function()
				perfPhaseCounter = perfPhaseCounter + 1

				if testEffects then
					if perfPhaseCounter == 2 then
						EHT.EffectUpdateCostMS = 0
						perfStartMS = GetGameTimeMilliseconds()
					elseif perfPhaseCounter > 2 then
						local perfEndMS = GetGameTimeMilliseconds()
						local perfTimeMS = perfEndMS - perfStartMS

						if perfTimeMS >= 4000 then
							local effect = testEffects[1][2]
							local effectUpdateCostMS = EHT.EffectUpdateCostMS
							local effectUpdateCostPercent = (effectUpdateCostMS / perfTimeMS) * 100
							local effectTypeIndex = effect:GetEffectTypeIndex()
							local effectTypeName = effect:GetEffectType():GetName()
							local perfDataTable = EHT.SavedVars.FXPerf
							local effectPerfData =
							{
								effectTypeIndex,
								effectTypeName,
								effectUpdateCostPercent,
							}

							local updated = false
							for i, e in ipairs(perfDataTable) do
								if effectTypeIndex == e.effectTypeIndex then
									perfDataTable[i] = effectPerfData
									updated = true
									break
								end
							end
							
							if not updated then
								table.insert(perfDataTable, effectPerfData)
							end

							df( "Effect %u. %s: Usage is %.2f%%", effectPerfData[1], effectPerfData[2], effectPerfData[3] )
							d( "_________________" )

							DeleteTestFX()
-- /script i=0 for k, v in pairs(EHT.SavedVars.FXPerf) do d(k) i=i+1 end df("%d effects", i)
						end
					end
				else
					repeat
						EHT.SavedVars.LastFXPerfKey = effectKey
						effectKey, effectType = next( effectTypes, effectKey )

						if not effectKey or not effectType then
							EHT.SavedVars.LastFXPerfKey = nil
							CancelTestFXPerf()
							zo_callLater(function() ReloadUI() end, 2000)

							return
						end
					until nil ~= effectType.Update

					local effectTypeName = effectType:GetName()
					local cameraYaw = GetPlayerCameraHeading()
					local offsetX, offsetZ = math.sin(cameraYaw) * 1000, math.cos(cameraYaw) * 1000

					testEffects = { }
					for testEffectIndex = 1, 10 do
						local testEffectEntry = { EHT.EffectUI.AddEffect( effectTypeName, true ) }
						local testEffect = testEffectEntry[2]
						local x, y, z = testEffect:GetPosition()
						testEffect:SetPosition(x - offsetX, y, z - offsetZ)
						testEffects[ testEffectIndex ] = testEffectEntry
					end

					perfPhaseCounter = 0
				end
			end )
		end
	end
end

function eff(eIndex) return EffectList[eIndex] end
function efp(eIndex,pIndex) return EffectList[eIndex].Particles[pIndex] end
function eft(eIndex,pIndex) return EffectList[eIndex].Particles[pIndex].Texture end

EHT.Modules = ( EHT.Modules or { } ) EHT.Modules.Effects = true
